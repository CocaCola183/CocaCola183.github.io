<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kivi</title>
  <subtitle>没有什么远大理想，只是永远都不会满足而已</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cocacola183.github.io/"/>
  <updated>2017-08-04T00:26:53.000Z</updated>
  <id>http://cocacola183.github.io/</id>
  
  <author>
    <name>kivi</name>
    <email>s_f_dragon@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mongodb生产部署建议</title>
    <link href="http://cocacola183.github.io/2017/07/10/mongo/mongodb%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2%E5%BB%BA%E8%AE%AE/"/>
    <id>http://cocacola183.github.io/2017/07/10/mongo/mongodb生产部署建议/</id>
    <published>2017-07-10T03:34:35.000Z</published>
    <updated>2017-08-04T00:26:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MongoDB二进制文件"><a href="#MongoDB二进制文件" class="headerlink" title="MongoDB二进制文件"></a>MongoDB二进制文件</h2><h3 id="支持的运行平台"><a href="#支持的运行平台" class="headerlink" title="支持的运行平台"></a>支持的运行平台</h3><ul>
<li><a href="https://docs.mongodb.com/manual/administration/production-notes/#x86-64" target="_blank" rel="external">x86_64</a></li>
<li><a href="https://docs.mongodb.com/manual/administration/production-notes/#arm64" target="_blank" rel="external">ARM64</a></li>
<li><a href="https://docs.mongodb.com/manual/administration/production-notes/#ppc64le-mongodb-enterprise-edition" target="_blank" rel="external">PPC64LE (MongoDB Enterprise Edition)</a></li>
<li><a href="https://docs.mongodb.com/manual/administration/production-notes/#s390x-mongodb-enterprise-edition" target="_blank" rel="external">s390x (MongoDB Enterprise Edition)</a></li>
</ul>
<a id="more"></a>
<h4 id="推荐的运行平台"><a href="#推荐的运行平台" class="headerlink" title="推荐的运行平台"></a>推荐的运行平台</h4><ul>
<li>Amazon Linux</li>
<li>Debian 7.1</li>
<li>RHEL / CentOS 6.2+</li>
<li>SLES 11+</li>
<li>Ubuntu LTS 12.04</li>
<li>Ubuntu LTS 14.04</li>
<li>Windows Server 2012 &amp; 2012 R2</li>
</ul>
<h4 id="推荐mongodb最新的release版本"><a href="#推荐mongodb最新的release版本" class="headerlink" title="推荐mongodb最新的release版本"></a>推荐mongodb最新的release版本</h4><h2 id="MongoDB-dbpath"><a href="#MongoDB-dbpath" class="headerlink" title="MongoDB dbpath"></a>MongoDB dbpath</h2><h3 id="并发性（基于不同的数据库引擎的比较）"><a href="#并发性（基于不同的数据库引擎的比较）" class="headerlink" title="并发性（基于不同的数据库引擎的比较）"></a>并发性（基于不同的数据库引擎的比较）</h3><h4 id="MMAPv1"><a href="#MMAPv1" class="headerlink" title="MMAPv1"></a>MMAPv1</h4><p>3.0之后的改动：3.0之后，MongoDB MMapv1提供文档级别的数据库锁：所有的集合都有一个唯一的读写锁，这意味着不同的集合可以同时执行更新操作</p>
<p>在2.2到2.6之间，每个数据库都有一个读写锁，允许并发读操作，但每个database同一时刻只能有一个写操作。在更早的版本中，在一个mongod进程中，所有的写操作抢占一个写锁</p>
<h4 id="WiredTiger"><a href="#WiredTiger" class="headerlink" title="WiredTiger"></a>WiredTiger</h4><p>wt单文档支持并发读写，客户端可在写操作执行期间进行读取操作，不同的线程也可以同时去修改一个集合的某一条数据</p>
<h2 id="Data-Consistency-数据一致性"><a href="#Data-Consistency-数据一致性" class="headerlink" title="Data Consistency(数据一致性)"></a>Data Consistency(数据一致性)</h2><h3 id="Journaling-日志"><a href="#Journaling-日志" class="headerlink" title="Journaling(日志)"></a>Journaling(日志)</h3><p>MongoDB的日志持久化在磁盘，并且使用的是预写式日志。如果遇到意外故障（例如断电），日志信息保证了MongoDB可以迅速恢复记录在日志中的但还没有记录到数据文件中的写操作。</p>
<h3 id="Read-Concern-数据读策略"><a href="#Read-Concern-数据读策略" class="headerlink" title="Read Concern(数据读策略)"></a>Read Concern(数据读策略)</h3><p><a href="http://www.mongoing.com/archives/3403" target="_blank" rel="external">这里</a>详细说明了数据度策略是什么以及解决的问题，以及<code>readConcern</code>和<code>readPreference</code>的比较。这里简单说明下：</p>
<blockquote><p>readConcern 的初衷在于解决『脏读』的问题，比如用户从 MongoDB 的 primary 上读取了某一条数据，但这条数据并没有同步到大多数节点，然后 primary 就故障了，重新恢复后 这个primary 节点会将未同步到大多数节点的数据回滚掉，导致用户读到了『脏数据』。</p>
<p>当指定 readConcern 级别为 majority 时，能保证用户读到的数据『已经写入到大多数节点』，而这样的数据肯定不会发生回滚，避免了脏读的问题。</p>
<p>需要注意的是，readConcern 能保证读到的数据『不会发生回滚』，但并不能保证读到的数据是最新的，这个官网上也有说明。</p>
<blockquote>
<p>Regardless of the read concern level, the most recent data on a node may not reflect the most recent version of the data in the system.</p>
</blockquote>
<p>有用户误以为，readConcern 指定为 majority 时，客户端会从大多数的节点读取数据，然后返回最新的数据。</p>
<p>实际上并不是这样，无论何种级别的 readConcern，客户端都只会从『某一个确定的节点』（具体是哪个节点由 readPreference 决定）读取数据，该节点根据自己看到的同步状态视图，只会返回已经同步到大多数节点的数据。</p>
<footer><strong>mongodb中文社区</strong><cite><a href="http://www.mongoing.com/archives/3403" target="_blank" rel="external">www.mongoing.com/archives/3403</a></cite></footer></blockquote>
<p>注意，读策略是MongoDB3.2加入的新特性，如果要使用读取『已经写入到大多数节点』的策略，除了要注意MongoDB的版本之外，还应该注意以下两点：</p>
<ul>
<li>启动mongod的时候，添加<code>--enableMajorityReadConcern</code>参数</li>
<li>副本集必须使用wt存储引擎，而且选举协议为<code>protocol version 1</code></li>
</ul>
<h3 id="Write-Concern-数据写策略"><a href="#Write-Concern-数据写策略" class="headerlink" title="Write Concern(数据写策略)"></a>Write Concern(数据写策略)</h3><p>写策略主要讨论的问题是MongoDB写操作的确认等级，写请求确认等级影响了写操作的速度。如果写确认等级比较低，写速度快，随着确认等级的升高，客户端可能要花更多的时间等待MongoDB进行写确认。如果说配置的写确认等级较低，有可能会出现写操作返回成功，但是并没有数据发生改变的情况</p>
<p>所以在生产环境使用MongoDB之前需要先考虑好合适的写操作确认等级</p>
<h2 id="Networking-网络"><a href="#Networking-网络" class="headerlink" title="Networking(网络)"></a>Networking(网络)</h2><h3 id="Use-Trusted-Networking-Environments-使用可信任的网络环境"><a href="#Use-Trusted-Networking-Environments-使用可信任的网络环境" class="headerlink" title="Use Trusted Networking Environments(使用可信任的网络环境)"></a>Use Trusted Networking Environments(使用可信任的网络环境)</h3><p>请在可信任的环境下运行MongoDB，通过网络保护策略保护MongoDB被任何非法的机器，系统，或者是网络访问（一般就是指在内网环境中启动运行MongoDB，只有同一内网的机器才有权限访问MongoDB）。如果必须暴露在网络环境中，MongoDB必须要配合相应的权限系统，监控系统等去保证MongDB不被非法访问。</p>
<blockquote>
<p>默认情况下，MongoDB的权限认证系统不会开启</p>
</blockquote>
<p>关于MongoDB的安全性，还有以下文章参考：</p>
<ul>
<li><a href="https://docs.mongodb.com/manual/administration/security-checklist/" target="_blank" rel="external">Security Checklist</a></li>
<li><a href="https://docs.mongodb.com/manual/core/security-mongodb-configuration/" target="_blank" rel="external">MongoDB Configuration Hardening</a></li>
<li><a href="https://docs.mongodb.com/manual/core/security-network/" target="_blank" rel="external">Hardening Network Infrastructure</a></li>
</ul>
<h3 id="Disable-HTTP-Interface-禁用http接口"><a href="#Disable-HTTP-Interface-禁用http接口" class="headerlink" title="Disable HTTP Interface(禁用http接口)"></a>Disable HTTP Interface(禁用http接口)</h3><p>MongoDB提供了一个http接口，用于检查节点状态，而且也可以用来执行一些脚本。http接口默认关闭，不能在生产环境开启http接口</p>
<h3 id="Manage-Connection-Pool-Sizes-连接池管理"><a href="#Manage-Connection-Pool-Sizes-连接池管理" class="headerlink" title="Manage Connection Pool Sizes(连接池管理)"></a>Manage Connection Pool Sizes(连接池管理)</h3><p>为了避免连接资源过载（常见的can not get resource from the pool），要预估连接池大小，设定一个比较合理的值。通常的经验是，在一开始的时候设定连接池的大小为当前平均数据库请求数量的110-115%，并且需要根据实际情况的改变而进行调整。参考<a href="https://docs.mongodb.com/manual/reference/connection-string/#connection-pool-options" target="_blank" rel="external">数据库连接池相关参数说明</a></p>
<p><code>connPoolStats</code>命令可以用来查询当前数据库连接数</p>
<h2 id="Hardware-Considerations-硬件注意事项"><a href="#Hardware-Considerations-硬件注意事项" class="headerlink" title="Hardware Considerations(硬件注意事项)"></a>Hardware Considerations(硬件注意事项)</h2><p>MongoDB对硬件的要求和限制相对较低</p>
<h3 id="Allocate-Sufficient-RAM-and-CPU-充足的内存和cpu"><a href="#Allocate-Sufficient-RAM-and-CPU-充足的内存和cpu" class="headerlink" title="Allocate Sufficient RAM and CPU(充足的内存和cpu)"></a>Allocate Sufficient RAM and CPU(充足的内存和cpu)</h3><h4 id="MMAPv1-1"><a href="#MMAPv1-1" class="headerlink" title="MMAPv1"></a>MMAPv1</h4><p>由于<code>MMAPv1</code>自身的并发模型，它并不需要很多的CPU内核。当然，如果增加了CPU内核数量，可以提高一部分性能，但是并不会减少单次处理的相应时间，至少需要一个双核物理CPU。</p>
<p>增加内存可以帮助MongoDB减少页交换次数，关于如何查看centos系统缺页信息，请参考<a href="https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab2/watch_linux_pagefault.md" target="_blank" rel="external">这里</a></p>
<h4 id="WiredTiger-1"><a href="#WiredTiger-1" class="headerlink" title="WiredTiger"></a>WiredTiger</h4><p>WiredTiger是一个多线程的存储引擎，能充分发挥出多核CPU的优势。当前活跃线程数和CPU数量的比例影响着wt的性能</p>
<ul>
<li>增加线程数量至CPU核数能提高吞吐量</li>
<li>如果活跃线程数量超出CPU数量到达一定成都的时候，吞吐量会下降</li>
</ul>
<p><code>mongostat</code>可以用来查看当前活跃操作数</p>
<p>WiredTiger存储引擎，既使用了WiredTiger内部缓存，也使用了文件系统缓存</p>
<p>MongoDB3.4开始，WiredTiger将会内部缓存将会占用以下（较大的一个）内存空间：</p>
<ul>
<li>50%的内存减去1GB</li>
<li>256MB</li>
</ul>
<p>由于使用了系统缓存，MongoDB实际上会使用掉所有没有被WiredTiger内部缓存和其他应用程序占用的内存空间。文件系统缓存中的数据是被压缩过的</p>
<p>为了调整WiredTiger内部缓存大小，可以通过设定参数<code>storage.wiredTiger.engineConfig.cacheSizeGB</code>或者<code>--wiredTigerCacheSizeGB</code>。避免设置的内部缓存大小大于默认值（个人认为这样处理可能是为了防止内存溢出的问题）</p>
<blockquote>
<p>注意：<code>storage.wiredTiger.engineConfig.cacheSizeGB</code>限制的是WiredTiger内部缓存占用内存大小。因为使用文件系统缓存的原因，操作系统会使用剩余的全部内存空间（所以跑着大业务量的mongod的机器内存使用总会100%）。</p>
</blockquote>
<p>这个设定（WiredTiger内部缓存默认值）的前提是一个机器上只运行一个mongod实例，如果你的机器上运行了多个mongod实例的话，应该把这个配置相对调低。生产环境不推荐一个机器上启动多个mongod进程。</p>
<p>如果是在容器中运行mongod实例（单个容器往往没有权限使用全部内存），这时候需要把<code>storage.wiredTiger.engineConfig.cacheSizeGB</code>的值设的小于容器可使用的内存空间大小</p>
<p>查看WiredTiger内部缓存到底占用了多少内存的方式是，在mongo shell中之行以下命令：<code>db.runCommand( { serverStatus: 1 } ).wiredTiger.cache[&quot;bytes currently in the cache&quot;]</code></p>
<h3 id="Compression-and-Encryption-压缩和加密"><a href="#Compression-and-Encryption-压缩和加密" class="headerlink" title="Compression and Encryption(压缩和加密)"></a>Compression and Encryption(压缩和加密)</h3><p>当开启加密功能的时候，配备AES-NI指令集扩展的CPU的性能表现最好。如果你使用的是企业级mongodb，而且使用了加密存储引擎，请选择配备AES-NI指令集扩展的CPU</p>
<h3 id="Use-Solid-State-Disks-SSDs-使用固态硬盘"><a href="#Use-Solid-State-Disks-SSDs-使用固态硬盘" class="headerlink" title="Use Solid State Disks (SSDs)(使用固态硬盘)"></a>Use Solid State Disks (SSDs)(使用固态硬盘)</h3><p>推荐在生产环境中使用固态硬盘，这样能带来更高的性价比。固态硬盘的随机读写能力非常适合MMMapv1的更新模型。</p>
<p><a href="https://zhidao.baidu.com/question/166368197.html" target="_blank" rel="external">SATA与SSD固态硬盘有什么区别</a></p>
<h3 id="MongoDB-and-NUMA-Hardware-非均匀存储器访问"><a href="#MongoDB-and-NUMA-Hardware-非均匀存储器访问" class="headerlink" title="MongoDB and NUMA Hardware(非均匀存储器访问)"></a>MongoDB and NUMA Hardware(非均匀存储器访问)</h3><p>在一个非均匀内存访问的系统中运行MongoDB可能会带来比较多的问题。包括慢查询和高CPU占用。</p>
<p>关于这部分详细内容，请具体参考<a href="https://docs.mongodb.com/manual/administration/production-notes/#mongodb-and-numa-hardware" target="_blank" rel="external">MongoDB Production Notes</a></p>
<h3 id="Disk-and-Storage-Systems-磁盘和存储系统"><a href="#Disk-and-Storage-Systems-磁盘和存储系统" class="headerlink" title="Disk and Storage Systems(磁盘和存储系统)"></a>Disk and Storage Systems(磁盘和存储系统)</h3><h4 id="swap-交换空间"><a href="#swap-交换空间" class="headerlink" title="swap(交换空间)"></a>swap(交换空间)</h4><p>生产环境中要为的系统分配交换空间。配置交换空间可以避免内存争用问题，防止Linux中的<a href="理解和配置 Linux 下的 OOM Killer">OOM Killer</a>杀掉mongod进程</p>
<p>当使用MMAPv1存储引擎的时候，mongod使用文件映射到内存的方法确保了操作系统不会将MongoDB数据存储在交换空间。在Windows系统上,因为一些限制，使用MMAPv1需要额外的交换空间在，参考<a href="https://docs.mongodb.com/manual/administration/production-notes/#production-windows-pagefile" target="_blank" rel="external">MongoDB on Windows</a></p>
<p>WiredTiger存储引擎在内存不够用的情况下可能会将部分数据存储在交换空间</p>
<h4 id="RAID-磁盘阵列"><a href="#RAID-磁盘阵列" class="headerlink" title="RAID(磁盘阵列)"></a>RAID(磁盘阵列)</h4><p>大部分生产环境中MongoDB运行环境中，磁盘阵列组合方式都是raid-10</p>
<p>raid-5和raid-6组合方式性能不如raid-10</p>
<p>不要在生产环境中使用raid-0，虽然raid-0提供了很好的写性能，但是它也存在一些缺点，例如会降低读性能。尤其是使用亚马DBS volumes</p>
<p>关于raid，可以参考<a href="https://zh.wikipedia.org/wiki/RAID" target="_blank" rel="external">这里</a></p>
<h4 id="Remote-Filesystems-远程文件系统"><a href="#Remote-Filesystems-远程文件系统" class="headerlink" title="Remote Filesystems(远程文件系统)"></a>Remote Filesystems(远程文件系统)</h4><p>总的来说，远程文件系统是不推荐在生产环境使用的，主要是因为性能问题</p>
<p>如果使用MMAPv1存储引擎，不推荐网络文件系统(NFS)，如果数据文件和日志文件都托管在NFS会导致性能问题。如果将数据文件和日志文件放在本地性能将会提高很多</p>
<p>当使用的是WiredTiger存储引擎的时候，如果远程文件系统符合ISO / IEC 9945 - 1:1996，WiredTiger对象就可以远程存储。因为通常情况下远程文件系统都比本地文件系统慢，所以使用远程文件系统会降低MongoDB的性能</p>
<p>如果决定使用NFS，添加以下的NFS选项到<code>/etc/fstab</code>文件：<code>bg</code>, <code>nolock</code>, 和 <code>noatime</code></p>
<h4 id="Separate-Components-onto-Different-Storage-Devices-不同组件使用不同的存储设备"><a href="#Separate-Components-onto-Different-Storage-Devices-不同组件使用不同的存储设备" class="headerlink" title="Separate Components onto Different Storage Devices(不同组件使用不同的存储设备)"></a>Separate Components onto Different Storage Devices(不同组件使用不同的存储设备)</h4><p>为了提高性能，可以根据应用程序的数据读写模式将数据库文件，journal文件，log文件等写到不同的存储设备上。将组件挂载为一个独立的文件系统，然后通过符号链接将对应的存储设备映射过去</p>
<p>如果使用WiredTiger存储引擎，也可以将索引单独存储到不同的存储设备上。、</p>
<blockquote>
<p>注意，使用不同的存储设备将会影响数据库快照备份，因为文件需要被存储到不同的设备和数据卷上</p>
</blockquote>
<h3 id="Scheduling-调度"><a href="#Scheduling-调度" class="headerlink" title="Scheduling(调度)"></a>Scheduling(调度)</h3><h4 id="Scheduling-for-Virtual-or-Cloud-Hosted-Devices-虚拟设备或云托管设备的调度"><a href="#Scheduling-for-Virtual-or-Cloud-Hosted-Devices-虚拟设备或云托管设备的调度" class="headerlink" title="Scheduling for Virtual or Cloud Hosted Devices(虚拟设备或云托管设备的调度)"></a>Scheduling for Virtual or Cloud Hosted Devices(虚拟设备或云托管设备的调度)</h4><p>如果使用虚拟机或者是云服务运行MongoDB，操作系统应该使用等待调度方式以获得最佳性能。等待调度方式允许操作系统I/O调度遵从底层虚拟机监控程序。</p>
<h4 id="Scheduling-for-Physical-Servers-物理机调度"><a href="#Scheduling-for-Physical-Servers-物理机调度" class="headerlink" title="Scheduling for Physical Servers(物理机调度)"></a>Scheduling for Physical Servers(物理机调度)</h4><p>如果使用物理机运行MongoDB，那么操作系统应该使用<code>deadline scheduler</code>的调度方式。<code>deadline scheduler</code>记录每个请求的最大延迟时间并且能够为磁盘敏感型数据库应用维持一个最合适的磁盘吞吐率</p>
<h2 id="Architecture-架构"><a href="#Architecture-架构" class="headerlink" title="Architecture(架构)"></a>Architecture(架构)</h2><h3 id="Replica-Sets-副本集"><a href="#Replica-Sets-副本集" class="headerlink" title="Replica Sets(副本集)"></a><a href="https://docs.mongodb.com/manual/administration/production-notes/#replica-sets" target="_blank" rel="external">Replica Sets(副本集)</a></h3><h3 id="Sharded-Clusters-分片集群"><a href="#Sharded-Clusters-分片集群" class="headerlink" title="Sharded Clusters 分片集群"></a><a href="https://docs.mongodb.com/manual/administration/production-notes/#sharded-clusters" target="_blank" rel="external">Sharded Clusters 分片集群</a></h3><h2 id="Compression-压缩"><a href="#Compression-压缩" class="headerlink" title="Compression(压缩)"></a>Compression(压缩)</h2><p>WiredTiger可以使用<a href="https://docs.mongodb.com/manual/reference/glossary/#term-snappy" target="_blank" rel="external">snappy</a>和<a href="https://docs.mongodb.com/manual/reference/glossary/#term-zlib" target="_blank" rel="external">zlib</a>两种方式压缩数据。snappy拥有较低的压缩比，但是性能损耗小；zlib能获得更高的压缩比，但是性能损耗多</p>
<p>默认情况下，WiredTiger使用snappy作为默认的压缩库，如果想改变默认的压缩设置，查看<a href="https://docs.mongodb.com/manual/reference/configuration-options/#storage.wiredTiger.collectionConfig.blockCompressor" target="_blank" rel="external">storage.wiredTiger.collectionConfig.blockCompressor</a></p>
<h2 id="Platform-Specific-Considerations-不同平台注意事项"><a href="#Platform-Specific-Considerations-不同平台注意事项" class="headerlink" title="Platform Specific Considerations(不同平台注意事项)"></a>Platform Specific Considerations(不同平台注意事项)</h2><blockquote>
<p>MongoDB会使用系统安装的glibc，并且要求glibc的版本至少在glibc-2.12-1.2.el6，否则会出现一些已知的bug，为了避免问题最好让glibc版本高于2.13</p>
</blockquote>
<h3 id="MongoDB-on-Linux-在linux上使用MongoDB"><a href="#MongoDB-on-Linux-在linux上使用MongoDB" class="headerlink" title="MongoDB on Linux(在linux上使用MongoDB)"></a>MongoDB on Linux(在linux上使用MongoDB)</h3><h4 id="Kernel-and-File-Systems-内核和文件系统"><a href="#Kernel-and-File-Systems-内核和文件系统" class="headerlink" title="Kernel and File Systems(内核和文件系统)"></a>Kernel and File Systems(内核和文件系统)</h4><p><strong>如果在Linux上使用MongoDB，那么Linux内核版本必须高于2.6.36，而且要使用XFS或者是EXT4文件系统。如果可能的话，尽量使用XFS，因为总体上MongoDB在XFS文件系统上运行地更好</strong></p>
<p><strong>当使用WiredTiger存储引擎的时候，强烈推荐使用XFS文件系统，因为这样能够避免因为使用EXT4文件系统导致的性能问题</strong></p>
<p>当使用MMapv1存储引擎的时候，MongoDB会预先创建数据库文件占用磁盘空间，虽然这时候还没有真的存储数据，而且通常创建的文件都比较大，基于这点考虑，同样推荐使用XFS和EXT4文件系统。如果可能的话，尽量使用XFS</p>
<p>注意：</p>
<ul>
<li>通常情况下，如果使用XFS文件系统，Linux内核版本至低是2.6.25</li>
<li>如果使用EXT4文件系统，Linux内核版本最低是2.6.28</li>
<li>如果使用Red Hat Enterprise或者是CentOS，内核版本最低为2.6.18-194</li>
</ul>
<h4 id="fsync-on-Directories"><a href="#fsync-on-Directories" class="headerlink" title="fsync() on Directories"></a>fsync() on Directories</h4><blockquote>
<p>MongoDB要求文件系统支持fsync()方法，HGFS和Virtual Box’s shared folders都不支持改方法</p>
</blockquote>
<h4 id="Recommended-Configuration-推荐配置"><a href="#Recommended-Configuration-推荐配置" class="headerlink" title="Recommended Configuration(推荐配置)"></a>Recommended Configuration(推荐配置)</h4><p><em>对于所有的MongoDB部署环境：</em></p>
<ul>
<li>主机必须使用Network Time Protocol (NTP)来同步时钟，这对于分片集群来说非常重要</li>
</ul>
<p>关于WiredTiger和MMAPv1存储引擎，有以下推荐配置：</p>
<ul>
<li>关掉存储数据文件的volumn的atime</li>
<li>设定文件描述符限制<code>-n</code>和用户进程可占用文件描述符数量限制(ulimit)<code>-u</code>高于20000，相关内容参考<a href="https://docs.mongodb.com/manual/reference/ulimit/" target="_blank" rel="external">这里</a>。ulimit过低将可能会导致MongoDB在业务繁忙的时候产生错误，进而甚至导致数据库连接失败，服务不可用等严重情况</li>
<li>关闭透明大页，MongoDB使用普通虚拟内存页性能表现更好</li>
<li>在BIOS中关闭NUMA</li>
<li>禁用SELinux，如果可能的话。如果已经在Red Hat操作系统中使用了SELinux，必须做好相应配置，参考<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/#install-rhel-configure-selinux" target="_blank" rel="external">Configure SELinux for MongoDB</a>和<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-enterprise-on-red-hat/#install-enterprise-rhel-configure-selinux" target="_blank" rel="external">Configure SELinux for MongoDB Enterprise</a></li>
</ul>
<blockquote>
<p>如果使用SELinux，任何需要使用server-side javascript的MongoDB操作语句将会导致segfault errors。<a href="https://docs.mongodb.com/manual/core/server-side-javascript/#disable-server-side-js" target="_blank" rel="external">Disable Server-Side Execution of JavaScript</a>介绍了如何禁止执行server-side javascript</p>
</blockquote>
<p>补充说明：</p>
<ul>
<li>atime<br>参考<a href="http://jianjian.blog.51cto.com/35031/103231" target="_blank" rel="external">这篇文章</a>，因为数据库文件可能频繁被修改，如果关闭atime，这样避免文件改动带来的atime的修改影响部分性能</li>
<li>ulimit<br>参考<a href="http://blog.csdn.net/cywosp/article/details/38965239" target="_blank" rel="external">这篇文章</a>，一般最大打开文件数会是系统内存的10%（以KB来计算）（称之为系统级限制），查看系统级别的最大打开文件数可以使用<code>sysctl -a | grep fs.file-max</code>命令查看。与此同时，内核为了不让某一个进程消耗掉所有的文件资源，其也会对单个进程最大打开文件数做默认值处理（称之为用户级限制），默认值一般是1024，使用<code>ulimit -n</code>命令可以查看。在Web服务器中，通过更改系统默认值文件描述符的最大值来优化服务器是最常见的方式之一，具体优化方式请查看<a href="http://blog.csdn.net/kumu_linux/article/details/7877770。" target="_blank" rel="external">http://blog.csdn.net/kumu_linux/article/details/7877770。</a></li>
<li>关于<a href="http://www.cnblogs.com/kerrycode/p/4670931.html" target="_blank" rel="external">Transparent Huge Pages(透明大页)</a></li>
<li><a href="https://baike.baidu.com/item/NUMA" target="_blank" rel="external">numa</a></li>
</ul>
<p><em>针对使用WiredTiger存储引擎的建议：</em></p>
<ul>
<li>不管使用什么类型的存储介质（机械硬盘，ssd），都要将linux系统readahead（文件预读）设置为0。设定更高等级的文件预读参数有利于连续的io操作，但是MongoDB的磁盘操作通常情况下都是随机的，调高文件预读等级只能带来有限的好处，而且会影响MongoDB本身的性能。因此，将readahead设置为0在大部分的工作场景中能让MonoDB获得最佳性能。</li>
</ul>
<p><em>针对使用MMAPv1存储引擎的建议：</em></p>
<ul>
<li>保证存储数据库文件的块设备的readahead是合适的。针对硬盘的随机读写操作类型，可以设定较低的readahead为32（16KB）。对于标准块设备，<code>sudo blockdev --report</code>可以获取当前readahead值，<code>sudo blockdev --setra &lt;value&gt; &lt;device&gt;</code>可以用于制定设备的值</li>
</ul>
<blockquote>
<p>补充说明：<br>readahead（文件预读）: Linux的文件预读readahead，指Linux系统内核将指定文件的某区域预读进页缓存起来，便于接下来对该区域进行读取时，不会因缺页（page fault）而阻塞。因为从内存读取比从磁盘读取要快很多。预读可以有效的减少磁盘的寻道次数和应用程序的I/O等待时间，是改进磁盘读I/O性能的重要优化手段之一。</p>
</blockquote>
<h4 id="MongoDB-and-TLS-SSL-libraries"><a href="#MongoDB-and-TLS-SSL-libraries" class="headerlink" title="MongoDB and TLS/SSL libraries"></a>MongoDB and TLS/SSL libraries</h4><p>在Linux系统中可能会看到以下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;path to SSL libs&gt;/libssl.so.&lt;version&gt;: no version information available (required by /usr/bin/mongod)</div><div class="line">&lt;path to SSL libs&gt;/libcrypto.so.&lt;version&gt;: no version information available (required by /usr/bin/mongod)</div></pre></td></tr></table></figure></p>
<p>这个警告说明了系统的TLS/SSL库和编译MongoDB使用的不一致，通常情况下并不需要关注这个，但仍然可以使用以下命令来查看MongoDB需要的TLS/SSL库版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objdump -T &lt;path to mongod&gt;/mongod | grep &quot; SSL_&quot;</div><div class="line">objdump -T &lt;path to mongod&gt;/mongod | grep &quot; CRYPTO_&quot;</div></pre></td></tr></table></figure></p>
<p>上述命令将返回以下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0000000000000000      DF *UND*       0000000000000000  libssl.so.10 SSL_write</div><div class="line">0000000000000000      DF *UND*       0000000000000000  OPENSSL_1.0.0 SSL_write</div></pre></td></tr></table></figure></p>
<p>接下来检测下系统中的TLS/SSL库的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objdump -T &lt;path to TLS/SSL libs&gt;/libssl.so.1*</div><div class="line">objdump -T &lt;path to TLS/SSL libs&gt;/libcrypto.so.1*</div></pre></td></tr></table></figure></p>
<p>上述方法，既不准确，也不完善，仅供参考</p>
<h3 id="MongoDB-on-Windows"><a href="#MongoDB-on-Windows" class="headerlink" title="MongoDB on Windows"></a>MongoDB on Windows</h3><p>感兴趣的可以参考<a href="https://docs.mongodb.com/manual/administration/production-notes/#mongodb-on-windows" target="_blank" rel="external">这里</a></p>
<h3 id="MongoDB-on-Virtual-Environments"><a href="#MongoDB-on-Virtual-Environments" class="headerlink" title="MongoDB on Virtual Environments"></a>MongoDB on Virtual Environments</h3><h4 id="EC2"><a href="#EC2" class="headerlink" title="EC2"></a>EC2</h4><p>MongoDB兼容EC2，<a href="https://www.mongodb.com/cloud/cloud-manager/?jmp=docs&amp;_ga=2.133439246.1051480522.1501766469-1069453493.1477385716" target="_blank" rel="external">MongoDB Cloud Manager</a>可以部署在AWS上，然后可以使用MongoDB Cloud Manager在EC2上部署mongod实例，详情参考<a href="Configure AWS Integration">Configure AWS Integration</a></p>
<h4 id="Azure"><a href="#Azure" class="headerlink" title="Azure"></a><a href="https://docs.mongodb.com/manual/administration/production-notes/#azure" target="_blank" rel="external">Azure</a></h4><h4 id="VMWare"><a href="#VMWare" class="headerlink" title="VMWare"></a>VMWare</h4><p>MongoDB兼容VMWare</p>
<p>VMWare支持内存过载，所以可以给虚拟机分配超出物理机实际内存大小的内存值。当内存过载时，管理程序会给虚拟机重新分配内存。VMWare balloon driver (vmmemctl)会自动回收它认为最没有价值的内存，balloon driver运行在虚拟机中，当balloon driver扩大时，会导致虚拟机回收应用的内存，这个会影响MongoDB的内存管理，影响MongoDB的内存</p>
<p>可以通过关闭balloon driver和VMWare的内存过载功能来避免上述问题。但是，关闭balloon driver会导致管理程序使用交换分区，因为没有其他的能够用来执行内存回收的机制。从swap读写数据要比从内存慢得多，这也会影响性能。因此关闭balloon driver和VMWare的内存过载功能不是最佳方案，最佳方案是给运行MongoDB的虚拟机分配全部内存，这样就能保证MongoDB不会被影响</p>
<p>使用VMWare的时候，确保每个物理CPU虚拟出来的CPU数量不超过2</p>
<p>使用vMotion关闭VMWare的（动态迁移）。虚拟机的动态迁移会导致性能问题，而且会影响MongoDB副本集和分片集群机制</p>
<p>可以克隆一个正在运行着MongoDB的虚拟机，也就是说可以使用这种方式快速的把一个MongoDB单点做成一个副本集。如果克隆一个开启了journaling的MongoDB的VM，直接克隆就能MongoDB就能启动。如果MongoDB没有开启，先关闭MongoDB，然后克隆VM，然后重启MongoDB</p>
<h4 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h4><p>MongoDB兼容KVM</p>
<p>KVM支持内存过载，所以可以给虚拟机分配超出物理机实际内存大小的内存值。当内存过载时，管理程序会给虚拟机重新分配内存。KVM balloon driver (vmmemctl)会自动回收它认为最没有价值的内存，balloon driver运行在虚拟机中，当balloon driver扩大时，会导致虚拟机回收应用的内存，这个会影响MongoDB的内存管理，影响MongoDB的内存</p>
<p>可以通过关闭balloon driver和KVM的内存过载功能来避免上述问题。但是，关闭balloon driver会导致管理程序使用交换分区，因为没有其他的能够用来执行内存回收的机制。从swap读写数据要比从内存慢得多，这也会影响性能。因此关闭balloon driver和KVM的内存过载功能不是最佳方案，最佳方案是给运行MongoDB的虚拟机分配全部内存，这样就能保证MongoDB不会被影响</p>
<p>使用KVM的时候，确保每个物理CPU虚拟出来的CPU数量不超过2</p>
<h2 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h2><h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><p>在Linux系统中，可以使用iostat去检查数据库是否存在磁盘io瓶颈</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iostat -xmt 1</div></pre></td></tr></table></figure>
<p>iostat关键字段：</p>
<ul>
<li>%util: 这个字段价值最大，它代表了当前指定时间磁盘使用百分比</li>
<li>avgrq-sz: 平均请求大小，这个数值越小表示有越多的random IO</li>
</ul>
<h3 id="bwm-ng"><a href="#bwm-ng" class="headerlink" title="bwm-ng"></a>bwm-ng</h3><p>这是个监控网络状态的命令行工具，可以用来确认是否存在网络瓶颈</p>
<h2 id="Backups"><a href="#Backups" class="headerlink" title="Backups"></a>Backups</h2><p>数据备份请参考<a href="https://docs.mongodb.com/manual/core/backups/" target="_blank" rel="external">这里</a></p>
<h2 id="其他参考链接"><a href="#其他参考链接" class="headerlink" title="其他参考链接"></a>其他参考链接</h2><ul>
<li><a href="Blog Post: Capacity Planning and Hardware Provisioning for MongoDB In Ten Minutes">Blog Post: Capacity Planning and Hardware Provisioning for MongoDB In Ten Minutes</a></li>
<li><a href="http://www.mongodb.com/lp/white-paper/multi-dc?jmp=docs&amp;_ga=2.133419918.1051480522.1501766469-1069453493.1477385716" target="_blank" rel="external">Whitepaper: MongoDB Multi-Data Center Deployments</a></li>
<li><a href="https://www.mongodb.com/lp/white-paper/mongodb-security-architecture?jmp=docs&amp;_ga=2.133419918.1051480522.1501766469-1069453493.1477385716" target="_blank" rel="external">Whitepaper: Security Architecture</a></li>
<li><a href="https://www.mongodb.com/lp/whitepaper/architecture-guide?jmp=docs&amp;_ga=2.133419918.1051480522.1501766469-1069453493.1477385716" target="_blank" rel="external">Whitepaper: MongoDB Architecture Guide</a></li>
<li><a href="http://www.mongodb.com/presentations/webinar-mongodb-administration-101?jmp=docs&amp;_ga=2.133419918.1051480522.1501766469-1069453493.1477385716" target="_blank" rel="external">Presentation: MongoDB Administration 101</a></li>
<li><a href="https://www.mongodb.com/products/consulting?jmp=docs&amp;_ga=2.133419918.1051480522.1501766469-1069453493.1477385716#s_product_readiness" target="_blank" rel="external">MongoDB Production Readiness Consulting Package</a></li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.mongodb.com/manual/administration/production-notes/" target="_blank" rel="external">MongoDB Production Notes</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MongoDB二进制文件&quot;&gt;&lt;a href=&quot;#MongoDB二进制文件&quot; class=&quot;headerlink&quot; title=&quot;MongoDB二进制文件&quot;&gt;&lt;/a&gt;MongoDB二进制文件&lt;/h2&gt;&lt;h3 id=&quot;支持的运行平台&quot;&gt;&lt;a href=&quot;#支持的运行平台&quot; class=&quot;headerlink&quot; title=&quot;支持的运行平台&quot;&gt;&lt;/a&gt;支持的运行平台&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/administration/production-notes/#x86-64&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;x86_64&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/administration/production-notes/#arm64&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ARM64&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/administration/production-notes/#ppc64le-mongodb-enterprise-edition&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PPC64LE (MongoDB Enterprise Edition)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/administration/production-notes/#s390x-mongodb-enterprise-edition&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;s390x (MongoDB Enterprise Edition)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="mongodb" scheme="http://cocacola183.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://cocacola183.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>mongodb wt数据文件损坏解决方案</title>
    <link href="http://cocacola183.github.io/2017/07/08/mongo/mongodb-wt%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://cocacola183.github.io/2017/07/08/mongo/mongodb-wt数据文件损坏解决方案/</id>
    <published>2017-07-08T02:34:04.000Z</published>
    <updated>2017-07-10T03:34:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.alexbevi.com/blog/2016/02/10/recovering-a-wiredtiger-collection-from-a-corrupt-mongodb-installation/" target="_blank" rel="external">原文链接</a><br><a href="http://dev.guanghe.tv/2016/06/06/recovering-a-wiredtiger-collection-from-a-corrupt-wt-file/" target="_blank" rel="external">译文链接</a>，我看的这篇，因为没有给出来原文链接，所以刚开始没找到原文</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>数据文件是wt文件，而且是通过<code>snappy</code>方式压缩的，如果不是通过<code>snappy</code>方式，也可以参考下这个方式，不过执行命令可能有所不同 </p>
</blockquote>
<p>这个解决方案非常适合这样的场景：服务器意外故障（例如断电），突然停机，导致mongodb数据文件损坏，进而导致了<code>mongod</code>进程无法启动</p>
<a id="more"></a>
<p>但是我却是遇到了这样的问题：服务器由于磁盘空间占用达到100%导致<code>mongod</code>进程挂掉，由于磁盘100%，无法再启动mongo进程，所以工作人员直接删掉了部分的wt文件，释放部分磁盘空间，然后再次启动mongo的时候，发现无法启动了。。。</p>
<p>无法启动的原因是mongo启动的时候会做一次检测，检查mongodb的数据文件和某个地方存储的信息是否一致的（具体这个位置我们暂时还不清楚），如果不一致，将会无法启动mongo进程。进程无法启动导致了很多严重的问题，好在这个数据库记录的都是一些非业务信息，数据的查询更新操作也不算太多，为了让集群快速可用，我们直接更改了一个空的数据目录，启动<code>mongod</code>进程，让集群先可用</p>
<p>然后问题来了，原来的数据要怎么恢复呢？于是我们就有了从wt文件中抽取出数据的需求，所以就有了以下过程</p>
<h2 id="恢复过程"><a href="#恢复过程" class="headerlink" title="恢复过程"></a>恢复过程</h2><h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><p><a href="http://source.wiredtiger.com/" target="_blank" rel="external">最新下载页面</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">yum install -y snappy</div><div class="line">wget http://source.wiredtiger.com/releases/wiredtiger-2.9.3.tar.bz2</div><div class="line"><span class="meta">#</span><span class="bash"> 解压，进入目录</span></div><div class="line">./configure --enable-snappy</div></pre></td></tr></table></figure>
<h3 id="准备恢复目录mongo-bak"><a href="#准备恢复目录mongo-bak" class="headerlink" title="准备恢复目录mongo-bak"></a>准备恢复目录mongo-bak</h3><p>目录包含以下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">collection********.wt</div><div class="line">_mdb_catalog.wt</div><div class="line">sizeStorer.wt</div><div class="line">storage.bson</div><div class="line">WiredTiger</div><div class="line">WiredTiger.basecfg</div><div class="line">WiredTiger.lock</div><div class="line">WiredTiger.turtle</div><div class="line">WiredTiger.wt</div></pre></td></tr></table></figure></p>
<h3 id="数据文件修复（我没做这一步处理因为没有必要）"><a href="#数据文件修复（我没做这一步处理因为没有必要）" class="headerlink" title="数据文件修复（我没做这一步处理因为没有必要）"></a>数据文件修复（我没做这一步处理因为没有必要）</h3><p>打捞出可以修复的部分</p>
<blockquote>
<p>注意仍在wt下载目录下执行</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./wt -v -h ../mongo-bak -C "extensions=[./ext/compressors/snappy/.libs/libwiredtiger_snappy.so]" -R salvage collection******.wt</div></pre></td></tr></table></figure>
<h3 id="数据格式调整"><a href="#数据格式调整" class="headerlink" title="数据格式调整"></a>数据格式调整</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./wt -v -h ../mongo-bak -C "extensions=[./ext/compressors/snappy/.libs/libwiredtiger_snappy.so]" -R dump -f ../collection.dump collection******</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，这个命令的最后一个参数是不带<code>.wt</code>的</p>
</blockquote>
<p>这样就把刚才修复的数据写到<code>collection.dump</code>中了</p>
<h3 id="在目标mongodb中创建一个集合（数据将会被恢复到这个mongodb中）"><a href="#在目标mongodb中创建一个集合（数据将会被恢复到这个mongodb中）" class="headerlink" title="在目标mongodb中创建一个集合（数据将会被恢复到这个mongodb中）"></a>在目标mongodb中创建一个集合（数据将会被恢复到这个mongodb中）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mongo</div><div class="line"><span class="meta">&gt;</span><span class="bash"> use Recovery</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> db.brokedCollection.insert(&#123;<span class="built_in">test</span>: 1&#125;)</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> db.brokedCollection.remove(&#123;&#125;)</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> db.brokedCollection.stats()</span></div></pre></td></tr></table></figure>
<p>创建完成之后，就能看到刚刚新建的wt文件了，假设记为<code>xxx.wt</code></p>
<h3 id="将collection-dump的数据写入xxx-wt"><a href="#将collection-dump的数据写入xxx-wt" class="headerlink" title="将collection.dump的数据写入xxx.wt"></a>将<code>collection.dump</code>的数据写入<code>xxx.wt</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./wt -v -h ../tmp-mongo -C "extensions=[./ext/compressors/snappy/.libs/libwiredtiger_snappy.so]" -R load -f ../collection.dump -r xxx</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，这里最后一个参数也是不带wt的。另外执行这一步的时候，必须要先关闭掉mongo进程，否则会提示wt文件被占用，无法写入数据</p>
</blockquote>
<h3 id="查看已经被恢复的数据"><a href="#查看已经被恢复的数据" class="headerlink" title="查看已经被恢复的数据"></a>查看已经被恢复的数据</h3><blockquote>
<p>将mongo进程启动之后，建议使用3.2的mongo客户端链接</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mongo</div><div class="line"><span class="meta">&gt;</span><span class="bash"> show dbs</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> use Recovery</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> show collections</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> db.brokedCollection.count()</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>count</code>是无法查到数据的，还是需要find</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> db.brokedCollection.find(&#123;&#125;, &#123;_id: 1&#125;)</span></div></pre></td></tr></table></figure>
<h3 id="将数据dump出来，然后重新写进去"><a href="#将数据dump出来，然后重新写进去" class="headerlink" title="将数据dump出来，然后重新写进去"></a>将数据dump出来，然后重新写进去</h3><p><code>mongodump</code></p>
<p><code>mongorestore</code></p>
<blockquote>
<p>注意，这里的<code>mongodump</code>和<code>mongorestore</code>都要使用3.2版本的</p>
</blockquote>
<p>数据经过导入导出之后就可以<code>count</code>出来了</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>以上恢复过程是针对数据库文件被直接删掉的情况。假如说当前数据库启动无误，这时候一个误删，删掉了数据库文件应该如何处理呢？</p>
<p><a href="https://blogs.gnome.org/raywang/2007/11/30/%E4%BD%BF%E7%94%A8lsof%E6%81%A2%E5%A4%8D%E8%AF%AF%E5%88%A0%E7%9A%84%E6%96%87%E4%BB%B6-%E8%BD%AC/" target="_blank" rel="external">使用lsof恢复误删的文件</a><br>这边文章写的清楚如何进行文件恢复</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.alexbevi.com/blog/2016/02/10/recovering-a-wiredtiger-collection-from-a-corrupt-mongodb-installation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://dev.guanghe.tv/2016/06/06/recovering-a-wiredtiger-collection-from-a-corrupt-wt-file/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;译文链接&lt;/a&gt;，我看的这篇，因为没有给出来原文链接，所以刚开始没找到原文&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;数据文件是wt文件，而且是通过&lt;code&gt;snappy&lt;/code&gt;方式压缩的，如果不是通过&lt;code&gt;snappy&lt;/code&gt;方式，也可以参考下这个方式，不过执行命令可能有所不同 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个解决方案非常适合这样的场景：服务器意外故障（例如断电），突然停机，导致mongodb数据文件损坏，进而导致了&lt;code&gt;mongod&lt;/code&gt;进程无法启动&lt;/p&gt;
    
    </summary>
    
      <category term="mongodb" scheme="http://cocacola183.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://cocacola183.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>天云山-北京平谷</title>
    <link href="http://cocacola183.github.io/2017/07/02/travel/%E5%A4%A9%E4%BA%91%E5%B1%B1-%E5%8C%97%E4%BA%AC%E5%B9%B3%E8%B0%B7/"/>
    <id>http://cocacola183.github.io/2017/07/02/travel/天云山-北京平谷/</id>
    <published>2017-07-02T06:00:00.000Z</published>
    <updated>2017-07-02T10:22:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考行程"><a href="#参考行程" class="headerlink" title="参考行程"></a>参考行程</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>如果和我有一样有以下相同出游前提</p>
<ul>
<li>想站在玻璃制作的观景台上感受下直面万丈深渊的刺激</li>
<li>想爬山</li>
<li>人在北京</li>
<li>想利用周末出游</li>
</ul>
<p>那么这个行程可能有一定的参考价值</p>
<a id="more"></a>
<h3 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h3><p>从<a href="http://www.pgtys.com/index.htm" target="_blank" rel="external">天云山旅游风景区官网</a>上看，玻璃栈道目前处于维修状态，而且官网上的旅游路线图已经非常老了，没有任何参考价值，我们沿途走的路线官网上都没有相关信息，玻璃观景台应该是个新加进去的项目。官网上的信息提示玻璃栈道正处在维护当中，所以决定去玩之前看下官网是非常有必要的</p>
<h3 id="出游行程"><a href="#出游行程" class="headerlink" title="出游行程"></a>出游行程</h3><h4 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h4><p>2017年7月1日，周六，早上六点半起床（已经非常晚了），七点出发，坐地铁换乘到15号线，坐到终点站俸伯。我们有19站地铁的行程，大约一个小时也就是八点左右到达。朋友有车，从俸伯出发，开车往景点出发，大约又需要一个半小时的行程，才到达经典。新手新车上路，老司机可能快很多。也就是<code>九点半</code>左右开始爬山，大约到了<code>下午三点</code>刚刚好坐缆车到达山底。作为亚健康久坐党，我们的游玩时间应该可以作为充足游玩时间参考。</p>
<h4 id="游玩路线"><a href="#游玩路线" class="headerlink" title="游玩路线"></a>游玩路线</h4><p>我们选择的路线是去玻璃观景台桥的路线，这个路线没办法看到玻璃栈道，玻璃桥，摆渡车。不过玻璃观景台也是非常壮观的。很刺激。虽然带了个入门级的单反，但是没有拍下当时的景点路线图，回来找行程路线发现已经找不到了。总之，去这个地方玩最主要的内容其实就是爬山，如果不愿意爬山的话，建议还是不要来玩了，只是看玻璃栈道，意义并不太大。</p>
<h3 id="出行消费（双人）"><a href="#出行消费（双人）" class="headerlink" title="出行消费（双人）"></a>出行消费（双人）</h3><p>景区门票：78元/人  学生票39元<br>索道价格：单程100元/人<br>玻璃观景台门票： 40元/人 </p>
<h3 id="游玩建议-重要"><a href="#游玩建议-重要" class="headerlink" title="游玩建议(重要)"></a>游玩建议(重要)</h3><ul>
<li>一定自己带好水，半山腰有卖水的，山顶有卖水的，半山腰和山顶之间没有卖水的，半山腰的水，我们没有买，山顶的水10元一瓶，只有常温矿泉水，而且没有冰镇</li>
<li>做好防晒，接近山顶的时候，会有阳光暴晒</li>
<li>还有些其他的登山注意事项这里就不提啦，总之出来玩还是要多准备</li>
<li>景点非常偏僻，建议自驾开车去，周末的车不算太多（我们去的时候还可以），可以不用为怎么回去而担心。如果必须要使用公共交通工具，最好提前规划好路线</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有山有水，还有点称得上惊险刺激的玩意儿，价格也不算太贵，总的来说还是值得一去的好地方，如果不愿意爬上千万别去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考行程&quot;&gt;&lt;a href=&quot;#参考行程&quot; class=&quot;headerlink&quot; title=&quot;参考行程&quot;&gt;&lt;/a&gt;参考行程&lt;/h2&gt;&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;如果和我有一样有以下相同出游前提&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想站在玻璃制作的观景台上感受下直面万丈深渊的刺激&lt;/li&gt;
&lt;li&gt;想爬山&lt;/li&gt;
&lt;li&gt;人在北京&lt;/li&gt;
&lt;li&gt;想利用周末出游&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么这个行程可能有一定的参考价值&lt;/p&gt;
    
    </summary>
    
      <category term="travel" scheme="http://cocacola183.github.io/categories/travel/"/>
    
    
      <category term="travel" scheme="http://cocacola183.github.io/tags/travel/"/>
    
  </entry>
  
  <entry>
    <title>mongodb两段提交</title>
    <link href="http://cocacola183.github.io/2017/06/03/mongo/mongodb%E4%B8%A4%E6%AE%B5%E6%8F%90%E4%BA%A4/"/>
    <id>http://cocacola183.github.io/2017/06/03/mongo/mongodb两段提交/</id>
    <published>2017-06-02T23:57:25.000Z</published>
    <updated>2017-07-08T02:34:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>mongodb所有的针对单个文档的操作都具有原子性，但是当一个操作涉及多个文档更新的时候，是非原子性的。但在生产环境中，是存在多文档更新的需求的，一般情况下，包含以下两个方面：</p>
<ul>
<li>原子性：如果任何一个操作失败，所有已经进行的操作全部回滚，并且中断接下来的所有操作</li>
<li>一致性：如果操作执行过程遭遇中断，例如断电，数据库要有能力保持数据一致性</li>
</ul>
<p>为了解决多文档更新事务性问题，可以使用两段提交的方式处理。两段提交可以保证数据是一致的，而且可以保证遇到错误之后可以恢复，但是在执行期间，文档本身处于待定状态</p>
<blockquote>
<p>注意：因为mongodb只有单文档操作具有事务性，两段提交只能提供类似原子操作的语义，而不是提供完善的事务机制</p>
</blockquote>
<a id="more"></a>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><h3 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h3><p>银行账户A转账给银行账户B</p>
<p>该场景会使用两个集合：</p>
<ul>
<li>accounts  记录用户信息</li>
<li>transactions  记录转账事务状态</li>
</ul>
<h3 id="初始化账户信息"><a href="#初始化账户信息" class="headerlink" title="初始化账户信息"></a>初始化账户信息</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">db.accounts.insert(</div><div class="line">   [</div><div class="line">     &#123; <span class="attr">_id</span>: <span class="string">"A"</span>, <span class="attr">balance</span>: <span class="number">1000</span>, <span class="attr">pendingTransactions</span>: [] &#125;,</div><div class="line">     &#123; <span class="attr">_id</span>: <span class="string">"B"</span>, <span class="attr">balance</span>: <span class="number">1000</span>, <span class="attr">pendingTransactions</span>: [] &#125;</div><div class="line">   ]</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="初始化转账记录表"><a href="#初始化转账记录表" class="headerlink" title="初始化转账记录表"></a>初始化转账记录表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.transactions.insert(</div><div class="line">    &#123; <span class="attr">_id</span>: <span class="number">1</span>, <span class="attr">source</span>: <span class="string">"A"</span>, <span class="attr">destination</span>: <span class="string">"B"</span>, <span class="attr">value</span>: <span class="number">100</span>, <span class="attr">state</span>: <span class="string">"initial"</span>, <span class="attr">lastModified</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="查找转账事务"><a href="#查找转账事务" class="headerlink" title="查找转账事务"></a>查找转账事务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t = db.transactions.findOne( &#123; <span class="attr">state</span>: <span class="string">"initial"</span> &#125; )</div></pre></td></tr></table></figure>
<h3 id="将转账事务状态由initial改为pending"><a href="#将转账事务状态由initial改为pending" class="headerlink" title="将转账事务状态由initial改为pending"></a>将转账事务状态由initial改为pending</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.transactions.update(</div><div class="line">    &#123; <span class="attr">_id</span>: t._id, <span class="attr">state</span>: <span class="string">"initial"</span> &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">$set</span>: &#123; <span class="attr">state</span>: <span class="string">"pending"</span> &#125;,</div><div class="line">      <span class="attr">$currentDate</span>: &#123; <span class="attr">lastModified</span>: <span class="literal">true</span> &#125;</div><div class="line">    &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="将事物状态记录到账户信息中"><a href="#将事物状态记录到账户信息中" class="headerlink" title="将事物状态记录到账户信息中"></a>将事物状态记录到账户信息中</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.accounts.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t.source, <span class="attr">pendingTransactions</span>: &#123; <span class="attr">$ne</span>: t._id &#125; &#125;,</div><div class="line">   &#123; <span class="attr">$inc</span>: &#123; <span class="attr">balance</span>: -t.value &#125;, <span class="attr">$push</span>: &#123; <span class="attr">pendingTransactions</span>: t._id &#125; &#125;</div><div class="line">)</div><div class="line"></div><div class="line">db.accounts.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t.destination, <span class="attr">pendingTransactions</span>: &#123; <span class="attr">$ne</span>: t._id &#125; &#125;,</div><div class="line">   &#123; <span class="attr">$inc</span>: &#123; <span class="attr">balance</span>: t.value &#125;, <span class="attr">$push</span>: &#123; <span class="attr">pendingTransactions</span>: t._id &#125; &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="将转账事务状态由pending改为applied"><a href="#将转账事务状态由pending改为applied" class="headerlink" title="将转账事务状态由pending改为applied"></a>将转账事务状态由pending改为applied</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.transactions.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t._id, <span class="attr">state</span>: <span class="string">"pending"</span> &#125;,</div><div class="line">   &#123;</div><div class="line">     <span class="attr">$set</span>: &#123; <span class="attr">state</span>: <span class="string">"applied"</span> &#125;,</div><div class="line">     <span class="attr">$currentDate</span>: &#123; <span class="attr">lastModified</span>: <span class="literal">true</span> &#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="将事务状态从账户信息中移除"><a href="#将事务状态从账户信息中移除" class="headerlink" title="将事务状态从账户信息中移除"></a>将事务状态从账户信息中移除</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.accounts.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t.source, <span class="attr">pendingTransactions</span>: t._id &#125;,</div><div class="line">   &#123; <span class="attr">$pull</span>: &#123; <span class="attr">pendingTransactions</span>: t._id &#125; &#125;</div><div class="line">)</div><div class="line"></div><div class="line">db.accounts.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t.destination, <span class="attr">pendingTransactions</span>: t._id &#125;,</div><div class="line">   &#123; <span class="attr">$pull</span>: &#123; <span class="attr">pendingTransactions</span>: t._id &#125; &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="将转账事务状态由applied改为done"><a href="#将转账事务状态由applied改为done" class="headerlink" title="将转账事务状态由applied改为done"></a>将转账事务状态由applied改为done</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.transactions.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t._id, <span class="attr">state</span>: <span class="string">"applied"</span> &#125;,</div><div class="line">   &#123;</div><div class="line">     <span class="attr">$set</span>: &#123; <span class="attr">state</span>: <span class="string">"done"</span> &#125;,</div><div class="line">     <span class="attr">$currentDate</span>: &#123; <span class="attr">lastModified</span>: <span class="literal">true</span> &#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>以上就是整个转账流程</p>
<h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p>转账流程不是最重要的，最重要的是从故障恢复整个转账流程。下面介绍如何从各个阶段恢复转账流程</p>
<h3 id="从pending状态恢复"><a href="#从pending状态恢复" class="headerlink" title="从pending状态恢复"></a>从<code>pending</code>状态恢复</h3><p><code>pending</code>状态就是确定要开始转账，而且已经开始更新AB账户的数据了，但是从这里到转账状态变为<code>applied</code>期间，出现了问题</p>
<p>以下是从<code>pending</code>状态恢复的过程</p>
<h4 id="找到至少30分钟都未更新的而且state是pending的转账状态"><a href="#找到至少30分钟都未更新的而且state是pending的转账状态" class="headerlink" title="找到至少30分钟都未更新的而且state是pending的转账状态"></a>找到至少30分钟都未更新的而且state是<code>pending</code>的转账状态</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dateThreshold = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">dateThreshold.setMinutes(dateThreshold.getMinutes() - <span class="number">30</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> t = db.transactions.findOne( &#123; <span class="attr">state</span>: <span class="string">"pending"</span>, <span class="attr">lastModified</span>: &#123; <span class="attr">$lt</span>: dateThreshold &#125; &#125; );</div></pre></td></tr></table></figure>
<h4 id="然后从进行转账这一步骤重新执行即可"><a href="#然后从进行转账这一步骤重新执行即可" class="headerlink" title="然后从进行转账这一步骤重新执行即可"></a>然后从<code>进行转账</code>这一步骤重新执行即可</h4><h3 id="从applied状态恢复"><a href="#从applied状态恢复" class="headerlink" title="从applied状态恢复"></a>从<code>applied</code>状态恢复</h3><h4 id="找到至少30分钟都未更新的而且state是applied的转账状态"><a href="#找到至少30分钟都未更新的而且state是applied的转账状态" class="headerlink" title="找到至少30分钟都未更新的而且state是applied的转账状态"></a>找到至少30分钟都未更新的而且state是<code>applied</code>的转账状态</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dateThreshold = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">dateThreshold.setMinutes(dateThreshold.getMinutes() - <span class="number">30</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> t = db.transactions.findOne( &#123; <span class="attr">state</span>: <span class="string">"applied"</span>, <span class="attr">lastModified</span>: &#123; <span class="attr">$lt</span>: dateThreshold &#125; &#125; );</div></pre></td></tr></table></figure>
<h4 id="然后从更新用户信息这一步骤重新执行即可"><a href="#然后从更新用户信息这一步骤重新执行即可" class="headerlink" title="然后从更新用户信息这一步骤重新执行即可"></a>然后从<code>更新用户信息</code>这一步骤重新执行即可</h4><h2 id="故障回滚"><a href="#故障回滚" class="headerlink" title="故障回滚"></a>故障回滚</h2><h3 id="从applied状态进行回滚"><a href="#从applied状态进行回滚" class="headerlink" title="从applied状态进行回滚"></a>从<code>applied</code>状态进行回滚</h3><p>当转账进行到<code>applied</code>状态时，不推荐回滚了，可以直接恢复这个转账事务，然后再新建一个退款的事务，把钱再转回去</p>
<h3 id="从pending状态回滚"><a href="#从pending状态回滚" class="headerlink" title="从pending状态回滚"></a>从<code>pending</code>状态回滚</h3><h4 id="将转账状态更新为canceling"><a href="#将转账状态更新为canceling" class="headerlink" title="将转账状态更新为canceling"></a>将转账状态更新为<code>canceling</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.transactions.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t._id, <span class="attr">state</span>: <span class="string">"pending"</span> &#125;,</div><div class="line">   &#123;</div><div class="line">     <span class="attr">$set</span>: &#123; <span class="attr">state</span>: <span class="string">"canceling"</span> &#125;,</div><div class="line">     <span class="attr">$currentDate</span>: &#123; <span class="attr">lastModified</span>: <span class="literal">true</span> &#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h4 id="取消AB账户的信息修改"><a href="#取消AB账户的信息修改" class="headerlink" title="取消AB账户的信息修改"></a>取消AB账户的信息修改</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.accounts.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t.destination, <span class="attr">pendingTransactions</span>: t._id &#125;,</div><div class="line">   &#123;</div><div class="line">     <span class="attr">$inc</span>: &#123; <span class="attr">balance</span>: -t.value &#125;,</div><div class="line">     <span class="attr">$pull</span>: &#123; <span class="attr">pendingTransactions</span>: t._id &#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.accounts.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t.source, <span class="attr">pendingTransactions</span>: t._id &#125;,</div><div class="line">   &#123;</div><div class="line">     <span class="attr">$inc</span>: &#123; <span class="attr">balance</span>: t.value&#125;,</div><div class="line">     <span class="attr">$pull</span>: &#123; <span class="attr">pendingTransactions</span>: t._id &#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h4 id="将转账状态改为canceled"><a href="#将转账状态改为canceled" class="headerlink" title="将转账状态改为canceled"></a>将转账状态改为<code>canceled</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.transactions.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t._id, <span class="attr">state</span>: <span class="string">"canceling"</span> &#125;,</div><div class="line">   &#123;</div><div class="line">     <span class="attr">$set</span>: &#123; <span class="attr">state</span>: <span class="string">"cancelled"</span> &#125;,</div><div class="line">     <span class="attr">$currentDate</span>: &#123; <span class="attr">lastModified</span>: <span class="literal">true</span> &#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="多个应用冲突考虑"><a href="#多个应用冲突考虑" class="headerlink" title="多个应用冲突考虑"></a>多个应用冲突考虑</h2><p>通常来说，事务的存在，就能保证多个应用共同启动而且不会影响到数据的一致性。上述的两段提交过程中，根据<code>state</code>字段的值去更新事务状态，就能保证在多应用情况下重复操作产生的问题。（因为mongodb的单条更新操作是原子性的，一条更新成功了，其他所有基于<code>state</code>的查询没法查到数据）</p>
<p>举个例子：app1和app2同时去更新一个转账事务的状态，但是app1先于app2，当app1更新完成之后，事务状态已经被更新为<code>pending</code>，这时候app2再去更新，会因为查询条件不匹配而终止当前事务的执行。</p>
<p>简单来说，解决多应用问题最重要的一点就是保证在同一时刻，同一个事物只能由同一个应用处理。为了保证这一点，可以加一个功能类似于<code>state</code>的字段<code>application</code>，用于标识当前事务属于哪个应用。</p>
<p>例如下面的代码，将事务由<code>initial</code>状态改为<code>pending</code>状态<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">t = db.transactions.findAndModify(</div><div class="line">       &#123;</div><div class="line">         <span class="attr">query</span>: &#123; <span class="attr">state</span>: <span class="string">"initial"</span>, <span class="attr">application</span>: &#123; <span class="attr">$exists</span>: <span class="literal">false</span> &#125; &#125;,</div><div class="line">         <span class="attr">update</span>:</div><div class="line">           &#123;</div><div class="line">             <span class="attr">$set</span>: &#123; <span class="attr">state</span>: <span class="string">"pending"</span>, <span class="attr">application</span>: <span class="string">"App1"</span> &#125;,</div><div class="line">             <span class="attr">$currentDate</span>: &#123; <span class="attr">lastModified</span>: <span class="literal">true</span> &#125;</div><div class="line">           &#125;,</div><div class="line">         <span class="attr">new</span>: <span class="literal">true</span></div><div class="line">       &#125;</div><div class="line">    )</div></pre></td></tr></table></figure></p>
<p>如果本次事务执行失败了，可以使用上面的恢复步骤进行恢复，但是必须保证恢复时也是由原来的应用去执行，例如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dateThreshold = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">dateThreshold.setMinutes(dateThreshold.getMinutes() - <span class="number">30</span>);</div><div class="line"></div><div class="line">db.transactions.find(</div><div class="line">   &#123;</div><div class="line">     <span class="attr">application</span>: <span class="string">"App1"</span>,</div><div class="line">     <span class="attr">state</span>: <span class="string">"pending"</span>,</div><div class="line">     <span class="attr">lastModified</span>: &#123; <span class="attr">$lt</span>: dateThreshold &#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是通过两步提交在mongodb中实现多谢如操作事务的原型，在生产环境中情况可能会更加复杂，所以必须根据实际情况而定</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><a href="https://docs.mongodb.com/manual/tutorial/perform-two-phase-commits/" title="Perform Two Phase Commits" target="_blank" rel="external">mogodb doc Perform Two Phase Commits</a>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;mongodb所有的针对单个文档的操作都具有原子性，但是当一个操作涉及多个文档更新的时候，是非原子性的。但在生产环境中，是存在多文档更新的需求的，一般情况下，包含以下两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性：如果任何一个操作失败，所有已经进行的操作全部回滚，并且中断接下来的所有操作&lt;/li&gt;
&lt;li&gt;一致性：如果操作执行过程遭遇中断，例如断电，数据库要有能力保持数据一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决多文档更新事务性问题，可以使用两段提交的方式处理。两段提交可以保证数据是一致的，而且可以保证遇到错误之后可以恢复，但是在执行期间，文档本身处于待定状态&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：因为mongodb只有单文档操作具有事务性，两段提交只能提供类似原子操作的语义，而不是提供完善的事务机制&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="mongodb" scheme="http://cocacola183.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://cocacola183.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>mongos cursor 的使用</title>
    <link href="http://cocacola183.github.io/2017/06/01/node/mongos-cursor-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://cocacola183.github.io/2017/06/01/node/mongos-cursor-的使用/</id>
    <published>2017-06-01T10:35:07.000Z</published>
    <updated>2017-07-02T12:31:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><div style="text-align:center">
  <div class="github-card" data-user="Automattic" data-repo="mongoose" data-width="100%" data-theme="default" data-target="" data-client-id="" data-client-secret=""></div>
</div>
<script src="/github-card-lib/githubcard.js"></script>

<p><code>mongoose</code>在github上是一个很受欢迎的开源项目，作为加强版的mongo node driver，有很多优点，但是无奈文档不怎么全面，下面是一些关于<code>mongoose cursor</code>的用法总结</p>
<a id="more"></a>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>node 6.9.1</li>
<li>mongoose 4.11.0 （如果可能，尽量用新版，开源的东西，你懂的）</li>
</ul>
<h2 id="cursor基础"><a href="#cursor基础" class="headerlink" title="cursor基础"></a>cursor基础</h2><p><a href="https://docs.mongodb.com/v3.0/core/cursors/" target="_blank" rel="external">参考链接</a></p>
<h3 id="cursor生命周期"><a href="#cursor生命周期" class="headerlink" title="cursor生命周期"></a>cursor生命周期</h3><p>cursor就是mongodb查询游标，利用它可以返回所有的查询结果，可以一次性返回，可以分批返回。</p>
<p>默认情况下，查询游标的生存周期是10分钟，如果在这期间，cursor耗尽（已经返回了所有结果），mongo server也会关闭这个cursor。cursor有选项noTimeout，可以阻止这个默认行为，如果使用了这个选项，就必须要手动关闭cursor或者是药最终有能力耗尽这个cursor。</p>
<h3 id="cursor隔离性"><a href="#cursor隔离性" class="headerlink" title="cursor隔离性"></a>cursor隔离性</h3><p>cursor使用过程当中肯定存在一些其他的操作会影响正在查询的数据，如果使用的饰mmapv1存储引擎，在某些情况下，会导致同一个document返回多次的情况，关于这一些，官方文档有详细的说明，建议大家早日更换wt</p>
<blockquote><p>As a cursor returns documents other operations may interleave with the query: with MMAPv1 storage engine, if some of these operations are updates that cause the document to move (in the case of a table scan, caused by document growth) or that change the indexed field on the index used by the query; then the cursor will return the same document more than once.</p>
<footer><strong>Mongodb doc</strong><cite><a href="https://docs.mongodb.com/v3.0/faq/developers/#faq-developers-isolate-cursors" target="_blank" rel="external">docs.mongodb.com/v3.0/faq/developers/#faq-developers-isolate-cursors</a></cite></footer></blockquote>
<h3 id="cursor-batch"><a href="#cursor-batch" class="headerlink" title="cursor batch"></a>cursor batch</h3><p>使用游标获取数据的时候，数据是分批返回的。每一批数据不能超过<a href="https://docs.mongodb.com/v3.0/reference/limits/#limit-bson-document-size" target="_blank" rel="external">maximum BSON document size</a>，默认情况下，第一批数据返回101条数据或者不超过1MB的数据，之后每次返回4M数据。可以手动设定batch size</p>
<h2 id="mongoose中使用cusror"><a href="#mongoose中使用cusror" class="headerlink" title="mongoose中使用cusror"></a>mongoose中使用cusror</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cursor = UserModel.find(&#123;<span class="attr">name</span>: <span class="string">'kivi'</span>&#125;).cursor(&#123;<span class="attr">batchSize</span>: <span class="number">100</span>&#125;);</div><div class="line">cursor.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</div><div class="line">  <span class="comment">// do something</span></div><div class="line">&#125;);</div><div class="line">cursor.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'cursor exausted'</span>;</div><div class="line">&#125;);</div><div class="line">cursor.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'got error'</span>, err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>一开始我也想着应该有什么方法能一次性拿到一个batch的数据，最终发现数据还是会一条一条的过来<br><blockquote><p>Batch sizes are just for performance optimisation and will not give you a 50 object chunk.<br>You will still have to process each doc individually.</p>
<footer><strong>stackoverflow</strong><cite><a href="https://stackoverflow.com/questions/42118590/mongoose-cursor-batchsize" target="_blank" rel="external">stackoverflow.com/questions/42118590/mongoose-cursor-batchsize</a></cite></footer></blockquote></p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>正常情况下，这么用是没问题的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cursor = model.aggregate(parameters).cursor(&#123; <span class="attr">batchSize</span>: <span class="number">1000</span> &#125;).exec();</div><div class="line">cursor.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</div><div class="line">  <span class="comment">// do something</span></div><div class="line">&#125;);</div><div class="line">cursor.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'cursor exausted'</span>;</div><div class="line">&#125;);</div><div class="line">cursor.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>但是上面的写法有的时候cursor是null，这是mongoose的一个bug，连接没有完全建立的时候就会出现这种情况</p>
<blockquote><p>It’s unfortunately a bug with the first way we implemented aggregation cursors - cursor will be undefined if the model’s underlying connection has not successfully connected. That’s what the async option for agg cursors is for:</p>
<p>model.aggregate(parameters).cursor({ batchSize: 1000, async: true }).exec(function(error, cursor) {<br>  // Can now use cursor<br>});<br>The reason why it needs to be async is that mongoose may need to wait for the connection to mongodb to be established before it can actually return the cursor.</p>
<footer><strong>mongoose</strong><cite><a href="https://github.com/Automattic/mongoose/issues/4694" target="_blank" rel="external">github.com/Automattic/mongoose/issues/4694</a></cite></footer></blockquote>
<p>所以下面的async参数非常有意义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">UserModel</div><div class="line">  .aggregate()</div><div class="line">  .cursor(&#123; <span class="attr">batchSize</span>: <span class="number">100</span>, <span class="attr">async</span>: <span class="literal">true</span> &#125;)</div><div class="line">  .exec(<span class="function"><span class="keyword">function</span> (<span class="params">err, cursor</span>) </span>&#123;</div><div class="line">      cursor.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</div><div class="line"></div><div class="line">      &#125;);</div><div class="line">      cursor.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      &#125;);</div><div class="line">      cursor.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line"></div><div class="line">      &#125;);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>以上是mongoose cursor使用的两个最基本的场景，以后会补充更多关于cursor更加丰富的用法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;div style=&quot;text-align:center&quot;&gt;
  &lt;div class=&quot;github-card&quot; data-user=&quot;Automattic&quot; data-repo=&quot;mongoose&quot; data-width=&quot;100%&quot; data-theme=&quot;default&quot; data-target=&quot;&quot; data-client-id=&quot;&quot; data-client-secret=&quot;&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&quot;/github-card-lib/githubcard.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;&lt;code&gt;mongoose&lt;/code&gt;在github上是一个很受欢迎的开源项目，作为加强版的mongo node driver，有很多优点，但是无奈文档不怎么全面，下面是一些关于&lt;code&gt;mongoose cursor&lt;/code&gt;的用法总结&lt;/p&gt;
    
    </summary>
    
      <category term="Node.js" scheme="http://cocacola183.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://cocacola183.github.io/tags/Node-js/"/>
    
      <category term="mongoose" scheme="http://cocacola183.github.io/tags/mongoose/"/>
    
  </entry>
  
  <entry>
    <title>mongodb常用命令整理</title>
    <link href="http://cocacola183.github.io/2017/05/22/mongo/mongodb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <id>http://cocacola183.github.io/2017/05/22/mongo/mongodb常用命令整理/</id>
    <published>2017-05-22T00:29:08.000Z</published>
    <updated>2017-07-02T12:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="慢查询相关"><a href="#慢查询相关" class="headerlink" title="慢查询相关"></a>慢查询相关</h2><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a><a href="https://blog.mlab.com/2014/02/mongodb-currentop-killop/" target="_blank" rel="external">慢查询</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.currentOp().inprog.forEach(</div><div class="line">  function(op) &#123;</div><div class="line">    if(op.secs_running &gt; 5) printjson(op);</div><div class="line">  &#125;</div><div class="line">)</div><div class="line"></div><div class="line">db.killOp(opid) // kill op</div></pre></td></tr></table></figure>
<p><a href="http://ultrasql.blog.51cto.com/9591438/1706481" target="_blank" rel="external">返回参数详解</a></p>
<a id="more"></a>
<h2 id="wiredtiger相关"><a href="#wiredtiger相关" class="headerlink" title="wiredtiger相关"></a>wiredtiger相关</h2><h3 id="查看mongodb-cache-size-bytes"><a href="#查看mongodb-cache-size-bytes" class="headerlink" title="查看mongodb cache size(bytes)"></a>查看mongodb cache size(bytes)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.runCommand( &#123; serverStatus: 1 &#125; ).wiredTiger.cache["bytes currently in the cache"]</div></pre></td></tr></table></figure>
<h3 id="查看mongodb内存占用-MB"><a href="#查看mongodb内存占用-MB" class="headerlink" title="查看mongodb内存占用(MB)"></a>查看mongodb内存占用(MB)</h3><h4 id="mongo-shell"><a href="#mongo-shell" class="headerlink" title="mongo shell"></a>mongo shell</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.runCommand( &#123; serverStatus: 1, workingSet: 1 &#125; ).mem.resident</div></pre></td></tr></table></figure>
<h4 id="linux-shell-最后一列是实际物理内存占用"><a href="#linux-shell-最后一列是实际物理内存占用" class="headerlink" title="linux shell(最后一列是实际物理内存占用)"></a>linux shell(最后一列是实际物理内存占用)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -e -o 'pid,comm,rsz'</div></pre></td></tr></table></figure>
<h4 id="查看系统缺页信息"><a href="#查看系统缺页信息" class="headerlink" title="查看系统缺页信息"></a><a href="https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab2/watch_linux_pagefault.md" target="_blank" rel="external">查看系统缺页信息</a></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -eo min_flt,maj_flt,pid,%cpu,%mem,pagein,args  --sort=min_flt | grep mongo</div></pre></td></tr></table></figure>
<h2 id="数据chunk相关"><a href="#数据chunk相关" class="headerlink" title="数据chunk相关"></a>数据chunk相关</h2><h3 id="查看chunk大小"><a href="#查看chunk大小" class="headerlink" title="查看chunk大小"></a>查看chunk大小</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var ns = "test.test"</div><div class="line">var key = &#123;account:1&#125; </div><div class="line"></div><div class="line">db.getSiblingDB("config").chunks.find(&#123;ns : ns&#125;).forEach(function(chunk) &#123;</div><div class="line">        var ds = db.getSiblingDB(ns.split(".")[0]).runCommand(&#123;datasize:chunk.ns,keyPattern:key,min:chunk.min,max:chunk.max&#125;);</div><div class="line">        print("Chunk: "+chunk._id +" has a size of "+ds.size+", and includes "+ds.numObjects+" objects (took "+ds.millis+"ms)")</div><div class="line">    &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="查询并切分大chunk"><a href="#查询并切分大chunk" class="headerlink" title="查询并切分大chunk"></a>查询并切分大chunk</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sh.stopBalancer()</div><div class="line"></div><div class="line">use config</div><div class="line">db.chunks.find(&#123;"ns": "test.user", jumbo: true&#125;)</div><div class="line"></div><div class="line">sh.splitAt("db.collection", &#123; account: "shardkey" &#125;)</div><div class="line"></div><div class="line">sh.splitFind("db.collection", &#123; account: "shardkey" &#125;)</div><div class="line"></div><div class="line">sh.moveChunk("db.collection", &#123; shardkey:"shardkey所在的块" &#125;, "需要移动的目标分片ID")</div><div class="line"></div><div class="line">sh.startBalancer()</div></pre></td></tr></table></figure>
<h2 id="Balancer"><a href="#Balancer" class="headerlink" title="Balancer"></a>Balancer</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use config</div><div class="line">db.settings.update(</div><div class="line">  &#123; _id: "balancer" &#125;,</div><div class="line">  &#123; $set: &#123; activeWindow : &#123; start: "23:00", stop: "6:00" &#125; &#125; &#125;,</div><div class="line">  &#123; upsert: true &#125;</div><div class="line"></div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h2><h3 id="js-shell"><a href="#js-shell" class="headerlink" title="js + shell"></a>js + shell</h3><p><a href="https://gist.github.com/bradvogel/f08c520887f3081a1e5dbc0f86531c7f#file-livesync-js" target="_blank" rel="external">迁移脚本</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;慢查询相关&quot;&gt;&lt;a href=&quot;#慢查询相关&quot; class=&quot;headerlink&quot; title=&quot;慢查询相关&quot;&gt;&lt;/a&gt;慢查询相关&lt;/h2&gt;&lt;h3 id=&quot;慢查询&quot;&gt;&lt;a href=&quot;#慢查询&quot; class=&quot;headerlink&quot; title=&quot;慢查询&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.mlab.com/2014/02/mongodb-currentop-killop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;慢查询&lt;/a&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;db.currentOp().inprog.forEach(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  function(op) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if(op.secs_running &amp;gt; 5) printjson(op);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;db.killOp(opid) // kill op&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;http://ultrasql.blog.51cto.com/9591438/1706481&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;返回参数详解&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mongodb" scheme="http://cocacola183.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://cocacola183.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>mongodb固定大小表</title>
    <link href="http://cocacola183.github.io/2017/05/09/mongo/mongodb%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E8%A1%A8/"/>
    <id>http://cocacola183.github.io/2017/05/09/mongo/mongodb固定大小表/</id>
    <published>2017-05-09T07:59:26.000Z</published>
    <updated>2017-07-02T02:33:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p><code>Capped collection</code>（固定大小表）是一种大小为可设定的固定值的集合。支持高性能写入操作和高性能以插入顺序读操作。<code>Capped collection</code>原理类似循环缓冲区，当达到最大限制时，会覆盖最老的数据用以写入新的数据。</p>
<h2 id="有什么特性"><a href="#有什么特性" class="headerlink" title="有什么特性"></a>有什么特性</h2><ul>
<li>大小固定可设定</li>
<li>提供高性能的写入操作，高性能的基于插入顺序的读操作</li>
</ul>
<h2 id="什么时候需要用"><a href="#什么时候需要用" class="headerlink" title="什么时候需要用"></a>什么时候需要用</h2><p>下面列举两个常见场景</p>
<h3 id="日志写入"><a href="#日志写入" class="headerlink" title="日志写入"></a>日志写入</h3><p>在大磁盘容量的系统中，在没有索引的前提下，以接近写日志文件的速度存储日志到<code>Capped collection</code>中。而且自带先进先出的磁盘空间使用策略</p>
<h3 id="缓存少量数据"><a href="#缓存少量数据" class="headerlink" title="缓存少量数据"></a>缓存少量数据</h3><p>缓存属于读取压力大，写入压力小的操作，如果不使用<code>Capped collection</code>，你就会面临两种选择</p>
<ul>
<li>牺牲写入性能，添加索引</li>
<li>让这部分数据常驻内存（占用内存空间）</li>
</ul>
<a id="more"></a>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><p>如果固定大小表会有更新操作，请先创建索引避免一次更新操作会扫描整个表</p>
<p>使用MMAPv1存储引擎的时候，如果有更新操作导致数据增长超过固定大小表的限制，更新将会失败</p>
<h3 id="使用MMAPv1存储引擎的副本集从节点"><a href="#使用MMAPv1存储引擎的副本集从节点" class="headerlink" title="使用MMAPv1存储引擎的副本集从节点"></a>使用MMAPv1存储引擎的副本集从节点</h3><p>如果主节点将固定大小表的size改小了，从节点也会随之改小</p>
<p>更新操作如果会让<code>Capped collection</code>超出配置的大小，primary节点会执行成功，secondary节点如果使用的是MMAPv1存储引擎，就会导致出现<code>failing update: objects in a capped ns cannot grow</code>的错误信息<br>为了解决这个问题，可以按照<a href="https://docs.mongodb.com/v3.0/tutorial/backup-with-filesystem-snapshots/" target="_blank" rel="external">这个教程</a>去处理secondary节点。<br>简单来说，方法就是把primary的数据目录复制一遍作为secondary的数据目录</p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p><code>Capped collection</code>无法删除部分文档，如果要删数据，只能drop掉表，然后新建一个新的<code>Capped collection</code></p>
<h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p><code>Capped collection</code>不能被分片</p>
<h3 id="Aggregation-out"><a href="#Aggregation-out" class="headerlink" title="Aggregation $out"></a>Aggregation $out</h3><p>聚合操作的$out操作符输出数据不能输出到<code>Capped collection</code></p>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.createCollection( "log", &#123; capped: true, size: 100000 &#125; ) // size的单位bytes</div></pre></td></tr></table></figure>
<ul>
<li>以上两个参数是必要参数</li>
<li><code>Capped collection</code>实际占用空间大小会略微大于配置的maxsize，因为有一些磁盘空间用于内部开销</li>
<li>如果size小于4096那么，<code>Capped collection</code>将认为size是4096，如果size大于4096，<code>Capped collection</code>会自动让size整除256</li>
</ul>
<p>也可以指定最大的document数量，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.createCollection(&quot;log&quot;, &#123; capped : true, size : 5242880, max : 5000 &#125; )</div></pre></td></tr></table></figure></p>
<blockquote>
<p>size是必传参数，size的优先级高于max</p>
</blockquote>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.cappedCollection.find().sort( &#123; $natural: -1 &#125; )</div></pre></td></tr></table></figure>
<p>上例是按照文档插入顺序倒排查询</p>
<h3 id="检查是否是Capped-collection"><a href="#检查是否是Capped-collection" class="headerlink" title="检查是否是Capped collection"></a>检查是否是<code>Capped collection</code></h3><p>db.collection.isCapped()</p>
<h3 id="将一个非Capped-collection转换为Capped-collection"><a href="#将一个非Capped-collection转换为Capped-collection" class="headerlink" title="将一个非Capped collection转换为Capped collection"></a>将一个非<code>Capped collection</code>转换为<code>Capped collection</code></h3><p>db.runCommand({“convertToCapped”: “mycoll”, size: 100000});</p>
<blockquote>
<p><span style="color: red">警告：这个命令会创建一个全局写锁，并且会阻塞其他操作一直到命令结束</span></p>
<p><span style="color: red">注意：分片集群不支持<code>convertToCapped</code>命令</span></p>
</blockquote>
<h3 id="设置自动删除数据的延迟时间"><a href="#设置自动删除数据的延迟时间" class="headerlink" title="设置自动删除数据的延迟时间"></a>设置自动删除数据的延迟时间</h3><p>如果想设置自动删除数据的延迟时间，可以参考mongodb的<a href="https://docs.mongodb.com/v3.0/reference/glossary/#term-ttl" target="_blank" rel="external">TTL索引</a>机制。遗憾的是TTL集合跟<code>Capped collection</code>并不兼容（没搞懂官网提这个搞什么）</p>
<h3 id="Tailable-Cursor"><a href="#Tailable-Cursor" class="headerlink" title="Tailable Cursor"></a>Tailable Cursor</h3><p><a href="https://docs.mongodb.com/v3.0/reference/glossary/#term-tailable-cursor" target="_blank" rel="external">tailable cursor</a>有点类似Unix命令<code>tail -f</code>，会跟踪文件新写入的内容，使用<code>tailable cursor</code>可以跟踪新插入到<code>Capped collection</code>中的数据</p>
<h2 id="其他相关概念"><a href="#其他相关概念" class="headerlink" title="其他相关概念"></a>其他相关概念</h2><h3 id="写入顺序"><a href="#写入顺序" class="headerlink" title="写入顺序"></a>写入顺序</h3><p><code>Capped collection</code>会保存数据写入顺序，所以如果返回数据顺序就是数据插入顺序，查询的时候不需要额外的索引去控制，<code>Capped collection</code>会自动以插入顺序返回。这种方式比使用索引有更好的性能</p>
<h3 id="旧数据的自动清除"><a href="#旧数据的自动清除" class="headerlink" title="旧数据的自动清除"></a>旧数据的自动清除</h3><p><code>Capped collection</code>会自动删除最老的数据，为新来的数据腾出空间，不需要代码控制</p>
<h3 id="id索引"><a href="#id索引" class="headerlink" title="_id索引"></a>_id索引</h3><p>2.4以及2.4以上的变更<br>固定大小表默认有_id字段，而且会默认在_id字段创建索引</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Capped collection&lt;/code&gt;（固定大小表）是一种大小为可设定的固定值的集合。支持高性能写入操作和高性能以插入顺序读操作。&lt;code&gt;Capped collection&lt;/code&gt;原理类似循环缓冲区，当达到最大限制时，会覆盖最老的数据用以写入新的数据。&lt;/p&gt;
&lt;h2 id=&quot;有什么特性&quot;&gt;&lt;a href=&quot;#有什么特性&quot; class=&quot;headerlink&quot; title=&quot;有什么特性&quot;&gt;&lt;/a&gt;有什么特性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;大小固定可设定&lt;/li&gt;
&lt;li&gt;提供高性能的写入操作，高性能的基于插入顺序的读操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么时候需要用&quot;&gt;&lt;a href=&quot;#什么时候需要用&quot; class=&quot;headerlink&quot; title=&quot;什么时候需要用&quot;&gt;&lt;/a&gt;什么时候需要用&lt;/h2&gt;&lt;p&gt;下面列举两个常见场景&lt;/p&gt;
&lt;h3 id=&quot;日志写入&quot;&gt;&lt;a href=&quot;#日志写入&quot; class=&quot;headerlink&quot; title=&quot;日志写入&quot;&gt;&lt;/a&gt;日志写入&lt;/h3&gt;&lt;p&gt;在大磁盘容量的系统中，在没有索引的前提下，以接近写日志文件的速度存储日志到&lt;code&gt;Capped collection&lt;/code&gt;中。而且自带先进先出的磁盘空间使用策略&lt;/p&gt;
&lt;h3 id=&quot;缓存少量数据&quot;&gt;&lt;a href=&quot;#缓存少量数据&quot; class=&quot;headerlink&quot; title=&quot;缓存少量数据&quot;&gt;&lt;/a&gt;缓存少量数据&lt;/h3&gt;&lt;p&gt;缓存属于读取压力大，写入压力小的操作，如果不使用&lt;code&gt;Capped collection&lt;/code&gt;，你就会面临两种选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;牺牲写入性能，添加索引&lt;/li&gt;
&lt;li&gt;让这部分数据常驻内存（占用内存空间）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="mongodb" scheme="http://cocacola183.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://cocacola183.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>分片对mongo curd的影响(小节)</title>
    <link href="http://cocacola183.github.io/2017/05/04/mongo/mongodb%E5%88%86%E7%89%87%E5%AF%B9curd%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <id>http://cocacola183.github.io/2017/05/04/mongo/mongodb分片对curd的影响/</id>
    <published>2017-05-04T07:17:47.000Z</published>
    <updated>2017-07-02T02:33:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>mongodb测试版本3.0.7</p>
<h2 id="分片对数据库操作的影响"><a href="#分片对数据库操作的影响" class="headerlink" title="分片对数据库操作的影响"></a>分片对数据库操作的影响</h2><h3 id="不受影响的api"><a href="#不受影响的api" class="headerlink" title="不受影响的api"></a>不受影响的api</h3><blockquote>
<p>注意这里只考虑api是否能正常使用，忽略分片对curd性能的影响 </p>
</blockquote>
<p>所有的插入，查询，删除操作都没有影响</p>
<h3 id="会受到影响的api"><a href="#会受到影响的api" class="headerlink" title="会受到影响的api"></a>会受到影响的api</h3><p><strong>更新(这里指的是update和所有类似update操作的方法，例如findAndModify等)</strong></p>
<p>同时存在以上三个条件，更新操作就都会失败</p>
<ul>
<li>查询条件中没有索引或者只包含了非unique索引(最常见的unique索引是_id)</li>
<li>查询条件中没有完整包含shard key</li>
<li>更新条件设定multi为false（只更新一条）</li>
</ul>
<p><strong>聚合查询group</strong></p>
<blockquote>
<p>注意: 所有的<code>group</code>操作都会失败</p>
</blockquote>
<p>聚合查询<code>aggregate</code>和<code>map reduce</code>都以用于sharded collection，<code>group</code>不能用于sharded collection</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;mongodb测试版本3.0.7&lt;/p&gt;
&lt;h2 id=&quot;分片对数据库操作的影响&quot;&gt;&lt;a href=&quot;#分片对数据库操作的影
    
    </summary>
    
      <category term="mongodb" scheme="http://cocacola183.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://cocacola183.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>武当山-湖北·十堰</title>
    <link href="http://cocacola183.github.io/2017/05/03/travel/%E6%AD%A6%E5%BD%93%E5%B1%B1-%E6%B9%96%E5%8C%97%C2%B7%E5%8D%81%E5%A0%B0/"/>
    <id>http://cocacola183.github.io/2017/05/03/travel/武当山-湖北·十堰/</id>
    <published>2017-05-03T15:10:09.000Z</published>
    <updated>2017-07-02T02:27:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考行程"><a href="#参考行程" class="headerlink" title="参考行程"></a>参考行程</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>如果和我有一样有以下相同出游前提</p>
<ul>
<li>游玩时间是五一节假日，出发地点是北京</li>
<li>香客（去武当山的目的之一是烧香）</li>
<li>出游时间仅有一天，而且有在山脚停留一晚的需要</li>
</ul>
<p>那么这个行程可能有一定的参考价值</p>
<a id="more"></a>
<h3 id="出游行程"><a href="#出游行程" class="headerlink" title="出游行程"></a>出游行程</h3><p><code>2017-04-28</code><br>晚卧铺从北京到十堰</p>
<blockquote>
<p>十堰市有个站是<code>武当山火车站</code>，可以直接买到这里的车票，出站坐<code>202路公交</code>就能直接去<code>武当山</code>了。如果买了<code>十堰火车站</code>的票，那就可以先从<code>武当山火车站</code>直接下车（先到武当山火车站）</p>
</blockquote>
<p><code>2017-04-29</code><br>下午三点半到达十堰市，从<code>十堰火车站</code>下车，乘坐202路公交（始发站），直达武当山，车程约<code>一个半</code>小时，到达住宿地点休息</p>
<p>关于住宿，这里要多说一点，有三类酒店</p>
<ul>
<li>山脚下，大门外的，一般都不贵。环境都一般我们选择的是这类酒店，虽然节假日住宿费直接翻倍，价格也可以接受大约在220左右（普通大床房）</li>
<li>山脚下，大门里的，这个并不推荐（有钱任性除外），外观豪华，位置一般。</li>
<li>山上，武当山旅游路线图上，有很多景点都有住宿的场所，最高的旅店直接在金顶（终点）脚下。如果是过来有充足的时间，可以考虑山脚呆一天，山上呆一天，如果有幸看到日出，也是极好的。一般上山时间会很久，没有办法感受到山中清晨的景色</li>
</ul>
<p>我们选择的是山脚下大门外的酒店，原因是我们携带的行李较多，不方便拿到山上去。<br>另外还有一点需要注意的是行李的问题，我们住的旅馆提供免费“寄存”的服务，但是也没有号码牌也没有什么别的，大家的东西都放在一堆，我们下山拿的时候，也就是说了声，就拿走了，有非常大的安全隐患。我估计其他的旅店也差不多的情况，所以尽量不要带太多东西去，最好能拿上所有东西上山。</p>
<p><code>2017-04-30</code><br>凌晨五点半起床，洗漱，准备<br>六点吃饭，吃完饭进门排队买票，等着走盘山路的车，大概花了一个小时<br>七点坐公交走盘山公路，这里有40分钟路程（蹒跚公路有两个选择，一个是坐车到<code>南岩</code>，爬山路金顶，另一个是直接坐到<code>琼台</code>，然后爬山，或者是坐索道上金顶）</p>
<blockquote>
<p>这40分钟盘山路走的会非常颠簸，动不动就会有180度的转弯，车会一直晃一只转，切记做好晕车准备</p>
</blockquote>
<p>我们选择的是爬上去，接近八点的时候开始从<code>南岩</code>往上爬，一直到11点到达金顶脚下，有三个小时的步行上山路程<br>上<code>金顶</code>的时候人特别多，堵到进门就要排队，<code>金顶</code>山峰非常陡峭，但是爬起来很快，慢的是排队的时间，正常上<code>金顶</code>，我觉得半个小时充足了，但是我们上去花了将近一个小时的时间<br>在<code>金顶</code>呆了大概20分钟<br>下<code>金顶</code>大概用了半个小时的时间，这里也是因为要排队<br>下了<code>金顶</code>之后我们选择坐索道回去，索道时间大概是10分钟，上索道之前会有免费照相服务，以武当山航拍图为背景，下了索道之后会免费送一张小照片，如果愿意付20元钱，会送一张大的留念卡<br>下了金顶之后就能迅速回到公交候车区，坐盘山公路回去了</p>
<h3 id="出行消费（双人）"><a href="#出行消费（双人）" class="headerlink" title="出行消费（双人）"></a>出行消费（双人）</h3><p>双人来回路费 2000（北京来回高铁，双人）<br>住宿 225<br>武当山门票 248/人<br>武当山金顶门票 27/人</p>
<h3 id="要带的东西"><a href="#要带的东西" class="headerlink" title="要带的东西"></a>要带的东西</h3><ul>
<li>晕车药</li>
<li>帽子</li>
<li>墨镜</li>
<li>太阳伞（雨伞）</li>
<li>一条专门擦汗的毛巾</li>
<li>防晒霜（女士）</li>
<li>登山杖，驱蚊药（非必选）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考行程&quot;&gt;&lt;a href=&quot;#参考行程&quot; class=&quot;headerlink&quot; title=&quot;参考行程&quot;&gt;&lt;/a&gt;参考行程&lt;/h2&gt;&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;如果和我有一样有以下相同出游前提&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;游玩时间是五一节假日，出发地点是北京&lt;/li&gt;
&lt;li&gt;香客（去武当山的目的之一是烧香）&lt;/li&gt;
&lt;li&gt;出游时间仅有一天，而且有在山脚停留一晚的需要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么这个行程可能有一定的参考价值&lt;/p&gt;
    
    </summary>
    
      <category term="travel" scheme="http://cocacola183.github.io/categories/travel/"/>
    
    
      <category term="travel" scheme="http://cocacola183.github.io/tags/travel/"/>
    
  </entry>
  
  <entry>
    <title>consul简单集群搭建</title>
    <link href="http://cocacola183.github.io/2017/03/15/consul/consul%E7%AE%80%E5%8D%95%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://cocacola183.github.io/2017/03/15/consul/consul简单集群搭建/</id>
    <published>2017-03-15T07:41:09.000Z</published>
    <updated>2017-07-02T02:29:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>一个基于docker的consul集群demo（多数据中心），目的不是为了在docker中使用consul（这个以后会写），而是借助docker作为承载consul的容器来实现集群搭建，因为consul需要使用的端口比较多。这里有最简单和最基本的（我认为）consul集群配置，旨在解决初学者一开始不知道怎么下手搭建集群的问题。</p>
<h2 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h2><ul>
<li>两个数据中心dc1, dc2</li>
<li>dc1中有4个节点, 三个server agent组成的server集群，和一个client agent作为客户端使用示例, dc1座位单个数据中示例</li>
<li>dc2中有2个节点, 一个server, 一个agnet, dc2主要用于测试多数据中心</li>
</ul>
<h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>macOS 10.12.2</p>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p><code>docker version</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Client:</div><div class="line">  Version:      1.12.0</div><div class="line">  API version:  1.24</div><div class="line">  Go version:   go1.6.3</div><div class="line">  Git commit:   8eab29e</div><div class="line">  Built:        Thu Jul 28 21:15:28 2016</div><div class="line">  OS/Arch:      darwin/amd64</div><div class="line"></div><div class="line">Server:</div><div class="line">  Version:      1.12.0</div><div class="line">  API version:  1.24</div><div class="line">  Go version:   go1.6.3</div><div class="line">  Git commit:   8eab29e</div><div class="line">  Built:        Thu Jul 28 23:54:00 2016</div><div class="line">  OS/Arch:      linux/amd64</div></pre></td></tr></table></figure></p>
<p><code>docker-compose version</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker-compose version 1.8.0, build f3628c7</div><div class="line">docker-py version: 1.9.0</div><div class="line">CPython version: 2.7.9</div><div class="line">OpenSSL version: OpenSSL 1.0.2h  3 May 2016</div></pre></td></tr></table></figure></p>
<p>docker版本稍微有点老，不过docker并不是本文的重点</p>
<a id="more"></a>
<h2 id="分分钟造火箭"><a href="#分分钟造火箭" class="headerlink" title="分分钟造火箭"></a>分分钟造火箭</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p><a href="https://github.com/CocaCola183/docker-consul/tree/master/examples/get-start" target="_blank" rel="external">以下所有代码地址</a></p>
<p>集群启动命令:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker network create consul</div><div class="line">./run.sh</div></pre></td></tr></table></figure></p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><h4 id="consul下载和安装"><a href="#consul下载和安装" class="headerlink" title="consul下载和安装"></a>consul下载和安装</h4><p>因为这里使用的是docker，所以直接pull镜像就可以了，但是还是提一下不使用docker的情况。consul下载地址在<a href="https://www.consul.io/downloads.html" target="_blank" rel="external">这里</a>，选择你最喜欢（最新）的版本下载就行了。下载完成之后就只有一个二进制文件（如果你是windows，那就一个exe，双击就能运行），直接执行就可以了。映射到path里面就是安装了，非常的方便。</p>
<h4 id="一个最简单的server配置"><a href="#一个最简单的server配置" class="headerlink" title="一个最简单的server配置"></a>一个最简单的server配置</h4><p>dc1-server1<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  "ui": true,                                     # 开启ui</div><div class="line">  "ui_dir": "/consul/ui",                         # ui绝对路径，可以官网下载最新的</div><div class="line">  "data_dir": "/consul/data",                     # consul数据存放目录</div><div class="line">  "bind_addr": "0.0.0.0",                         # 这个在后面做详细解释</div><div class="line">  "bootstrap_expect": 3,                          # 集群预期server节点数量</div><div class="line">  "retry_join": ["dc1-server2", "dc1-server3"],   # 组成集群的另外两个节点</div><div class="line"></div><div class="line">  "encrypt": "HSDVV9epQyQ3wYIla5R2hA==",          # gossip密钥，后面说明</div><div class="line">  "server": true,                                 # 是否是server</div><div class="line">  "retry_interval": "30s",                        # retry_interval和retry_max都是配合retry_join的</div><div class="line">  "retry_max": 10,</div><div class="line">  "log_level": "INFO",                            # 日志级别(trace, debug, info, warn, err)</div><div class="line">  "datacenter": "dc1",                            # 数据中心名称</div><div class="line">  "rejoin_after_leave": true,                     # leave之后是否重新加入，这个在这边文章中不重要</div><div class="line">  "leave_on_terminate": true                      # 进程关闭后leave</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>dc1-server1启动成功输出结果<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">==&gt; WARNING: Expect Mode enabled, expecting 3 servers</div><div class="line">==&gt; Starting Consul agent...</div><div class="line">==&gt; Starting Consul agent RPC...</div><div class="line">==&gt; Consul agent running!</div><div class="line">           Version: 'v0.7.5'</div><div class="line">           Node ID: '6a6f4d95-fdd1-4663-8017-34e3ce6abe68'</div><div class="line">         Node name: 'af5238a133cd'</div><div class="line">        Datacenter: 'dc1'</div><div class="line">            Server: true (bootstrap: false)</div><div class="line">       Client Addr: 127.0.0.1 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400)</div><div class="line">      Cluster Addr: 172.19.0.5 (LAN: 8301, WAN: 8302)</div><div class="line">    Gossip encrypt: true, RPC-TLS: false, TLS-Incoming: false</div><div class="line">             Atlas: &lt;disabled&gt;</div></pre></td></tr></table></figure></p>
<p>这里选择三点进行重点说明:</p>
<blockquote>
<p>bootstrap_expect</p>
</blockquote>
<p>因为我这里有三个容器作为consul server，所以这里设定bootstrap_expect为3，任一台启动后都retry_join另外两个节点。server一般推荐3～5个。另外，这里直接写了容器名，是因为docker自建bridge网络下，可以互相解析主机名。如果你是在服务器下使用，那直接写bind_addr的ip好了。</p>
<blockquote>
<p>bind_addr</p>
</blockquote>
<p>server agent，这个是consul服务绑定ip，还有一个配置叫advertise_addr，这个是用于和集群中其他节点通信的addr。如果不设置advertise_addr，默认bind_addr就是advertise_addr。还有一个配置叫做client_addr，这个是程序调用的地址，例如，通过http api获取集群信息，或者访问集群web ui，等等。</p>
<p>server agent一般选用public ip作为advertise_addr，private作为client_addr，这样public ip用于多数据中心通信，内网用于调用http api。</p>
<p>这里写0.0.0.0是为了让consul自己去获取ip，因为docker容器的ip不固定，我没法在一开始进行配置。设定0.0.0.0会自动bind机器上的所有ip，advertise第一个ipv4 address，容器起来就两个ip，一个127.0.0.1，一个就是局域网ip，这样就解决了ip问题</p>
<blockquote>
<p>encrypt</p>
</blockquote>
<p>这个值可以由consul生成，命令是<code>consul keygen</code>，使用这个值进行gossip encrypt。这里其实有一个简单的安全策略, server agent暴露集群ip为内网ip(前提是内网是值得信任的)，如果想要访问只能通过内网实现，如果是要添加client agent，则需要encrypt值。当然除了多数据中心无法实现（如果多个数据中心也组了一个内网也是可以实现的），这个策略提供了一个最基本的安全性保障</p>
<h3 id="一个简单的client的配置"><a href="#一个简单的client的配置" class="headerlink" title="一个简单的client的配置"></a>一个简单的client的配置</h3><p>dc1-client1<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"bind_addr"</span>: <span class="string">"0.0.0.0"</span>,</div><div class="line">  <span class="attr">"retry_join"</span>: [<span class="string">"dc1-server1"</span>],</div><div class="line"></div><div class="line">  <span class="attr">"encrypt"</span>: <span class="string">"HSDVV9epQyQ3wYIla5R2hA=="</span>,</div><div class="line">  <span class="attr">"server"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">"retry_interval"</span>: <span class="string">"30s"</span>,</div><div class="line">  <span class="attr">"retry_max"</span>: <span class="number">10</span>,</div><div class="line">  <span class="attr">"log_level"</span>: <span class="string">"INFO"</span>,</div><div class="line">  <span class="attr">"datacenter"</span>: <span class="string">"dc1"</span>,</div><div class="line">  <span class="attr">"rejoin_after_leave"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"leave_on_terminate"</span>: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动成功后输出<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">==&gt; Starting Consul agent...</div><div class="line">==&gt; Starting Consul agent RPC...</div><div class="line">==&gt; Consul agent running!</div><div class="line">           Version: 'v0.7.5'</div><div class="line">           Node ID: '6a6f4d95-fdd1-4663-8017-34e3ce6abe68'</div><div class="line">         Node name: '849f9a9af9e4'</div><div class="line">        Datacenter: 'dc1'</div><div class="line">            Server: false (bootstrap: false)</div><div class="line">       Client Addr: 127.0.0.1 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400)</div><div class="line">      Cluster Addr: 172.19.0.6 (LAN: 8301, WAN: 8302)</div><div class="line">    Gossip encrypt: true, RPC-TLS: false, TLS-Incoming: false</div><div class="line">             Atlas: &lt;disabled&gt;</div><div class="line"></div><div class="line">==&gt; Log data will now stream in as it occurs:</div><div class="line"></div><div class="line">    2017/03/16 02:06:55 [INFO] serf: EventMemberJoin: 849f9a9af9e4 172.19.0.6</div><div class="line">    2017/03/16 02:06:55 [WARN] manager: No servers available</div><div class="line">    2017/03/16 02:06:55 [ERR] agent: failed to sync remote state: No known Consul servers</div><div class="line">    2017/03/16 02:06:55 [INFO] agent: Joining cluster...</div><div class="line">    2017/03/16 02:06:55 [INFO] agent: (LAN) joining: [dc1-server1]</div><div class="line">    2017/03/16 02:06:55 [INFO] serf: EventMemberJoin: b54d8793677a 172.19.0.4</div><div class="line">    2017/03/16 02:06:55 [INFO] serf: EventMemberJoin: fa4d82838664 172.19.0.3</div><div class="line">    2017/03/16 02:06:55 [INFO] serf: EventMemberJoin: 0d816b9e0c1e 172.19.0.2</div><div class="line">    2017/03/16 02:06:55 [INFO] agent: (LAN) joined: 1 Err: &lt;nil&gt;</div><div class="line">    2017/03/16 02:06:55 [INFO] agent: Join completed. Synced with 1 initial agents</div><div class="line">    2017/03/16 02:06:55 [INFO] consul: adding server b54d8793677a (Addr: tcp/172.19.0.4:8300) (DC: dc1)</div><div class="line">    2017/03/16 02:06:55 [INFO] consul: adding server fa4d82838664 (Addr: tcp/172.19.0.3:8300) (DC: dc1)</div><div class="line">    2017/03/16 02:06:55 [INFO] consul: adding server 0d816b9e0c1e (Addr: tcp/172.19.0.2:8300) (DC: dc1)</div><div class="line">    2017/03/16 02:07:01 [INFO] consul: New leader elected: 0d816b9e0c1e</div><div class="line">    2017/03/16 02:07:01 [INFO] agent: Synced node info</div></pre></td></tr></table></figure></p>
<p>配置基本上和上面一样的，这里只说一点，retry-join这个参数的配置，只需要配置任一server即可，因为其他的server会自动被发现。</p>
<h4 id="ui的配置"><a href="#ui的配置" class="headerlink" title="ui的配置"></a>ui的配置</h4><p>ui的配置还是很有必要的，这个能非常直观的看到consul集群的信息，<a href="http://demo.consul.io/?_ga=1.9587189.1947061243.1483414531" target="_blank" rel="external">demo</a></p>
<p>配置很简单，只需要把<a href="https://releases.hashicorp.com/consul/0.7.5/consul_0.7.5_web_ui.zip?_ga=1.1614321.1947061243.1483414531" target="_blank" rel="external">这里</a>下载下来的静态文件放到配置文件指定的目录即可。</p>
<h4 id="多数据中心"><a href="#多数据中心" class="headerlink" title="多数据中心"></a>多数据中心</h4><p>dc2-server1配置中有这么一个配置: <code>&quot;retry_join&quot;: [&quot;dc1-server1&quot;]</code>，这样两个数据中心就有关联了。</p>
<h4 id="集群搭建完成之后集群成员查看"><a href="#集群搭建完成之后集群成员查看" class="headerlink" title="集群搭建完成之后集群成员查看"></a>集群搭建完成之后集群成员查看</h4><p>dc1<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/ # consul members</div><div class="line">Node          Address          Status  Type    Build  Protocol  DC</div><div class="line">0d816b9e0c1e  172.19.0.2:8301  alive   server  0.7.5  2         dc1</div><div class="line">849f9a9af9e4  172.19.0.6:8301  alive   client  0.7.5  2         dc1</div><div class="line">b54d8793677a  172.19.0.4:8301  alive   server  0.7.5  2         dc1</div><div class="line">fa4d82838664  172.19.0.3:8301  alive   server  0.7.5  2         dc1</div></pre></td></tr></table></figure></p>
<p>dc2<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/ # consul members</div><div class="line">Node          Address          Status  Type    Build  Protocol  DC</div><div class="line">be5a88e5badb  172.19.0.7:8301  alive   client  0.7.5  2         dc2</div><div class="line">db92c7930efb  172.19.0.5:8301  alive   server  0.7.5  2         dc2</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意</p>
</blockquote>
<p>这里只是提及了部分配置，所有的配置都写在项目的consul文件夹下，可以参考下不同，理解集群的原理。（很简单）</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>这里介绍集群搭建完成之后最简单的使用方法，以及一些相关的库</p>
<h3 id="简单的消除配置文件的方法"><a href="#简单的消除配置文件的方法" class="headerlink" title="简单的消除配置文件的方法"></a>简单的消除配置文件的方法</h3><p>服务启动的时候，调用consul api将服务注册到consul集群中，这样其他依赖这个服务的服务就可以获取到前者的ip和port了。其他的一些配置，例如数据库连接数，可以提前注册在key-value store中，这样也能通过api调用获取。一般情况下，配置文件也就基本是这些信息</p>
<h3 id="开发过程中正确的使用姿势"><a href="#开发过程中正确的使用姿势" class="headerlink" title="开发过程中正确的使用姿势"></a>开发过程中正确的使用姿势</h3><p>本地启动一个agent，加入到consul集群中，然后所有的信息，都从本地consul去获取。这里要强调的是开发过程中不要直接去使用集群中server节点，或者是使用其他client节点。所以任何时候应用需要调用consul api的时候，连接的都是localhost</p>
<h3 id="推荐三方库"><a href="#推荐三方库" class="headerlink" title="推荐三方库"></a>推荐三方库</h3><p><a href="https://github.com/silas/node-consul" target="_blank" rel="external">node-consul</a> 已经实践过，简单的需求都能满足<br><a href="https://github.com/savagegus/ansible-consul" target="_blank" rel="external">ansible-consul</a> 如果想使用ansbile部署使用consul，推荐使用这个库，也经过实践验证（可能需要改写）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;一个基于docker的consul集群demo（多数据中心），目的不是为了在docker中使用consul（这个以后会写），而是借助docker作为承载consul的容器来实现集群搭建，因为consul需要使用的端口比较多。这里有最简单和最基本的（我认为）consul集群配置，旨在解决初学者一开始不知道怎么下手搭建集群的问题。&lt;/p&gt;
&lt;h2 id=&quot;集群架构&quot;&gt;&lt;a href=&quot;#集群架构&quot; class=&quot;headerlink&quot; title=&quot;集群架构&quot;&gt;&lt;/a&gt;集群架构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;两个数据中心dc1, dc2&lt;/li&gt;
&lt;li&gt;dc1中有4个节点, 三个server agent组成的server集群，和一个client agent作为客户端使用示例, dc1座位单个数据中示例&lt;/li&gt;
&lt;li&gt;dc2中有2个节点, 一个server, 一个agnet, dc2主要用于测试多数据中心&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基础环境&quot;&gt;&lt;a href=&quot;#基础环境&quot; class=&quot;headerlink&quot; title=&quot;基础环境&quot;&gt;&lt;/a&gt;基础环境&lt;/h2&gt;&lt;h3 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h3&gt;&lt;p&gt;macOS 10.12.2&lt;/p&gt;
&lt;h3 id=&quot;docker&quot;&gt;&lt;a href=&quot;#docker&quot; class=&quot;headerlink&quot; title=&quot;docker&quot;&gt;&lt;/a&gt;docker&lt;/h3&gt;&lt;p&gt;&lt;code&gt;docker version&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Client:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Version:      1.12.0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  API version:  1.24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Go version:   go1.6.3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Git commit:   8eab29e&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Built:        Thu Jul 28 21:15:28 2016&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  OS/Arch:      darwin/amd64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Server:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Version:      1.12.0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  API version:  1.24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Go version:   go1.6.3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Git commit:   8eab29e&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Built:        Thu Jul 28 23:54:00 2016&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  OS/Arch:      linux/amd64&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker-compose version&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;docker-compose version 1.8.0, build f3628c7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;docker-py version: 1.9.0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CPython version: 2.7.9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OpenSSL version: OpenSSL 1.0.2h  3 May 2016&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;docker版本稍微有点老，不过docker并不是本文的重点&lt;/p&gt;
    
    </summary>
    
      <category term="consul" scheme="http://cocacola183.github.io/categories/consul/"/>
    
    
      <category term="consul" scheme="http://cocacola183.github.io/tags/consul/"/>
    
      <category term="微服务" scheme="http://cocacola183.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="注册发现" scheme="http://cocacola183.github.io/tags/%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
</feed>
