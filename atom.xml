<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kivi</title>
  <subtitle>没有什么远大理想，只是永远都不会满足而已</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cocacola183.github.io/"/>
  <updated>2017-07-09T14:27:29.000Z</updated>
  <id>http://cocacola183.github.io/</id>
  
  <author>
    <name>kivi</name>
    <email>s_f_dragon@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mongodb wt数据文件损坏解决方案</title>
    <link href="http://cocacola183.github.io/2017/07/08/mongo/mongodb-wt%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://cocacola183.github.io/2017/07/08/mongo/mongodb-wt数据文件损坏解决方案/</id>
    <published>2017-07-08T02:34:04.000Z</published>
    <updated>2017-07-09T14:27:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.alexbevi.com/blog/2016/02/10/recovering-a-wiredtiger-collection-from-a-corrupt-mongodb-installation/" target="_blank" rel="external">原文链接</a><br><a href="http://dev.guanghe.tv/2016/06/06/recovering-a-wiredtiger-collection-from-a-corrupt-wt-file/" target="_blank" rel="external">译文链接</a>，我看的这篇，因为没有给出来原文链接，所以刚开始没找到原文</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>数据文件是wt文件，而且是通过<code>snappy</code>方式压缩的，如果不是通过<code>snappy</code>方式，也可以参考下这个方式，不过执行命令可能有所不同 </p>
</blockquote>
<p>这个解决方案非常适合这样的场景：服务器意外故障（例如断电），突然停机，导致mongodb数据文件损坏，进而导致了<code>mongod</code>进程无法启动</p>
<a id="more"></a>
<p>但是我却是遇到了这样的问题：服务器由于磁盘空间占用达到100%导致<code>mongod</code>进程挂掉，由于磁盘100%，无法再启动mongo进程，所以工作人员直接删掉了部分的wt文件，释放部分磁盘空间，然后再次启动mongo的时候，发现无法启动了。。。</p>
<p>无法启动的原因是mongo启动的时候会做一次检测，检查mongodb的数据文件和某个地方存储的信息是否一致的（具体这个位置我们暂时还不清楚），如果不一致，将会无法启动mongo进程。进程无法启动导致了很多严重的问题，好在这个数据库记录的都是一些非业务信息，数据的查询更新操作也不算太多，为了让集群快速可用，我们直接更改了一个空的数据目录，启动<code>mongod</code>进程，让集群先可用</p>
<p>然后问题来了，原来的数据要怎么恢复呢？于是我们就有了从wt文件中抽取出数据的需求，所以就有了以下过程</p>
<h2 id="恢复过程"><a href="#恢复过程" class="headerlink" title="恢复过程"></a>恢复过程</h2><h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><p><a href="http://source.wiredtiger.com/" target="_blank" rel="external">最新下载页面</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">yum install -y snappy</div><div class="line">wget http://source.wiredtiger.com/releases/wiredtiger-2.9.3.tar.bz2</div><div class="line"><span class="meta">#</span><span class="bash"> 解压，进入目录</span></div><div class="line">./configure --enable-snappy</div></pre></td></tr></table></figure>
<h3 id="准备恢复目录mongo-bak"><a href="#准备恢复目录mongo-bak" class="headerlink" title="准备恢复目录mongo-bak"></a>准备恢复目录mongo-bak</h3><p>目录包含以下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">collection********.wt</div><div class="line">_mdb_catalog.wt</div><div class="line">sizeStorer.wt</div><div class="line">storage.bson</div><div class="line">WiredTiger</div><div class="line">WiredTiger.basecfg</div><div class="line">WiredTiger.lock</div><div class="line">WiredTiger.turtle</div><div class="line">WiredTiger.wt</div></pre></td></tr></table></figure></p>
<h3 id="数据文件修复（我没做这一步处理因为没有必要）"><a href="#数据文件修复（我没做这一步处理因为没有必要）" class="headerlink" title="数据文件修复（我没做这一步处理因为没有必要）"></a>数据文件修复（我没做这一步处理因为没有必要）</h3><p>打捞出可以修复的部分</p>
<blockquote>
<p>注意仍在wt下载目录下执行</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./wt -v -h ../mongo-bak -C "extensions=[./ext/compressors/snappy/.libs/libwiredtiger_snappy.so]" -R salvage collection******.wt</div></pre></td></tr></table></figure>
<h3 id="数据格式调整"><a href="#数据格式调整" class="headerlink" title="数据格式调整"></a>数据格式调整</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./wt -v -h ../mongo-bak -C "extensions=[./ext/compressors/snappy/.libs/libwiredtiger_snappy.so]" -R dump -f ../collection.dump collection******</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，这个命令的最后一个参数是不带<code>.wt</code>的</p>
</blockquote>
<p>这样就把刚才修复的数据写到<code>collection.dump</code>中了</p>
<h3 id="在目标mongodb中创建一个集合（数据将会被恢复到这个mongodb中）"><a href="#在目标mongodb中创建一个集合（数据将会被恢复到这个mongodb中）" class="headerlink" title="在目标mongodb中创建一个集合（数据将会被恢复到这个mongodb中）"></a>在目标mongodb中创建一个集合（数据将会被恢复到这个mongodb中）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mongo</div><div class="line"><span class="meta">&gt;</span><span class="bash"> use Recovery</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> db.brokedCollection.insert(&#123;<span class="built_in">test</span>: 1&#125;)</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> db.brokedCollection.remove(&#123;&#125;)</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> db.brokedCollection.stats()</span></div></pre></td></tr></table></figure>
<p>创建完成之后，就能看到刚刚新建的wt文件了，假设记为<code>xxx.wt</code></p>
<h3 id="将collection-dump的数据写入xxx-wt"><a href="#将collection-dump的数据写入xxx-wt" class="headerlink" title="将collection.dump的数据写入xxx.wt"></a>将<code>collection.dump</code>的数据写入<code>xxx.wt</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./wt -v -h ../tmp-mongo -C "extensions=[./ext/compressors/snappy/.libs/libwiredtiger_snappy.so]" -R load -f ../collection.dump -r xxx</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，这里最后一个参数也是不带wt的。另外执行这一步的时候，必须要先关闭掉mongo进程，否则会提示wt文件被占用，无法写入数据</p>
</blockquote>
<h3 id="查看已经被恢复的数据"><a href="#查看已经被恢复的数据" class="headerlink" title="查看已经被恢复的数据"></a>查看已经被恢复的数据</h3><blockquote>
<p>将mongo进程启动之后，建议使用3.2的mongo客户端链接</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mongo</div><div class="line"><span class="meta">&gt;</span><span class="bash"> show dbs</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> use Recovery</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> show collections</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> db.brokedCollection.count()</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>count</code>是无法查到数据的，还是需要find</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> db.brokedCollection.find(&#123;&#125;, &#123;_id: 1&#125;)</span></div></pre></td></tr></table></figure>
<h3 id="将数据dump出来，然后重新写进去"><a href="#将数据dump出来，然后重新写进去" class="headerlink" title="将数据dump出来，然后重新写进去"></a>将数据dump出来，然后重新写进去</h3><p><code>mongodump</code></p>
<p><code>mongorestore</code></p>
<p>数据经过导入导出之后就可以<code>count</code>出来了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.alexbevi.com/blog/2016/02/10/recovering-a-wiredtiger-collection-from-a-corrupt-mongodb-installation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://dev.guanghe.tv/2016/06/06/recovering-a-wiredtiger-collection-from-a-corrupt-wt-file/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;译文链接&lt;/a&gt;，我看的这篇，因为没有给出来原文链接，所以刚开始没找到原文&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;数据文件是wt文件，而且是通过&lt;code&gt;snappy&lt;/code&gt;方式压缩的，如果不是通过&lt;code&gt;snappy&lt;/code&gt;方式，也可以参考下这个方式，不过执行命令可能有所不同 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个解决方案非常适合这样的场景：服务器意外故障（例如断电），突然停机，导致mongodb数据文件损坏，进而导致了&lt;code&gt;mongod&lt;/code&gt;进程无法启动&lt;/p&gt;
    
    </summary>
    
      <category term="mongodb" scheme="http://cocacola183.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://cocacola183.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>天云山-北京平谷</title>
    <link href="http://cocacola183.github.io/2017/07/02/travel/%E5%A4%A9%E4%BA%91%E5%B1%B1-%E5%8C%97%E4%BA%AC%E5%B9%B3%E8%B0%B7/"/>
    <id>http://cocacola183.github.io/2017/07/02/travel/天云山-北京平谷/</id>
    <published>2017-07-02T06:00:00.000Z</published>
    <updated>2017-07-02T10:22:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考行程"><a href="#参考行程" class="headerlink" title="参考行程"></a>参考行程</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>如果和我有一样有以下相同出游前提</p>
<ul>
<li>想站在玻璃制作的观景台上感受下直面万丈深渊的刺激</li>
<li>想爬山</li>
<li>人在北京</li>
<li>想利用周末出游</li>
</ul>
<p>那么这个行程可能有一定的参考价值</p>
<a id="more"></a>
<h3 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h3><p>从<a href="http://www.pgtys.com/index.htm" target="_blank" rel="external">天云山旅游风景区官网</a>上看，玻璃栈道目前处于维修状态，而且官网上的旅游路线图已经非常老了，没有任何参考价值，我们沿途走的路线官网上都没有相关信息，玻璃观景台应该是个新加进去的项目。官网上的信息提示玻璃栈道正处在维护当中，所以决定去玩之前看下官网是非常有必要的</p>
<h3 id="出游行程"><a href="#出游行程" class="headerlink" title="出游行程"></a>出游行程</h3><h4 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h4><p>2017年7月1日，周六，早上六点半起床（已经非常晚了），七点出发，坐地铁换乘到15号线，坐到终点站俸伯。我们有19站地铁的行程，大约一个小时也就是八点左右到达。朋友有车，从俸伯出发，开车往景点出发，大约又需要一个半小时的行程，才到达经典。新手新车上路，老司机可能快很多。也就是<code>九点半</code>左右开始爬山，大约到了<code>下午三点</code>刚刚好坐缆车到达山底。作为亚健康久坐党，我们的游玩时间应该可以作为充足游玩时间参考。</p>
<h4 id="游玩路线"><a href="#游玩路线" class="headerlink" title="游玩路线"></a>游玩路线</h4><p>我们选择的路线是去玻璃观景台桥的路线，这个路线没办法看到玻璃栈道，玻璃桥，摆渡车。不过玻璃观景台也是非常壮观的。很刺激。虽然带了个入门级的单反，但是没有拍下当时的景点路线图，回来找行程路线发现已经找不到了。总之，去这个地方玩最主要的内容其实就是爬山，如果不愿意爬山的话，建议还是不要来玩了，只是看玻璃栈道，意义并不太大。</p>
<h3 id="出行消费（双人）"><a href="#出行消费（双人）" class="headerlink" title="出行消费（双人）"></a>出行消费（双人）</h3><p>景区门票：78元/人  学生票39元<br>索道价格：单程100元/人<br>玻璃观景台门票： 40元/人 </p>
<h3 id="游玩建议-重要"><a href="#游玩建议-重要" class="headerlink" title="游玩建议(重要)"></a>游玩建议(重要)</h3><ul>
<li>一定自己带好水，半山腰有卖水的，山顶有卖水的，半山腰和山顶之间没有卖水的，半山腰的水，我们没有买，山顶的水10元一瓶，只有常温矿泉水，而且没有冰镇</li>
<li>做好防晒，接近山顶的时候，会有阳光暴晒</li>
<li>还有些其他的登山注意事项这里就不提啦，总之出来玩还是要多准备</li>
<li>景点非常偏僻，建议自驾开车去，周末的车不算太多（我们去的时候还可以），可以不用为怎么回去而担心。如果必须要使用公共交通工具，最好提前规划好路线</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有山有水，还有点称得上惊险刺激的玩意儿，价格也不算太贵，总的来说还是值得一去的好地方，如果不愿意爬上千万别去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考行程&quot;&gt;&lt;a href=&quot;#参考行程&quot; class=&quot;headerlink&quot; title=&quot;参考行程&quot;&gt;&lt;/a&gt;参考行程&lt;/h2&gt;&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;如果和我有一样有以下相同出游前提&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想站在玻璃制作的观景台上感受下直面万丈深渊的刺激&lt;/li&gt;
&lt;li&gt;想爬山&lt;/li&gt;
&lt;li&gt;人在北京&lt;/li&gt;
&lt;li&gt;想利用周末出游&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么这个行程可能有一定的参考价值&lt;/p&gt;
    
    </summary>
    
      <category term="travel" scheme="http://cocacola183.github.io/categories/travel/"/>
    
    
      <category term="travel" scheme="http://cocacola183.github.io/tags/travel/"/>
    
  </entry>
  
  <entry>
    <title>mongodb两段提交</title>
    <link href="http://cocacola183.github.io/2017/06/03/mongo/mongodb%E4%B8%A4%E6%AE%B5%E6%8F%90%E4%BA%A4/"/>
    <id>http://cocacola183.github.io/2017/06/03/mongo/mongodb两段提交/</id>
    <published>2017-06-02T23:57:25.000Z</published>
    <updated>2017-07-08T02:34:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>mongodb所有的针对单个文档的操作都具有原子性，但是当一个操作涉及多个文档更新的时候，是非原子性的。但在生产环境中，是存在多文档更新的需求的，一般情况下，包含以下两个方面：</p>
<ul>
<li>原子性：如果任何一个操作失败，所有已经进行的操作全部回滚，并且中断接下来的所有操作</li>
<li>一致性：如果操作执行过程遭遇中断，例如断电，数据库要有能力保持数据一致性</li>
</ul>
<p>为了解决多文档更新事务性问题，可以使用两段提交的方式处理。两段提交可以保证数据是一致的，而且可以保证遇到错误之后可以恢复，但是在执行期间，文档本身处于待定状态</p>
<blockquote>
<p>注意：因为mongodb只有单文档操作具有事务性，两段提交只能提供类似原子操作的语义，而不是提供完善的事务机制</p>
</blockquote>
<a id="more"></a>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><h3 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h3><p>银行账户A转账给银行账户B</p>
<p>该场景会使用两个集合：</p>
<ul>
<li>accounts  记录用户信息</li>
<li>transactions  记录转账事务状态</li>
</ul>
<h3 id="初始化账户信息"><a href="#初始化账户信息" class="headerlink" title="初始化账户信息"></a>初始化账户信息</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">db.accounts.insert(</div><div class="line">   [</div><div class="line">     &#123; <span class="attr">_id</span>: <span class="string">"A"</span>, <span class="attr">balance</span>: <span class="number">1000</span>, <span class="attr">pendingTransactions</span>: [] &#125;,</div><div class="line">     &#123; <span class="attr">_id</span>: <span class="string">"B"</span>, <span class="attr">balance</span>: <span class="number">1000</span>, <span class="attr">pendingTransactions</span>: [] &#125;</div><div class="line">   ]</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="初始化转账记录表"><a href="#初始化转账记录表" class="headerlink" title="初始化转账记录表"></a>初始化转账记录表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.transactions.insert(</div><div class="line">    &#123; <span class="attr">_id</span>: <span class="number">1</span>, <span class="attr">source</span>: <span class="string">"A"</span>, <span class="attr">destination</span>: <span class="string">"B"</span>, <span class="attr">value</span>: <span class="number">100</span>, <span class="attr">state</span>: <span class="string">"initial"</span>, <span class="attr">lastModified</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="查找转账事务"><a href="#查找转账事务" class="headerlink" title="查找转账事务"></a>查找转账事务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t = db.transactions.findOne( &#123; <span class="attr">state</span>: <span class="string">"initial"</span> &#125; )</div></pre></td></tr></table></figure>
<h3 id="将转账事务状态由initial改为pending"><a href="#将转账事务状态由initial改为pending" class="headerlink" title="将转账事务状态由initial改为pending"></a>将转账事务状态由initial改为pending</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.transactions.update(</div><div class="line">    &#123; <span class="attr">_id</span>: t._id, <span class="attr">state</span>: <span class="string">"initial"</span> &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">$set</span>: &#123; <span class="attr">state</span>: <span class="string">"pending"</span> &#125;,</div><div class="line">      <span class="attr">$currentDate</span>: &#123; <span class="attr">lastModified</span>: <span class="literal">true</span> &#125;</div><div class="line">    &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="将事物状态记录到账户信息中"><a href="#将事物状态记录到账户信息中" class="headerlink" title="将事物状态记录到账户信息中"></a>将事物状态记录到账户信息中</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.accounts.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t.source, <span class="attr">pendingTransactions</span>: &#123; <span class="attr">$ne</span>: t._id &#125; &#125;,</div><div class="line">   &#123; <span class="attr">$inc</span>: &#123; <span class="attr">balance</span>: -t.value &#125;, <span class="attr">$push</span>: &#123; <span class="attr">pendingTransactions</span>: t._id &#125; &#125;</div><div class="line">)</div><div class="line"></div><div class="line">db.accounts.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t.destination, <span class="attr">pendingTransactions</span>: &#123; <span class="attr">$ne</span>: t._id &#125; &#125;,</div><div class="line">   &#123; <span class="attr">$inc</span>: &#123; <span class="attr">balance</span>: t.value &#125;, <span class="attr">$push</span>: &#123; <span class="attr">pendingTransactions</span>: t._id &#125; &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="将转账事务状态由pending改为applied"><a href="#将转账事务状态由pending改为applied" class="headerlink" title="将转账事务状态由pending改为applied"></a>将转账事务状态由pending改为applied</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.transactions.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t._id, <span class="attr">state</span>: <span class="string">"pending"</span> &#125;,</div><div class="line">   &#123;</div><div class="line">     <span class="attr">$set</span>: &#123; <span class="attr">state</span>: <span class="string">"applied"</span> &#125;,</div><div class="line">     <span class="attr">$currentDate</span>: &#123; <span class="attr">lastModified</span>: <span class="literal">true</span> &#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="将事务状态从账户信息中移除"><a href="#将事务状态从账户信息中移除" class="headerlink" title="将事务状态从账户信息中移除"></a>将事务状态从账户信息中移除</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.accounts.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t.source, <span class="attr">pendingTransactions</span>: t._id &#125;,</div><div class="line">   &#123; <span class="attr">$pull</span>: &#123; <span class="attr">pendingTransactions</span>: t._id &#125; &#125;</div><div class="line">)</div><div class="line"></div><div class="line">db.accounts.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t.destination, <span class="attr">pendingTransactions</span>: t._id &#125;,</div><div class="line">   &#123; <span class="attr">$pull</span>: &#123; <span class="attr">pendingTransactions</span>: t._id &#125; &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="将转账事务状态由applied改为done"><a href="#将转账事务状态由applied改为done" class="headerlink" title="将转账事务状态由applied改为done"></a>将转账事务状态由applied改为done</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.transactions.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t._id, <span class="attr">state</span>: <span class="string">"applied"</span> &#125;,</div><div class="line">   &#123;</div><div class="line">     <span class="attr">$set</span>: &#123; <span class="attr">state</span>: <span class="string">"done"</span> &#125;,</div><div class="line">     <span class="attr">$currentDate</span>: &#123; <span class="attr">lastModified</span>: <span class="literal">true</span> &#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>以上就是整个转账流程</p>
<h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p>转账流程不是最重要的，最重要的是从故障恢复整个转账流程。下面介绍如何从各个阶段恢复转账流程</p>
<h3 id="从pending状态恢复"><a href="#从pending状态恢复" class="headerlink" title="从pending状态恢复"></a>从<code>pending</code>状态恢复</h3><p><code>pending</code>状态就是确定要开始转账，而且已经开始更新AB账户的数据了，但是从这里到转账状态变为<code>applied</code>期间，出现了问题</p>
<p>以下是从<code>pending</code>状态恢复的过程</p>
<h4 id="找到至少30分钟都未更新的而且state是pending的转账状态"><a href="#找到至少30分钟都未更新的而且state是pending的转账状态" class="headerlink" title="找到至少30分钟都未更新的而且state是pending的转账状态"></a>找到至少30分钟都未更新的而且state是<code>pending</code>的转账状态</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dateThreshold = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">dateThreshold.setMinutes(dateThreshold.getMinutes() - <span class="number">30</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> t = db.transactions.findOne( &#123; <span class="attr">state</span>: <span class="string">"pending"</span>, <span class="attr">lastModified</span>: &#123; <span class="attr">$lt</span>: dateThreshold &#125; &#125; );</div></pre></td></tr></table></figure>
<h4 id="然后从进行转账这一步骤重新执行即可"><a href="#然后从进行转账这一步骤重新执行即可" class="headerlink" title="然后从进行转账这一步骤重新执行即可"></a>然后从<code>进行转账</code>这一步骤重新执行即可</h4><h3 id="从applied状态恢复"><a href="#从applied状态恢复" class="headerlink" title="从applied状态恢复"></a>从<code>applied</code>状态恢复</h3><h4 id="找到至少30分钟都未更新的而且state是applied的转账状态"><a href="#找到至少30分钟都未更新的而且state是applied的转账状态" class="headerlink" title="找到至少30分钟都未更新的而且state是applied的转账状态"></a>找到至少30分钟都未更新的而且state是<code>applied</code>的转账状态</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dateThreshold = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">dateThreshold.setMinutes(dateThreshold.getMinutes() - <span class="number">30</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> t = db.transactions.findOne( &#123; <span class="attr">state</span>: <span class="string">"applied"</span>, <span class="attr">lastModified</span>: &#123; <span class="attr">$lt</span>: dateThreshold &#125; &#125; );</div></pre></td></tr></table></figure>
<h4 id="然后从更新用户信息这一步骤重新执行即可"><a href="#然后从更新用户信息这一步骤重新执行即可" class="headerlink" title="然后从更新用户信息这一步骤重新执行即可"></a>然后从<code>更新用户信息</code>这一步骤重新执行即可</h4><h2 id="故障回滚"><a href="#故障回滚" class="headerlink" title="故障回滚"></a>故障回滚</h2><h3 id="从applied状态进行回滚"><a href="#从applied状态进行回滚" class="headerlink" title="从applied状态进行回滚"></a>从<code>applied</code>状态进行回滚</h3><p>当转账进行到<code>applied</code>状态时，不推荐回滚了，可以直接恢复这个转账事务，然后再新建一个退款的事务，把钱再转回去</p>
<h3 id="从pending状态回滚"><a href="#从pending状态回滚" class="headerlink" title="从pending状态回滚"></a>从<code>pending</code>状态回滚</h3><h4 id="将转账状态更新为canceling"><a href="#将转账状态更新为canceling" class="headerlink" title="将转账状态更新为canceling"></a>将转账状态更新为<code>canceling</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.transactions.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t._id, <span class="attr">state</span>: <span class="string">"pending"</span> &#125;,</div><div class="line">   &#123;</div><div class="line">     <span class="attr">$set</span>: &#123; <span class="attr">state</span>: <span class="string">"canceling"</span> &#125;,</div><div class="line">     <span class="attr">$currentDate</span>: &#123; <span class="attr">lastModified</span>: <span class="literal">true</span> &#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h4 id="取消AB账户的信息修改"><a href="#取消AB账户的信息修改" class="headerlink" title="取消AB账户的信息修改"></a>取消AB账户的信息修改</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.accounts.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t.destination, <span class="attr">pendingTransactions</span>: t._id &#125;,</div><div class="line">   &#123;</div><div class="line">     <span class="attr">$inc</span>: &#123; <span class="attr">balance</span>: -t.value &#125;,</div><div class="line">     <span class="attr">$pull</span>: &#123; <span class="attr">pendingTransactions</span>: t._id &#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.accounts.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t.source, <span class="attr">pendingTransactions</span>: t._id &#125;,</div><div class="line">   &#123;</div><div class="line">     <span class="attr">$inc</span>: &#123; <span class="attr">balance</span>: t.value&#125;,</div><div class="line">     <span class="attr">$pull</span>: &#123; <span class="attr">pendingTransactions</span>: t._id &#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h4 id="将转账状态改为canceled"><a href="#将转账状态改为canceled" class="headerlink" title="将转账状态改为canceled"></a>将转账状态改为<code>canceled</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.transactions.update(</div><div class="line">   &#123; <span class="attr">_id</span>: t._id, <span class="attr">state</span>: <span class="string">"canceling"</span> &#125;,</div><div class="line">   &#123;</div><div class="line">     <span class="attr">$set</span>: &#123; <span class="attr">state</span>: <span class="string">"cancelled"</span> &#125;,</div><div class="line">     <span class="attr">$currentDate</span>: &#123; <span class="attr">lastModified</span>: <span class="literal">true</span> &#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="多个应用冲突考虑"><a href="#多个应用冲突考虑" class="headerlink" title="多个应用冲突考虑"></a>多个应用冲突考虑</h2><p>通常来说，事务的存在，就能保证多个应用共同启动而且不会影响到数据的一致性。上述的两段提交过程中，根据<code>state</code>字段的值去更新事务状态，就能保证在多应用情况下重复操作产生的问题。（因为mongodb的单条更新操作是原子性的，一条更新成功了，其他所有基于<code>state</code>的查询没法查到数据）</p>
<p>举个例子：app1和app2同时去更新一个转账事务的状态，但是app1先于app2，当app1更新完成之后，事务状态已经被更新为<code>pending</code>，这时候app2再去更新，会因为查询条件不匹配而终止当前事务的执行。</p>
<p>简单来说，解决多应用问题最重要的一点就是保证在同一时刻，同一个事物只能由同一个应用处理。为了保证这一点，可以加一个功能类似于<code>state</code>的字段<code>application</code>，用于标识当前事务属于哪个应用。</p>
<p>例如下面的代码，将事务由<code>initial</code>状态改为<code>pending</code>状态<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">t = db.transactions.findAndModify(</div><div class="line">       &#123;</div><div class="line">         <span class="attr">query</span>: &#123; <span class="attr">state</span>: <span class="string">"initial"</span>, <span class="attr">application</span>: &#123; <span class="attr">$exists</span>: <span class="literal">false</span> &#125; &#125;,</div><div class="line">         <span class="attr">update</span>:</div><div class="line">           &#123;</div><div class="line">             <span class="attr">$set</span>: &#123; <span class="attr">state</span>: <span class="string">"pending"</span>, <span class="attr">application</span>: <span class="string">"App1"</span> &#125;,</div><div class="line">             <span class="attr">$currentDate</span>: &#123; <span class="attr">lastModified</span>: <span class="literal">true</span> &#125;</div><div class="line">           &#125;,</div><div class="line">         <span class="attr">new</span>: <span class="literal">true</span></div><div class="line">       &#125;</div><div class="line">    )</div></pre></td></tr></table></figure></p>
<p>如果本次事务执行失败了，可以使用上面的恢复步骤进行恢复，但是必须保证恢复时也是由原来的应用去执行，例如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dateThreshold = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">dateThreshold.setMinutes(dateThreshold.getMinutes() - <span class="number">30</span>);</div><div class="line"></div><div class="line">db.transactions.find(</div><div class="line">   &#123;</div><div class="line">     <span class="attr">application</span>: <span class="string">"App1"</span>,</div><div class="line">     <span class="attr">state</span>: <span class="string">"pending"</span>,</div><div class="line">     <span class="attr">lastModified</span>: &#123; <span class="attr">$lt</span>: dateThreshold &#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是通过两步提交在mongodb中实现多谢如操作事务的原型，在生产环境中情况可能会更加复杂，所以必须根据实际情况而定</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><a href="https://docs.mongodb.com/manual/tutorial/perform-two-phase-commits/" title="Perform Two Phase Commits" target="_blank" rel="external">mogodb doc Perform Two Phase Commits</a>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;mongodb所有的针对单个文档的操作都具有原子性，但是当一个操作涉及多个文档更新的时候，是非原子性的。但在生产环境中，是存在多文档更新的需求的，一般情况下，包含以下两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性：如果任何一个操作失败，所有已经进行的操作全部回滚，并且中断接下来的所有操作&lt;/li&gt;
&lt;li&gt;一致性：如果操作执行过程遭遇中断，例如断电，数据库要有能力保持数据一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决多文档更新事务性问题，可以使用两段提交的方式处理。两段提交可以保证数据是一致的，而且可以保证遇到错误之后可以恢复，但是在执行期间，文档本身处于待定状态&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：因为mongodb只有单文档操作具有事务性，两段提交只能提供类似原子操作的语义，而不是提供完善的事务机制&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="mongodb" scheme="http://cocacola183.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://cocacola183.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>mongos cursor 的使用</title>
    <link href="http://cocacola183.github.io/2017/06/01/node/mongos-cursor-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://cocacola183.github.io/2017/06/01/node/mongos-cursor-的使用/</id>
    <published>2017-06-01T10:35:07.000Z</published>
    <updated>2017-07-02T12:31:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><div style="text-align:center">
  <div class="github-card" data-user="Automattic" data-repo="mongoose" data-width="100%" data-theme="default" data-target="" data-client-id="" data-client-secret=""></div>
</div>
<script src="/github-card-lib/githubcard.js"></script>

<p><code>mongoose</code>在github上是一个很受欢迎的开源项目，作为加强版的mongo node driver，有很多优点，但是无奈文档不怎么全面，下面是一些关于<code>mongoose cursor</code>的用法总结</p>
<a id="more"></a>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>node 6.9.1</li>
<li>mongoose 4.11.0 （如果可能，尽量用新版，开源的东西，你懂的）</li>
</ul>
<h2 id="cursor基础"><a href="#cursor基础" class="headerlink" title="cursor基础"></a>cursor基础</h2><p><a href="https://docs.mongodb.com/v3.0/core/cursors/" target="_blank" rel="external">参考链接</a></p>
<h3 id="cursor生命周期"><a href="#cursor生命周期" class="headerlink" title="cursor生命周期"></a>cursor生命周期</h3><p>cursor就是mongodb查询游标，利用它可以返回所有的查询结果，可以一次性返回，可以分批返回。</p>
<p>默认情况下，查询游标的生存周期是10分钟，如果在这期间，cursor耗尽（已经返回了所有结果），mongo server也会关闭这个cursor。cursor有选项noTimeout，可以阻止这个默认行为，如果使用了这个选项，就必须要手动关闭cursor或者是药最终有能力耗尽这个cursor。</p>
<h3 id="cursor隔离性"><a href="#cursor隔离性" class="headerlink" title="cursor隔离性"></a>cursor隔离性</h3><p>cursor使用过程当中肯定存在一些其他的操作会影响正在查询的数据，如果使用的饰mmapv1存储引擎，在某些情况下，会导致同一个document返回多次的情况，关于这一些，官方文档有详细的说明，建议大家早日更换wt</p>
<blockquote><p>As a cursor returns documents other operations may interleave with the query: with MMAPv1 storage engine, if some of these operations are updates that cause the document to move (in the case of a table scan, caused by document growth) or that change the indexed field on the index used by the query; then the cursor will return the same document more than once.</p>
<footer><strong>Mongodb doc</strong><cite><a href="https://docs.mongodb.com/v3.0/faq/developers/#faq-developers-isolate-cursors" target="_blank" rel="external">docs.mongodb.com/v3.0/faq/developers/#faq-developers-isolate-cursors</a></cite></footer></blockquote>
<h3 id="cursor-batch"><a href="#cursor-batch" class="headerlink" title="cursor batch"></a>cursor batch</h3><p>使用游标获取数据的时候，数据是分批返回的。每一批数据不能超过<a href="https://docs.mongodb.com/v3.0/reference/limits/#limit-bson-document-size" target="_blank" rel="external">maximum BSON document size</a>，默认情况下，第一批数据返回101条数据或者不超过1MB的数据，之后每次返回4M数据。可以手动设定batch size</p>
<h2 id="mongoose中使用cusror"><a href="#mongoose中使用cusror" class="headerlink" title="mongoose中使用cusror"></a>mongoose中使用cusror</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cursor = UserModel.find(&#123;<span class="attr">name</span>: <span class="string">'kivi'</span>&#125;).cursor(&#123;<span class="attr">batchSize</span>: <span class="number">100</span>&#125;);</div><div class="line">cursor.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</div><div class="line">  <span class="comment">// do something</span></div><div class="line">&#125;);</div><div class="line">cursor.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'cursor exausted'</span>;</div><div class="line">&#125;);</div><div class="line">cursor.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'got error'</span>, err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>一开始我也想着应该有什么方法能一次性拿到一个batch的数据，最终发现数据还是会一条一条的过来<br><blockquote><p>Batch sizes are just for performance optimisation and will not give you a 50 object chunk.<br>You will still have to process each doc individually.</p>
<footer><strong>stackoverflow</strong><cite><a href="https://stackoverflow.com/questions/42118590/mongoose-cursor-batchsize" target="_blank" rel="external">stackoverflow.com/questions/42118590/mongoose-cursor-batchsize</a></cite></footer></blockquote></p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>正常情况下，这么用是没问题的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cursor = model.aggregate(parameters).cursor(&#123; <span class="attr">batchSize</span>: <span class="number">1000</span> &#125;).exec();</div><div class="line">cursor.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</div><div class="line">  <span class="comment">// do something</span></div><div class="line">&#125;);</div><div class="line">cursor.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'cursor exausted'</span>;</div><div class="line">&#125;);</div><div class="line">cursor.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>但是上面的写法有的时候cursor是null，这是mongoose的一个bug，连接没有完全建立的时候就会出现这种情况</p>
<blockquote><p>It’s unfortunately a bug with the first way we implemented aggregation cursors - cursor will be undefined if the model’s underlying connection has not successfully connected. That’s what the async option for agg cursors is for:</p>
<p>model.aggregate(parameters).cursor({ batchSize: 1000, async: true }).exec(function(error, cursor) {<br>  // Can now use cursor<br>});<br>The reason why it needs to be async is that mongoose may need to wait for the connection to mongodb to be established before it can actually return the cursor.</p>
<footer><strong>mongoose</strong><cite><a href="https://github.com/Automattic/mongoose/issues/4694" target="_blank" rel="external">github.com/Automattic/mongoose/issues/4694</a></cite></footer></blockquote>
<p>所以下面的async参数非常有意义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">UserModel</div><div class="line">  .aggregate()</div><div class="line">  .cursor(&#123; <span class="attr">batchSize</span>: <span class="number">100</span>, <span class="attr">async</span>: <span class="literal">true</span> &#125;)</div><div class="line">  .exec(<span class="function"><span class="keyword">function</span> (<span class="params">err, cursor</span>) </span>&#123;</div><div class="line">      cursor.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</div><div class="line"></div><div class="line">      &#125;);</div><div class="line">      cursor.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      &#125;);</div><div class="line">      cursor.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line"></div><div class="line">      &#125;);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>以上是mongoose cursor使用的两个最基本的场景，以后会补充更多关于cursor更加丰富的用法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;div style=&quot;text-align:center&quot;&gt;
  &lt;div class=&quot;github-card&quot; data-user=&quot;Automattic&quot; data-repo=&quot;mongoose&quot; data-width=&quot;100%&quot; data-theme=&quot;default&quot; data-target=&quot;&quot; data-client-id=&quot;&quot; data-client-secret=&quot;&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&quot;/github-card-lib/githubcard.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;&lt;code&gt;mongoose&lt;/code&gt;在github上是一个很受欢迎的开源项目，作为加强版的mongo node driver，有很多优点，但是无奈文档不怎么全面，下面是一些关于&lt;code&gt;mongoose cursor&lt;/code&gt;的用法总结&lt;/p&gt;
    
    </summary>
    
      <category term="Node.js" scheme="http://cocacola183.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://cocacola183.github.io/tags/Node-js/"/>
    
      <category term="mongoose" scheme="http://cocacola183.github.io/tags/mongoose/"/>
    
  </entry>
  
  <entry>
    <title>mongodb常用命令整理</title>
    <link href="http://cocacola183.github.io/2017/05/22/mongo/mongodb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <id>http://cocacola183.github.io/2017/05/22/mongo/mongodb常用命令整理/</id>
    <published>2017-05-22T00:29:08.000Z</published>
    <updated>2017-07-02T12:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="慢查询相关"><a href="#慢查询相关" class="headerlink" title="慢查询相关"></a>慢查询相关</h2><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a><a href="https://blog.mlab.com/2014/02/mongodb-currentop-killop/" target="_blank" rel="external">慢查询</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.currentOp().inprog.forEach(</div><div class="line">  function(op) &#123;</div><div class="line">    if(op.secs_running &gt; 5) printjson(op);</div><div class="line">  &#125;</div><div class="line">)</div><div class="line"></div><div class="line">db.killOp(opid) // kill op</div></pre></td></tr></table></figure>
<p><a href="http://ultrasql.blog.51cto.com/9591438/1706481" target="_blank" rel="external">返回参数详解</a></p>
<a id="more"></a>
<h2 id="wiredtiger相关"><a href="#wiredtiger相关" class="headerlink" title="wiredtiger相关"></a>wiredtiger相关</h2><h3 id="查看mongodb-cache-size-bytes"><a href="#查看mongodb-cache-size-bytes" class="headerlink" title="查看mongodb cache size(bytes)"></a>查看mongodb cache size(bytes)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.runCommand( &#123; serverStatus: 1 &#125; ).wiredTiger.cache["bytes currently in the cache"]</div></pre></td></tr></table></figure>
<h3 id="查看mongodb内存占用-MB"><a href="#查看mongodb内存占用-MB" class="headerlink" title="查看mongodb内存占用(MB)"></a>查看mongodb内存占用(MB)</h3><h4 id="mongo-shell"><a href="#mongo-shell" class="headerlink" title="mongo shell"></a>mongo shell</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.runCommand( &#123; serverStatus: 1, workingSet: 1 &#125; ).mem.resident</div></pre></td></tr></table></figure>
<h4 id="linux-shell-最后一列是实际物理内存占用"><a href="#linux-shell-最后一列是实际物理内存占用" class="headerlink" title="linux shell(最后一列是实际物理内存占用)"></a>linux shell(最后一列是实际物理内存占用)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -e -o 'pid,comm,rsz'</div></pre></td></tr></table></figure>
<h4 id="查看系统缺页信息"><a href="#查看系统缺页信息" class="headerlink" title="查看系统缺页信息"></a><a href="https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab2/watch_linux_pagefault.md" target="_blank" rel="external">查看系统缺页信息</a></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -eo min_flt,maj_flt,pid,%cpu,%mem,pagein,args  --sort=min_flt | grep mongo</div></pre></td></tr></table></figure>
<h2 id="数据chunk相关"><a href="#数据chunk相关" class="headerlink" title="数据chunk相关"></a>数据chunk相关</h2><h3 id="查看chunk大小"><a href="#查看chunk大小" class="headerlink" title="查看chunk大小"></a>查看chunk大小</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var ns = "test.test"</div><div class="line">var key = &#123;account:1&#125; </div><div class="line"></div><div class="line">db.getSiblingDB("config").chunks.find(&#123;ns : ns&#125;).forEach(function(chunk) &#123;</div><div class="line">        var ds = db.getSiblingDB(ns.split(".")[0]).runCommand(&#123;datasize:chunk.ns,keyPattern:key,min:chunk.min,max:chunk.max&#125;);</div><div class="line">        print("Chunk: "+chunk._id +" has a size of "+ds.size+", and includes "+ds.numObjects+" objects (took "+ds.millis+"ms)")</div><div class="line">    &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="查询并切分大chunk"><a href="#查询并切分大chunk" class="headerlink" title="查询并切分大chunk"></a>查询并切分大chunk</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sh.stopBalancer()</div><div class="line"></div><div class="line">use config</div><div class="line">db.chunks.find(&#123;"ns": "test.user", jumbo: true&#125;)</div><div class="line"></div><div class="line">sh.splitAt("db.collection", &#123; account: "shardkey" &#125;)</div><div class="line"></div><div class="line">sh.splitFind("db.collection", &#123; account: "shardkey" &#125;)</div><div class="line"></div><div class="line">sh.moveChunk("db.collection", &#123; shardkey:"shardkey所在的块" &#125;, "需要移动的目标分片ID")</div><div class="line"></div><div class="line">sh.startBalancer()</div></pre></td></tr></table></figure>
<h2 id="Balancer"><a href="#Balancer" class="headerlink" title="Balancer"></a>Balancer</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use config</div><div class="line">db.settings.update(</div><div class="line">  &#123; _id: "balancer" &#125;,</div><div class="line">  &#123; $set: &#123; activeWindow : &#123; start: "23:00", stop: "6:00" &#125; &#125; &#125;,</div><div class="line">  &#123; upsert: true &#125;</div><div class="line"></div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h2><h3 id="js-shell"><a href="#js-shell" class="headerlink" title="js + shell"></a>js + shell</h3><p><a href="https://gist.github.com/bradvogel/f08c520887f3081a1e5dbc0f86531c7f#file-livesync-js" target="_blank" rel="external">迁移脚本</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;慢查询相关&quot;&gt;&lt;a href=&quot;#慢查询相关&quot; class=&quot;headerlink&quot; title=&quot;慢查询相关&quot;&gt;&lt;/a&gt;慢查询相关&lt;/h2&gt;&lt;h3 id=&quot;慢查询&quot;&gt;&lt;a href=&quot;#慢查询&quot; class=&quot;headerlink&quot; title=&quot;慢查询&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.mlab.com/2014/02/mongodb-currentop-killop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;慢查询&lt;/a&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;db.currentOp().inprog.forEach(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  function(op) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if(op.secs_running &amp;gt; 5) printjson(op);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;db.killOp(opid) // kill op&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;http://ultrasql.blog.51cto.com/9591438/1706481&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;返回参数详解&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mongodb" scheme="http://cocacola183.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://cocacola183.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>mongodb固定大小表</title>
    <link href="http://cocacola183.github.io/2017/05/09/mongo/mongodb%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E8%A1%A8/"/>
    <id>http://cocacola183.github.io/2017/05/09/mongo/mongodb固定大小表/</id>
    <published>2017-05-09T07:59:26.000Z</published>
    <updated>2017-07-02T02:33:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p><code>Capped collection</code>（固定大小表）是一种大小为可设定的固定值的集合。支持高性能写入操作和高性能以插入顺序读操作。<code>Capped collection</code>原理类似循环缓冲区，当达到最大限制时，会覆盖最老的数据用以写入新的数据。</p>
<h2 id="有什么特性"><a href="#有什么特性" class="headerlink" title="有什么特性"></a>有什么特性</h2><ul>
<li>大小固定可设定</li>
<li>提供高性能的写入操作，高性能的基于插入顺序的读操作</li>
</ul>
<h2 id="什么时候需要用"><a href="#什么时候需要用" class="headerlink" title="什么时候需要用"></a>什么时候需要用</h2><p>下面列举两个常见场景</p>
<h3 id="日志写入"><a href="#日志写入" class="headerlink" title="日志写入"></a>日志写入</h3><p>在大磁盘容量的系统中，在没有索引的前提下，以接近写日志文件的速度存储日志到<code>Capped collection</code>中。而且自带先进先出的磁盘空间使用策略</p>
<h3 id="缓存少量数据"><a href="#缓存少量数据" class="headerlink" title="缓存少量数据"></a>缓存少量数据</h3><p>缓存属于读取压力大，写入压力小的操作，如果不使用<code>Capped collection</code>，你就会面临两种选择</p>
<ul>
<li>牺牲写入性能，添加索引</li>
<li>让这部分数据常驻内存（占用内存空间）</li>
</ul>
<a id="more"></a>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><p>如果固定大小表会有更新操作，请先创建索引避免一次更新操作会扫描整个表</p>
<p>使用MMAPv1存储引擎的时候，如果有更新操作导致数据增长超过固定大小表的限制，更新将会失败</p>
<h3 id="使用MMAPv1存储引擎的副本集从节点"><a href="#使用MMAPv1存储引擎的副本集从节点" class="headerlink" title="使用MMAPv1存储引擎的副本集从节点"></a>使用MMAPv1存储引擎的副本集从节点</h3><p>如果主节点将固定大小表的size改小了，从节点也会随之改小</p>
<p>更新操作如果会让<code>Capped collection</code>超出配置的大小，primary节点会执行成功，secondary节点如果使用的是MMAPv1存储引擎，就会导致出现<code>failing update: objects in a capped ns cannot grow</code>的错误信息<br>为了解决这个问题，可以按照<a href="https://docs.mongodb.com/v3.0/tutorial/backup-with-filesystem-snapshots/" target="_blank" rel="external">这个教程</a>去处理secondary节点。<br>简单来说，方法就是把primary的数据目录复制一遍作为secondary的数据目录</p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p><code>Capped collection</code>无法删除部分文档，如果要删数据，只能drop掉表，然后新建一个新的<code>Capped collection</code></p>
<h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p><code>Capped collection</code>不能被分片</p>
<h3 id="Aggregation-out"><a href="#Aggregation-out" class="headerlink" title="Aggregation $out"></a>Aggregation $out</h3><p>聚合操作的$out操作符输出数据不能输出到<code>Capped collection</code></p>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.createCollection( "log", &#123; capped: true, size: 100000 &#125; ) // size的单位bytes</div></pre></td></tr></table></figure>
<ul>
<li>以上两个参数是必要参数</li>
<li><code>Capped collection</code>实际占用空间大小会略微大于配置的maxsize，因为有一些磁盘空间用于内部开销</li>
<li>如果size小于4096那么，<code>Capped collection</code>将认为size是4096，如果size大于4096，<code>Capped collection</code>会自动让size整除256</li>
</ul>
<p>也可以指定最大的document数量，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.createCollection(&quot;log&quot;, &#123; capped : true, size : 5242880, max : 5000 &#125; )</div></pre></td></tr></table></figure></p>
<blockquote>
<p>size是必传参数，size的优先级高于max</p>
</blockquote>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.cappedCollection.find().sort( &#123; $natural: -1 &#125; )</div></pre></td></tr></table></figure>
<p>上例是按照文档插入顺序倒排查询</p>
<h3 id="检查是否是Capped-collection"><a href="#检查是否是Capped-collection" class="headerlink" title="检查是否是Capped collection"></a>检查是否是<code>Capped collection</code></h3><p>db.collection.isCapped()</p>
<h3 id="将一个非Capped-collection转换为Capped-collection"><a href="#将一个非Capped-collection转换为Capped-collection" class="headerlink" title="将一个非Capped collection转换为Capped collection"></a>将一个非<code>Capped collection</code>转换为<code>Capped collection</code></h3><p>db.runCommand({“convertToCapped”: “mycoll”, size: 100000});</p>
<blockquote>
<p><span style="color: red">警告：这个命令会创建一个全局写锁，并且会阻塞其他操作一直到命令结束</span></p>
<p><span style="color: red">注意：分片集群不支持<code>convertToCapped</code>命令</span></p>
</blockquote>
<h3 id="设置自动删除数据的延迟时间"><a href="#设置自动删除数据的延迟时间" class="headerlink" title="设置自动删除数据的延迟时间"></a>设置自动删除数据的延迟时间</h3><p>如果想设置自动删除数据的延迟时间，可以参考mongodb的<a href="https://docs.mongodb.com/v3.0/reference/glossary/#term-ttl" target="_blank" rel="external">TTL索引</a>机制。遗憾的是TTL集合跟<code>Capped collection</code>并不兼容（没搞懂官网提这个搞什么）</p>
<h3 id="Tailable-Cursor"><a href="#Tailable-Cursor" class="headerlink" title="Tailable Cursor"></a>Tailable Cursor</h3><p><a href="https://docs.mongodb.com/v3.0/reference/glossary/#term-tailable-cursor" target="_blank" rel="external">tailable cursor</a>有点类似Unix命令<code>tail -f</code>，会跟踪文件新写入的内容，使用<code>tailable cursor</code>可以跟踪新插入到<code>Capped collection</code>中的数据</p>
<h2 id="其他相关概念"><a href="#其他相关概念" class="headerlink" title="其他相关概念"></a>其他相关概念</h2><h3 id="写入顺序"><a href="#写入顺序" class="headerlink" title="写入顺序"></a>写入顺序</h3><p><code>Capped collection</code>会保存数据写入顺序，所以如果返回数据顺序就是数据插入顺序，查询的时候不需要额外的索引去控制，<code>Capped collection</code>会自动以插入顺序返回。这种方式比使用索引有更好的性能</p>
<h3 id="旧数据的自动清除"><a href="#旧数据的自动清除" class="headerlink" title="旧数据的自动清除"></a>旧数据的自动清除</h3><p><code>Capped collection</code>会自动删除最老的数据，为新来的数据腾出空间，不需要代码控制</p>
<h3 id="id索引"><a href="#id索引" class="headerlink" title="_id索引"></a>_id索引</h3><p>2.4以及2.4以上的变更<br>固定大小表默认有_id字段，而且会默认在_id字段创建索引</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Capped collection&lt;/code&gt;（固定大小表）是一种大小为可设定的固定值的集合。支持高性能写入操作和高性能以插入顺序读操作。&lt;code&gt;Capped collection&lt;/code&gt;原理类似循环缓冲区，当达到最大限制时，会覆盖最老的数据用以写入新的数据。&lt;/p&gt;
&lt;h2 id=&quot;有什么特性&quot;&gt;&lt;a href=&quot;#有什么特性&quot; class=&quot;headerlink&quot; title=&quot;有什么特性&quot;&gt;&lt;/a&gt;有什么特性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;大小固定可设定&lt;/li&gt;
&lt;li&gt;提供高性能的写入操作，高性能的基于插入顺序的读操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么时候需要用&quot;&gt;&lt;a href=&quot;#什么时候需要用&quot; class=&quot;headerlink&quot; title=&quot;什么时候需要用&quot;&gt;&lt;/a&gt;什么时候需要用&lt;/h2&gt;&lt;p&gt;下面列举两个常见场景&lt;/p&gt;
&lt;h3 id=&quot;日志写入&quot;&gt;&lt;a href=&quot;#日志写入&quot; class=&quot;headerlink&quot; title=&quot;日志写入&quot;&gt;&lt;/a&gt;日志写入&lt;/h3&gt;&lt;p&gt;在大磁盘容量的系统中，在没有索引的前提下，以接近写日志文件的速度存储日志到&lt;code&gt;Capped collection&lt;/code&gt;中。而且自带先进先出的磁盘空间使用策略&lt;/p&gt;
&lt;h3 id=&quot;缓存少量数据&quot;&gt;&lt;a href=&quot;#缓存少量数据&quot; class=&quot;headerlink&quot; title=&quot;缓存少量数据&quot;&gt;&lt;/a&gt;缓存少量数据&lt;/h3&gt;&lt;p&gt;缓存属于读取压力大，写入压力小的操作，如果不使用&lt;code&gt;Capped collection&lt;/code&gt;，你就会面临两种选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;牺牲写入性能，添加索引&lt;/li&gt;
&lt;li&gt;让这部分数据常驻内存（占用内存空间）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="mongodb" scheme="http://cocacola183.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://cocacola183.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>分片对mongo curd的影响(小节)</title>
    <link href="http://cocacola183.github.io/2017/05/04/mongo/mongodb%E5%88%86%E7%89%87%E5%AF%B9curd%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <id>http://cocacola183.github.io/2017/05/04/mongo/mongodb分片对curd的影响/</id>
    <published>2017-05-04T07:17:47.000Z</published>
    <updated>2017-07-02T02:33:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>mongodb测试版本3.0.7</p>
<h2 id="分片对数据库操作的影响"><a href="#分片对数据库操作的影响" class="headerlink" title="分片对数据库操作的影响"></a>分片对数据库操作的影响</h2><h3 id="不受影响的api"><a href="#不受影响的api" class="headerlink" title="不受影响的api"></a>不受影响的api</h3><blockquote>
<p>注意这里只考虑api是否能正常使用，忽略分片对curd性能的影响 </p>
</blockquote>
<p>所有的插入，查询，删除操作都没有影响</p>
<h3 id="会受到影响的api"><a href="#会受到影响的api" class="headerlink" title="会受到影响的api"></a>会受到影响的api</h3><p><strong>更新(这里指的是update和所有类似update操作的方法，例如findAndModify等)</strong></p>
<p>同时存在以上三个条件，更新操作就都会失败</p>
<ul>
<li>查询条件中没有索引或者只包含了非unique索引(最常见的unique索引是_id)</li>
<li>查询条件中没有完整包含shard key</li>
<li>更新条件设定multi为false（只更新一条）</li>
</ul>
<p><strong>聚合查询group</strong></p>
<blockquote>
<p>注意: 所有的<code>group</code>操作都会失败</p>
</blockquote>
<p>聚合查询<code>aggregate</code>和<code>map reduce</code>都以用于sharded collection，<code>group</code>不能用于sharded collection</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;mongodb测试版本3.0.7&lt;/p&gt;
&lt;h2 id=&quot;分片对数据库操作的影响&quot;&gt;&lt;a href=&quot;#分片对数据库操作的影
    
    </summary>
    
      <category term="mongodb" scheme="http://cocacola183.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://cocacola183.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>武当山-湖北·十堰</title>
    <link href="http://cocacola183.github.io/2017/05/03/travel/%E6%AD%A6%E5%BD%93%E5%B1%B1-%E6%B9%96%E5%8C%97%C2%B7%E5%8D%81%E5%A0%B0/"/>
    <id>http://cocacola183.github.io/2017/05/03/travel/武当山-湖北·十堰/</id>
    <published>2017-05-03T15:10:09.000Z</published>
    <updated>2017-07-02T02:27:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考行程"><a href="#参考行程" class="headerlink" title="参考行程"></a>参考行程</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>如果和我有一样有以下相同出游前提</p>
<ul>
<li>游玩时间是五一节假日，出发地点是北京</li>
<li>香客（去武当山的目的之一是烧香）</li>
<li>出游时间仅有一天，而且有在山脚停留一晚的需要</li>
</ul>
<p>那么这个行程可能有一定的参考价值</p>
<a id="more"></a>
<h3 id="出游行程"><a href="#出游行程" class="headerlink" title="出游行程"></a>出游行程</h3><p><code>2017-04-28</code><br>晚卧铺从北京到十堰</p>
<blockquote>
<p>十堰市有个站是<code>武当山火车站</code>，可以直接买到这里的车票，出站坐<code>202路公交</code>就能直接去<code>武当山</code>了。如果买了<code>十堰火车站</code>的票，那就可以先从<code>武当山火车站</code>直接下车（先到武当山火车站）</p>
</blockquote>
<p><code>2017-04-29</code><br>下午三点半到达十堰市，从<code>十堰火车站</code>下车，乘坐202路公交（始发站），直达武当山，车程约<code>一个半</code>小时，到达住宿地点休息</p>
<p>关于住宿，这里要多说一点，有三类酒店</p>
<ul>
<li>山脚下，大门外的，一般都不贵。环境都一般我们选择的是这类酒店，虽然节假日住宿费直接翻倍，价格也可以接受大约在220左右（普通大床房）</li>
<li>山脚下，大门里的，这个并不推荐（有钱任性除外），外观豪华，位置一般。</li>
<li>山上，武当山旅游路线图上，有很多景点都有住宿的场所，最高的旅店直接在金顶（终点）脚下。如果是过来有充足的时间，可以考虑山脚呆一天，山上呆一天，如果有幸看到日出，也是极好的。一般上山时间会很久，没有办法感受到山中清晨的景色</li>
</ul>
<p>我们选择的是山脚下大门外的酒店，原因是我们携带的行李较多，不方便拿到山上去。<br>另外还有一点需要注意的是行李的问题，我们住的旅馆提供免费“寄存”的服务，但是也没有号码牌也没有什么别的，大家的东西都放在一堆，我们下山拿的时候，也就是说了声，就拿走了，有非常大的安全隐患。我估计其他的旅店也差不多的情况，所以尽量不要带太多东西去，最好能拿上所有东西上山。</p>
<p><code>2017-04-30</code><br>凌晨五点半起床，洗漱，准备<br>六点吃饭，吃完饭进门排队买票，等着走盘山路的车，大概花了一个小时<br>七点坐公交走盘山公路，这里有40分钟路程（蹒跚公路有两个选择，一个是坐车到<code>南岩</code>，爬山路金顶，另一个是直接坐到<code>琼台</code>，然后爬山，或者是坐索道上金顶）</p>
<blockquote>
<p>这40分钟盘山路走的会非常颠簸，动不动就会有180度的转弯，车会一直晃一只转，切记做好晕车准备</p>
</blockquote>
<p>我们选择的是爬上去，接近八点的时候开始从<code>南岩</code>往上爬，一直到11点到达金顶脚下，有三个小时的步行上山路程<br>上<code>金顶</code>的时候人特别多，堵到进门就要排队，<code>金顶</code>山峰非常陡峭，但是爬起来很快，慢的是排队的时间，正常上<code>金顶</code>，我觉得半个小时充足了，但是我们上去花了将近一个小时的时间<br>在<code>金顶</code>呆了大概20分钟<br>下<code>金顶</code>大概用了半个小时的时间，这里也是因为要排队<br>下了<code>金顶</code>之后我们选择坐索道回去，索道时间大概是10分钟，上索道之前会有免费照相服务，以武当山航拍图为背景，下了索道之后会免费送一张小照片，如果愿意付20元钱，会送一张大的留念卡<br>下了金顶之后就能迅速回到公交候车区，坐盘山公路回去了</p>
<h3 id="出行消费（双人）"><a href="#出行消费（双人）" class="headerlink" title="出行消费（双人）"></a>出行消费（双人）</h3><p>双人来回路费 2000（北京来回高铁，双人）<br>住宿 225<br>武当山门票 248/人<br>武当山金顶门票 27/人</p>
<h3 id="要带的东西"><a href="#要带的东西" class="headerlink" title="要带的东西"></a>要带的东西</h3><ul>
<li>晕车药</li>
<li>帽子</li>
<li>墨镜</li>
<li>太阳伞（雨伞）</li>
<li>一条专门擦汗的毛巾</li>
<li>防晒霜（女士）</li>
<li>登山杖，驱蚊药（非必选）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考行程&quot;&gt;&lt;a href=&quot;#参考行程&quot; class=&quot;headerlink&quot; title=&quot;参考行程&quot;&gt;&lt;/a&gt;参考行程&lt;/h2&gt;&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;如果和我有一样有以下相同出游前提&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;游玩时间是五一节假日，出发地点是北京&lt;/li&gt;
&lt;li&gt;香客（去武当山的目的之一是烧香）&lt;/li&gt;
&lt;li&gt;出游时间仅有一天，而且有在山脚停留一晚的需要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么这个行程可能有一定的参考价值&lt;/p&gt;
    
    </summary>
    
      <category term="travel" scheme="http://cocacola183.github.io/categories/travel/"/>
    
    
      <category term="travel" scheme="http://cocacola183.github.io/tags/travel/"/>
    
  </entry>
  
  <entry>
    <title>consul简单集群搭建</title>
    <link href="http://cocacola183.github.io/2017/03/15/consul/consul%E7%AE%80%E5%8D%95%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://cocacola183.github.io/2017/03/15/consul/consul简单集群搭建/</id>
    <published>2017-03-15T07:41:09.000Z</published>
    <updated>2017-07-02T02:29:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>一个基于docker的consul集群demo（多数据中心），目的不是为了在docker中使用consul（这个以后会写），而是借助docker作为承载consul的容器来实现集群搭建，因为consul需要使用的端口比较多。这里有最简单和最基本的（我认为）consul集群配置，旨在解决初学者一开始不知道怎么下手搭建集群的问题。</p>
<h2 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h2><ul>
<li>两个数据中心dc1, dc2</li>
<li>dc1中有4个节点, 三个server agent组成的server集群，和一个client agent作为客户端使用示例, dc1座位单个数据中示例</li>
<li>dc2中有2个节点, 一个server, 一个agnet, dc2主要用于测试多数据中心</li>
</ul>
<h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>macOS 10.12.2</p>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p><code>docker version</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Client:</div><div class="line">  Version:      1.12.0</div><div class="line">  API version:  1.24</div><div class="line">  Go version:   go1.6.3</div><div class="line">  Git commit:   8eab29e</div><div class="line">  Built:        Thu Jul 28 21:15:28 2016</div><div class="line">  OS/Arch:      darwin/amd64</div><div class="line"></div><div class="line">Server:</div><div class="line">  Version:      1.12.0</div><div class="line">  API version:  1.24</div><div class="line">  Go version:   go1.6.3</div><div class="line">  Git commit:   8eab29e</div><div class="line">  Built:        Thu Jul 28 23:54:00 2016</div><div class="line">  OS/Arch:      linux/amd64</div></pre></td></tr></table></figure></p>
<p><code>docker-compose version</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker-compose version 1.8.0, build f3628c7</div><div class="line">docker-py version: 1.9.0</div><div class="line">CPython version: 2.7.9</div><div class="line">OpenSSL version: OpenSSL 1.0.2h  3 May 2016</div></pre></td></tr></table></figure></p>
<p>docker版本稍微有点老，不过docker并不是本文的重点</p>
<a id="more"></a>
<h2 id="分分钟造火箭"><a href="#分分钟造火箭" class="headerlink" title="分分钟造火箭"></a>分分钟造火箭</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p><a href="https://github.com/CocaCola183/docker-consul/tree/master/examples/get-start" target="_blank" rel="external">以下所有代码地址</a></p>
<p>集群启动命令:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker network create consul</div><div class="line">./run.sh</div></pre></td></tr></table></figure></p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><h4 id="consul下载和安装"><a href="#consul下载和安装" class="headerlink" title="consul下载和安装"></a>consul下载和安装</h4><p>因为这里使用的是docker，所以直接pull镜像就可以了，但是还是提一下不使用docker的情况。consul下载地址在<a href="https://www.consul.io/downloads.html" target="_blank" rel="external">这里</a>，选择你最喜欢（最新）的版本下载就行了。下载完成之后就只有一个二进制文件（如果你是windows，那就一个exe，双击就能运行），直接执行就可以了。映射到path里面就是安装了，非常的方便。</p>
<h4 id="一个最简单的server配置"><a href="#一个最简单的server配置" class="headerlink" title="一个最简单的server配置"></a>一个最简单的server配置</h4><p>dc1-server1<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  "ui": true,                                     # 开启ui</div><div class="line">  "ui_dir": "/consul/ui",                         # ui绝对路径，可以官网下载最新的</div><div class="line">  "data_dir": "/consul/data",                     # consul数据存放目录</div><div class="line">  "bind_addr": "0.0.0.0",                         # 这个在后面做详细解释</div><div class="line">  "bootstrap_expect": 3,                          # 集群预期server节点数量</div><div class="line">  "retry_join": ["dc1-server2", "dc1-server3"],   # 组成集群的另外两个节点</div><div class="line"></div><div class="line">  "encrypt": "HSDVV9epQyQ3wYIla5R2hA==",          # gossip密钥，后面说明</div><div class="line">  "server": true,                                 # 是否是server</div><div class="line">  "retry_interval": "30s",                        # retry_interval和retry_max都是配合retry_join的</div><div class="line">  "retry_max": 10,</div><div class="line">  "log_level": "INFO",                            # 日志级别(trace, debug, info, warn, err)</div><div class="line">  "datacenter": "dc1",                            # 数据中心名称</div><div class="line">  "rejoin_after_leave": true,                     # leave之后是否重新加入，这个在这边文章中不重要</div><div class="line">  "leave_on_terminate": true                      # 进程关闭后leave</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>dc1-server1启动成功输出结果<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">==&gt; WARNING: Expect Mode enabled, expecting 3 servers</div><div class="line">==&gt; Starting Consul agent...</div><div class="line">==&gt; Starting Consul agent RPC...</div><div class="line">==&gt; Consul agent running!</div><div class="line">           Version: 'v0.7.5'</div><div class="line">           Node ID: '6a6f4d95-fdd1-4663-8017-34e3ce6abe68'</div><div class="line">         Node name: 'af5238a133cd'</div><div class="line">        Datacenter: 'dc1'</div><div class="line">            Server: true (bootstrap: false)</div><div class="line">       Client Addr: 127.0.0.1 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400)</div><div class="line">      Cluster Addr: 172.19.0.5 (LAN: 8301, WAN: 8302)</div><div class="line">    Gossip encrypt: true, RPC-TLS: false, TLS-Incoming: false</div><div class="line">             Atlas: &lt;disabled&gt;</div></pre></td></tr></table></figure></p>
<p>这里选择三点进行重点说明:</p>
<blockquote>
<p>bootstrap_expect</p>
</blockquote>
<p>因为我这里有三个容器作为consul server，所以这里设定bootstrap_expect为3，任一台启动后都retry_join另外两个节点。server一般推荐3～5个。另外，这里直接写了容器名，是因为docker自建bridge网络下，可以互相解析主机名。如果你是在服务器下使用，那直接写bind_addr的ip好了。</p>
<blockquote>
<p>bind_addr</p>
</blockquote>
<p>server agent，这个是consul服务绑定ip，还有一个配置叫advertise_addr，这个是用于和集群中其他节点通信的addr。如果不设置advertise_addr，默认bind_addr就是advertise_addr。还有一个配置叫做client_addr，这个是程序调用的地址，例如，通过http api获取集群信息，或者访问集群web ui，等等。</p>
<p>server agent一般选用public ip作为advertise_addr，private作为client_addr，这样public ip用于多数据中心通信，内网用于调用http api。</p>
<p>这里写0.0.0.0是为了让consul自己去获取ip，因为docker容器的ip不固定，我没法在一开始进行配置。设定0.0.0.0会自动bind机器上的所有ip，advertise第一个ipv4 address，容器起来就两个ip，一个127.0.0.1，一个就是局域网ip，这样就解决了ip问题</p>
<blockquote>
<p>encrypt</p>
</blockquote>
<p>这个值可以由consul生成，命令是<code>consul keygen</code>，使用这个值进行gossip encrypt。这里其实有一个简单的安全策略, server agent暴露集群ip为内网ip(前提是内网是值得信任的)，如果想要访问只能通过内网实现，如果是要添加client agent，则需要encrypt值。当然除了多数据中心无法实现（如果多个数据中心也组了一个内网也是可以实现的），这个策略提供了一个最基本的安全性保障</p>
<h3 id="一个简单的client的配置"><a href="#一个简单的client的配置" class="headerlink" title="一个简单的client的配置"></a>一个简单的client的配置</h3><p>dc1-client1<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"bind_addr"</span>: <span class="string">"0.0.0.0"</span>,</div><div class="line">  <span class="attr">"retry_join"</span>: [<span class="string">"dc1-server1"</span>],</div><div class="line"></div><div class="line">  <span class="attr">"encrypt"</span>: <span class="string">"HSDVV9epQyQ3wYIla5R2hA=="</span>,</div><div class="line">  <span class="attr">"server"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">"retry_interval"</span>: <span class="string">"30s"</span>,</div><div class="line">  <span class="attr">"retry_max"</span>: <span class="number">10</span>,</div><div class="line">  <span class="attr">"log_level"</span>: <span class="string">"INFO"</span>,</div><div class="line">  <span class="attr">"datacenter"</span>: <span class="string">"dc1"</span>,</div><div class="line">  <span class="attr">"rejoin_after_leave"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"leave_on_terminate"</span>: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动成功后输出<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">==&gt; Starting Consul agent...</div><div class="line">==&gt; Starting Consul agent RPC...</div><div class="line">==&gt; Consul agent running!</div><div class="line">           Version: 'v0.7.5'</div><div class="line">           Node ID: '6a6f4d95-fdd1-4663-8017-34e3ce6abe68'</div><div class="line">         Node name: '849f9a9af9e4'</div><div class="line">        Datacenter: 'dc1'</div><div class="line">            Server: false (bootstrap: false)</div><div class="line">       Client Addr: 127.0.0.1 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400)</div><div class="line">      Cluster Addr: 172.19.0.6 (LAN: 8301, WAN: 8302)</div><div class="line">    Gossip encrypt: true, RPC-TLS: false, TLS-Incoming: false</div><div class="line">             Atlas: &lt;disabled&gt;</div><div class="line"></div><div class="line">==&gt; Log data will now stream in as it occurs:</div><div class="line"></div><div class="line">    2017/03/16 02:06:55 [INFO] serf: EventMemberJoin: 849f9a9af9e4 172.19.0.6</div><div class="line">    2017/03/16 02:06:55 [WARN] manager: No servers available</div><div class="line">    2017/03/16 02:06:55 [ERR] agent: failed to sync remote state: No known Consul servers</div><div class="line">    2017/03/16 02:06:55 [INFO] agent: Joining cluster...</div><div class="line">    2017/03/16 02:06:55 [INFO] agent: (LAN) joining: [dc1-server1]</div><div class="line">    2017/03/16 02:06:55 [INFO] serf: EventMemberJoin: b54d8793677a 172.19.0.4</div><div class="line">    2017/03/16 02:06:55 [INFO] serf: EventMemberJoin: fa4d82838664 172.19.0.3</div><div class="line">    2017/03/16 02:06:55 [INFO] serf: EventMemberJoin: 0d816b9e0c1e 172.19.0.2</div><div class="line">    2017/03/16 02:06:55 [INFO] agent: (LAN) joined: 1 Err: &lt;nil&gt;</div><div class="line">    2017/03/16 02:06:55 [INFO] agent: Join completed. Synced with 1 initial agents</div><div class="line">    2017/03/16 02:06:55 [INFO] consul: adding server b54d8793677a (Addr: tcp/172.19.0.4:8300) (DC: dc1)</div><div class="line">    2017/03/16 02:06:55 [INFO] consul: adding server fa4d82838664 (Addr: tcp/172.19.0.3:8300) (DC: dc1)</div><div class="line">    2017/03/16 02:06:55 [INFO] consul: adding server 0d816b9e0c1e (Addr: tcp/172.19.0.2:8300) (DC: dc1)</div><div class="line">    2017/03/16 02:07:01 [INFO] consul: New leader elected: 0d816b9e0c1e</div><div class="line">    2017/03/16 02:07:01 [INFO] agent: Synced node info</div></pre></td></tr></table></figure></p>
<p>配置基本上和上面一样的，这里只说一点，retry-join这个参数的配置，只需要配置任一server即可，因为其他的server会自动被发现。</p>
<h4 id="ui的配置"><a href="#ui的配置" class="headerlink" title="ui的配置"></a>ui的配置</h4><p>ui的配置还是很有必要的，这个能非常直观的看到consul集群的信息，<a href="http://demo.consul.io/?_ga=1.9587189.1947061243.1483414531" target="_blank" rel="external">demo</a></p>
<p>配置很简单，只需要把<a href="https://releases.hashicorp.com/consul/0.7.5/consul_0.7.5_web_ui.zip?_ga=1.1614321.1947061243.1483414531" target="_blank" rel="external">这里</a>下载下来的静态文件放到配置文件指定的目录即可。</p>
<h4 id="多数据中心"><a href="#多数据中心" class="headerlink" title="多数据中心"></a>多数据中心</h4><p>dc2-server1配置中有这么一个配置: <code>&quot;retry_join&quot;: [&quot;dc1-server1&quot;]</code>，这样两个数据中心就有关联了。</p>
<h4 id="集群搭建完成之后集群成员查看"><a href="#集群搭建完成之后集群成员查看" class="headerlink" title="集群搭建完成之后集群成员查看"></a>集群搭建完成之后集群成员查看</h4><p>dc1<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/ # consul members</div><div class="line">Node          Address          Status  Type    Build  Protocol  DC</div><div class="line">0d816b9e0c1e  172.19.0.2:8301  alive   server  0.7.5  2         dc1</div><div class="line">849f9a9af9e4  172.19.0.6:8301  alive   client  0.7.5  2         dc1</div><div class="line">b54d8793677a  172.19.0.4:8301  alive   server  0.7.5  2         dc1</div><div class="line">fa4d82838664  172.19.0.3:8301  alive   server  0.7.5  2         dc1</div></pre></td></tr></table></figure></p>
<p>dc2<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/ # consul members</div><div class="line">Node          Address          Status  Type    Build  Protocol  DC</div><div class="line">be5a88e5badb  172.19.0.7:8301  alive   client  0.7.5  2         dc2</div><div class="line">db92c7930efb  172.19.0.5:8301  alive   server  0.7.5  2         dc2</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意</p>
</blockquote>
<p>这里只是提及了部分配置，所有的配置都写在项目的consul文件夹下，可以参考下不同，理解集群的原理。（很简单）</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>这里介绍集群搭建完成之后最简单的使用方法，以及一些相关的库</p>
<h3 id="简单的消除配置文件的方法"><a href="#简单的消除配置文件的方法" class="headerlink" title="简单的消除配置文件的方法"></a>简单的消除配置文件的方法</h3><p>服务启动的时候，调用consul api将服务注册到consul集群中，这样其他依赖这个服务的服务就可以获取到前者的ip和port了。其他的一些配置，例如数据库连接数，可以提前注册在key-value store中，这样也能通过api调用获取。一般情况下，配置文件也就基本是这些信息</p>
<h3 id="开发过程中正确的使用姿势"><a href="#开发过程中正确的使用姿势" class="headerlink" title="开发过程中正确的使用姿势"></a>开发过程中正确的使用姿势</h3><p>本地启动一个agent，加入到consul集群中，然后所有的信息，都从本地consul去获取。这里要强调的是开发过程中不要直接去使用集群中server节点，或者是使用其他client节点。所以任何时候应用需要调用consul api的时候，连接的都是localhost</p>
<h3 id="推荐三方库"><a href="#推荐三方库" class="headerlink" title="推荐三方库"></a>推荐三方库</h3><p><a href="https://github.com/silas/node-consul" target="_blank" rel="external">node-consul</a> 已经实践过，简单的需求都能满足<br><a href="https://github.com/savagegus/ansible-consul" target="_blank" rel="external">ansible-consul</a> 如果想使用ansbile部署使用consul，推荐使用这个库，也经过实践验证（可能需要改写）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;一个基于docker的consul集群demo（多数据中心），目的不是为了在docker中使用consul（这个以后会写），而是借助docker作为承载consul的容器来实现集群搭建，因为consul需要使用的端口比较多。这里有最简单和最基本的（我认为）consul集群配置，旨在解决初学者一开始不知道怎么下手搭建集群的问题。&lt;/p&gt;
&lt;h2 id=&quot;集群架构&quot;&gt;&lt;a href=&quot;#集群架构&quot; class=&quot;headerlink&quot; title=&quot;集群架构&quot;&gt;&lt;/a&gt;集群架构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;两个数据中心dc1, dc2&lt;/li&gt;
&lt;li&gt;dc1中有4个节点, 三个server agent组成的server集群，和一个client agent作为客户端使用示例, dc1座位单个数据中示例&lt;/li&gt;
&lt;li&gt;dc2中有2个节点, 一个server, 一个agnet, dc2主要用于测试多数据中心&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基础环境&quot;&gt;&lt;a href=&quot;#基础环境&quot; class=&quot;headerlink&quot; title=&quot;基础环境&quot;&gt;&lt;/a&gt;基础环境&lt;/h2&gt;&lt;h3 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h3&gt;&lt;p&gt;macOS 10.12.2&lt;/p&gt;
&lt;h3 id=&quot;docker&quot;&gt;&lt;a href=&quot;#docker&quot; class=&quot;headerlink&quot; title=&quot;docker&quot;&gt;&lt;/a&gt;docker&lt;/h3&gt;&lt;p&gt;&lt;code&gt;docker version&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Client:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Version:      1.12.0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  API version:  1.24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Go version:   go1.6.3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Git commit:   8eab29e&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Built:        Thu Jul 28 21:15:28 2016&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  OS/Arch:      darwin/amd64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Server:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Version:      1.12.0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  API version:  1.24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Go version:   go1.6.3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Git commit:   8eab29e&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Built:        Thu Jul 28 23:54:00 2016&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  OS/Arch:      linux/amd64&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker-compose version&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;docker-compose version 1.8.0, build f3628c7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;docker-py version: 1.9.0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CPython version: 2.7.9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OpenSSL version: OpenSSL 1.0.2h  3 May 2016&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;docker版本稍微有点老，不过docker并不是本文的重点&lt;/p&gt;
    
    </summary>
    
      <category term="consul" scheme="http://cocacola183.github.io/categories/consul/"/>
    
    
      <category term="consul" scheme="http://cocacola183.github.io/tags/consul/"/>
    
      <category term="微服务" scheme="http://cocacola183.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="注册发现" scheme="http://cocacola183.github.io/tags/%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>consul调研</title>
    <link href="http://cocacola183.github.io/2017/03/08/consul/consul%E8%B0%83%E7%A0%94/"/>
    <id>http://cocacola183.github.io/2017/03/08/consul/consul调研/</id>
    <published>2017-03-08T13:35:04.000Z</published>
    <updated>2017-07-02T02:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li>我的服务相互依赖，而且数量较多，需要有合适的机制解决繁杂的配置文件配置问题</li>
<li>我要架设微服务架构，需要一个服务注册中心，需要一个较为完善的服务发现的机制</li>
</ul>
<p>上面是我找到consul的原因</p>
<h2 id="什么是consul"><a href="#什么是consul" class="headerlink" title="什么是consul"></a>什么是consul</h2><p><a href="https://www.consul.io/" target="_blank" rel="external">官网</a>的一句话总结里面有这么几个关键词: </p>
<ul>
<li>服务发现</li>
<li>简化配置</li>
<li>分布式(去中心化)</li>
<li>高可用 </li>
<li>多数据中心</li>
</ul>
<p>在<a href="https://github.com/hashicorp/consul" target="_blank" rel="external">github</a>上，consul给出了这么几个关键特性：</p>
<ul>
<li>服务发现</li>
<li>健康检查</li>
<li>键值存储</li>
<li>多数据中心支持</li>
</ul>
<p>以上便是我对cosnul的初步印象</p>
<a id="more"></a>
<h2 id="consul的架构"><a href="#consul的架构" class="headerlink" title="consul的架构"></a>consul的架构</h2><img title="consul架构图" alt="consul架构图" src="http://7xj5yf.com1.z0.glb.clouddn.com//images/20170308-01.png?imageView2/2/w/1000">
<p>这里简单说明consul几个方言：<br><strong>Agent</strong>：Consul集群中长时间运行的守护进程，以consul agent 命令开始启动. 在客户端和服务端模式下都可以运行，可以运行DNS或者HTTP接口， 它的主要作用是运行时检查和保持服务同步<br><strong>Client</strong>: 客户端, 无状态, 消耗极少的资源，将接口请求转发给局域网内的服务端集群<br><strong>server</strong>: 服务端, 保存配置信息, 高可用集群, 在局域网内与本地客户端通讯, 通过广域网与其他数据中心通讯. 每个数据中心的 server 数量推荐为 3 个或是 5 个<br><strong>Datacenter</strong>: 数据中心，多数据中心联合工作保证数据存储安全快捷<br><strong>Consensus</strong>：一致性协议使用的是Raft Protocol<br><strong>Gossip</strong>: consul是基于<a href="https://www.serf.io/" target="_blank" rel="external">serf</a>构建的, serf使用<a href="https://en.wikipedia.org/wiki/Gossip_protocol" target="_blank" rel="external">gossip protocol</a>来实现各种特性<br><strong>LAN Gossip</strong>: 包含了同一局域网所有内节点的gossip池<br><strong>WAN Gossip</strong>: 广域网中由Server组成的gossip池<br><strong>RPC</strong>： 远程过程调用</p>
<p>对于consul的详细理解，可以参考<a href="https://www.consul.io/docs/internals/architecture.html" target="_blank" rel="external">官方文档</a></p>
<p>总结为以下几点：</p>
<ul>
<li>如图所示，consul支持多数据中心</li>
<li>每个数据中心由server和client组成。server推荐由3～5个节点组成(基于可用性和性能的平衡),节点越多, 数据恢复一致周期越长，但是节点无数量限制, 横向拓展非常方便</li>
<li>所有节点基于gossip protocol加入集群。即一个数据中心就是一个gossip池，这么做有以下几个目的<ul>
<li>不需要给clent配置server地址，自动化服务发现（关于这点我还比较疑惑）</li>
<li>所有节点能做到相互故障感知，比传统的心跳机制更容易拓展到更大集群规模</li>
<li>gossip protocol做为一个消息层传递重大消息，例如lead election</li>
</ul>
</li>
<li>server节点也是wan_goosip池的成员，wan_gossip与lan_gossip的区别是wan_gossip做了高网络延迟的相关优化。wan_gossip的目的是让多个数据中心互相感知，同时添加一个新的数据中心就像添加一个节点到wan_gossip池中一样简单。也因为所有server再同一gossip池中，所以能轻松实现跨数据中心请求</li>
</ul>
<h2 id="与同类型的产品相比较，consul有哪些优势"><a href="#与同类型的产品相比较，consul有哪些优势" class="headerlink" title="与同类型的产品相比较，consul有哪些优势"></a>与同类型的产品相比较，consul有哪些优势</h2><h3 id="同类工具有以下这些"><a href="#同类工具有以下这些" class="headerlink" title="同类工具有以下这些"></a>同类工具有以下这些</h3><ul>
<li><a href="https://github.com/coreos/etcd" target="_blank" rel="external">etcd</a> Distributed reliable key-value store for the most critical data of a distributed system</li>
<li><a href="https://zookeeper.apache.org/" target="_blank" rel="external">zookeeper</a> Apache ZooKeeper is an effort to develop and maintain an open-source server which enables highly reliable distributed coordination.</li>
<li><a href="https://github.com/ha/doozerd" target="_blank" rel="external">Doozerd</a> A consistent distributed data store.</li>
</ul>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul>
<li>架构类似，都有服务节点，而这些服务节点的操作都要求达到节点的仲裁数（通常，节点的仲裁数遵循的是简单多数原则</li>
<li>强一致性，用于构建复杂的分布式系统</li>
</ul>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul>
<li>zooKeeper, etcd只提供一个原始的K/V值存储，并要求开发人员构建他们自己的系统来提供服务发现功能，cosnul提供服务发现功能</li>
<li>consul基于gossip的健康检查机制脱颖而出。ZooKeeper健康检查机制需要胖客户端，增加了工作量。etcd无健康检查功能</li>
<li>consul使用Raft算法来保证一致性, 比复杂的Paxos算法更直接. 相比较而言, zookeeper采用的是 Paxos, 而 etcd 使用的则是 Raft.</li>
<li>支持多数据中心，内外网的服务采用不同的端口进行监听。多数据中心集群可以避免单数据中心的单点故障, 而其部署则需要考虑网络延迟, 分片等情况等. zookeeper和etcd 均不提供多数据中心功能的支持.</li>
<li>支持 http 和 dns 协议接口. zookeeper的集成较为复杂, etcd 只支持 http 协议.</li>
<li>官方提供web管理界面, etcd 无此功能</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>consul和其他的工具来比，一方面提供了完整的工具集让降低了使用的工作量成本，另一方面在作为一个服务注册发现中心，自身有相对完善的机制，确实是中小型团队的推荐方案。</p>
<h3 id="更多关于工具的对比，参考下面"><a href="#更多关于工具的对比，参考下面" class="headerlink" title="更多关于工具的对比，参考下面"></a>更多关于工具的对比，参考下面</h3><p><a href="https://www.consul.io/intro/vs/zookeeper.html" target="_blank" rel="external">官网链接，主要看这个就够了</a><br><a href="https://my.oschina.net/u/2362111/blog/714503" target="_blank" rel="external">服务发现 zookeeper ,consul ,etcd 的一些比较(文中表格有参考价值)</a></p>
<h2 id="工具成熟程度"><a href="#工具成熟程度" class="headerlink" title="工具成熟程度"></a>工具成熟程度</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><h4 id="技术支撑"><a href="#技术支撑" class="headerlink" title="技术支撑"></a>技术支撑</h4><p><a href="https://www.hashicorp.com/?_ga=1.3867120.1947061243.1483414531" target="_blank" rel="external">HashiCorp</a>是一家企业级服务公司，公司致力于革命性的数据中心管理技术研发，让开发者通过一个工具就来构建完整的开发环境，提高开发效率。<a href="https://github.com/hashicorp" target="_blank" rel="external">这里</a>是他们的开源项目列表。<br>consul的技术支撑来自这里，目前github star已拥有8600+，算是比较优质的项目了</p>
<h4 id="国内使用情况"><a href="#国内使用情况" class="headerlink" title="国内使用情况"></a>国内使用情况</h4><p>consul是新东西，加上真的贯彻微服务架构的公可能没那么多，感觉好像没有太多人用，但是随便一搜总能搜到一些公司的技术分享用到了consul,比如<a href="http://www.infoq.com/cn/articles/service-discovery-at-stripe" target="_blank" rel="external">这个</a>，还有<a href="http://www.weidu8.net/wx/1004147150862858" target="_blank" rel="external">这个（挺潮的，ansible,consul,docker）</a>等等，大家都开始陆陆续续的踩坑了。现在看来也不至于新到没人用</p>
<h3 id="LTS"><a href="#LTS" class="headerlink" title="LTS"></a>LTS</h3><p>目前consul还处于0.x的状态，更新的速度并不快，简单来讲，这个工具还处于试水阶段。虽然是0.7（目前是0.7.5），但是发布过30个版本了。所以也不算是第一批入坑的人，这里作为一个已经使用过consul的“司机”，我觉得consul还是很好用的，目前没遇到过什么根本无法解决，或者是需要等更新才能解决的难题，可能我使用的功能相对简单，但是如果根据28原则来看，这些功能真的够了</p>
<p>目前没有看到相关的LTS计划，包括版本升级之类的，真的要升级，还是要多看release文档，多测试。</p>
<h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>这是目前我觉得最蛋疼的事情了，少有优质中文setup文档，这也是我刚开始接触consul的时候，感觉最痛苦的地方，下一篇会写consul入门文章。<br>学习的整体思路还是先看官网，注意消化理解，然后setup，遇到问题stackoverflow，最后提issue，这是目前我学习任何一门新的开源工具的实(tao)践(lu)。</p>
<h4 id="社区-1"><a href="#社区-1" class="headerlink" title="社区"></a>社区</h4><p>没有中文社区，可能能在go中文社区，docker中文社区等周边社区看到consul的影子，stackoverflow find by tags: consul 357, consul-template 31，作为新生一代的服务注册发现工具，社区方面还有待提高</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>社区方面可能是consul目前看来的缺点吧</p>
<h2 id="投入回报比"><a href="#投入回报比" class="headerlink" title="投入回报比"></a>投入回报比</h2><h3 id="使用成本"><a href="#使用成本" class="headerlink" title="使用成本"></a>使用成本</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>consul的安装很简单，下载然后解压就行了一个可执行文件搞定一切，<a href="https://www.consul.io/intro/getting-started/install.html" target="_blank" rel="external">安装文档</a></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>配置相对于安装要复杂一些，<a href="https://www.consul.io/docs/agent/options.html#reloadable-configuration" target="_blank" rel="external">这里</a>是完整的配置选项。个人觉得搭建consul集群可能首面临的问题是要规划一个集群环境，当然这个通过docker做也比较方便，关于配置，在下一篇文章中会重点描述</p>
<h3 id="学习成本"><a href="#学习成本" class="headerlink" title="学习成本"></a>学习成本</h3><p>consul的使用是比较简单的，就是简单的http，dns等API调用，非常方便，简单易用。</p>
<h3 id="长期-短期利益衡量"><a href="#长期-短期利益衡量" class="headerlink" title="长期/短期利益衡量"></a>长期/短期利益衡量</h3><p>这个主要就是看具体情景了，如果不是特别需要用到其他的服务注册发现工具，我觉得consul是一个不错的低成本选择。所以从短期利益来看，用这个很快，基本的功能很全，能分分钟造出来火箭；从长远角度看目前确实个人评估能力有限，暂时考虑不到。</p>
<h3 id="对当前工作流的影响"><a href="#对当前工作流的影响" class="headerlink" title="对当前工作流的影响"></a>对当前工作流的影响</h3><p>这个确实对开发主要影响体现在现在使用网络接口获取配置，跟原来使用配置文件的方式不太一样了。尤其是node程序，举个简单的例子，还是有很多人在用express的时候，启动文件和应用程序配置文件(app.js)没有分开，这样的话想要在启动主程序之前做一些初始化的工作，就得改点东西了，如果用临时的方式处理（把app.js包在初始化配置的会掉函数中），可能没那么优雅</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>以上对比的与consul相关的工具可能就是一个分布式kv系统，而consul提供的是一套fullstack的工具集合。从某种程度来说，consul提供的每一个小的工具，都是一个最佳实践，再有这些小的最佳实践组成一个健全的工具集合，暴露出简单的API给client。如果没有特别的需要必须使用其他工具（例如使用Hadoop的话可能会选择zookeeper），或者是没有那么极客必须要自己去构建一个完善的注册发现系统，consul确实一个非常不错的选择。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我的服务相互依赖，而且数量较多，需要有合适的机制解决繁杂的配置文件配置问题&lt;/li&gt;
&lt;li&gt;我要架设微服务架构，需要一个服务注册中心，需要一个较为完善的服务发现的机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面是我找到consul的原因&lt;/p&gt;
&lt;h2 id=&quot;什么是consul&quot;&gt;&lt;a href=&quot;#什么是consul&quot; class=&quot;headerlink&quot; title=&quot;什么是consul&quot;&gt;&lt;/a&gt;什么是consul&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.consul.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;的一句话总结里面有这么几个关键词: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;简化配置&lt;/li&gt;
&lt;li&gt;分布式(去中心化)&lt;/li&gt;
&lt;li&gt;高可用 &lt;/li&gt;
&lt;li&gt;多数据中心&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/hashicorp/consul&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;上，consul给出了这么几个关键特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;健康检查&lt;/li&gt;
&lt;li&gt;键值存储&lt;/li&gt;
&lt;li&gt;多数据中心支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上便是我对cosnul的初步印象&lt;/p&gt;
    
    </summary>
    
      <category term="consul" scheme="http://cocacola183.github.io/categories/consul/"/>
    
    
      <category term="consul" scheme="http://cocacola183.github.io/tags/consul/"/>
    
      <category term="微服务" scheme="http://cocacola183.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="注册发现" scheme="http://cocacola183.github.io/tags/%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>mongodb常见Q&amp;A整理</title>
    <link href="http://cocacola183.github.io/2017/03/07/mongo/mongodb%E5%B8%B8%E8%A7%81Q-A%E6%95%B4%E7%90%86/"/>
    <id>http://cocacola183.github.io/2017/03/07/mongo/mongodb常见Q-A整理/</id>
    <published>2017-03-07T02:34:28.000Z</published>
    <updated>2017-07-08T02:31:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="升级相关"><a href="#升级相关" class="headerlink" title="升级相关"></a>升级相关</h3><h4 id="cluster-upgrade-from-2-6-9-to-3-0-3-error-no-such-cmd-getUserCacheGeneration"><a href="#cluster-upgrade-from-2-6-9-to-3-0-3-error-no-such-cmd-getUserCacheGeneration" class="headerlink" title="cluster upgrade from 2.6.9 to 3.0.3 error: no such cmd: _getUserCacheGeneration"></a>cluster upgrade from 2.6.9 to 3.0.3 error: no such cmd: _getUserCacheGeneration</h4><p><a href="https://jira.mongodb.org/browse/SERVER-18651" target="_blank" rel="external">参考链接</a></p>
<p>这个问题是因为config-server在2.6.10中才加入这个api</p>
<hr>
<h4 id="configdb-error：-bad-serverID-set-in-setShardVersion-and-none"><a href="#configdb-error：-bad-serverID-set-in-setShardVersion-and-none" class="headerlink" title="configdb error： bad serverID set in setShardVersion and none"></a>configdb error： bad serverID set in setShardVersion and none</h4><p>升级3.0就能解决这个问题</p>
<hr>
<h4 id="2-6-primary-连接不上-3-0的seconary-errno-111-Connection-refused"><a href="#2-6-primary-连接不上-3-0的seconary-errno-111-Connection-refused" class="headerlink" title="2.6 primary 连接不上 3.0的seconary errno:111 Connection refused"></a>2.6 primary 连接不上 3.0的seconary errno:111 Connection refused</h4><p><a href="http://stackoverflow.com/questions/24899849/connection-refused-to-mongodb-errno-111" target="_blank" rel="external">参考链接</a></p>
<p>问题是mongodb没有正常关闭，删掉dbpath所有内容，重启mongodb，问题就解决了</p>
<hr>
<h4 id="mongorestore-no-reachable-servers"><a href="#mongorestore-no-reachable-servers" class="headerlink" title="mongorestore no reachable servers"></a>mongorestore no reachable servers</h4><p>这个问题是因为节点启动指定了rs name，但是却没有正确初始化replica set</p>
<a id="more"></a>
<hr>
<h4 id="replSet-info-Couldn’t-load-config-yet-Sleeping-20sec-and-will-try-again"><a href="#replSet-info-Couldn’t-load-config-yet-Sleeping-20sec-and-will-try-again" class="headerlink" title="replSet info Couldn’t load config yet. Sleeping 20sec and will try again"></a>replSet info Couldn’t load config yet. Sleeping 20sec and will try again</h4><p>干掉不停尝试的进程，重新启动</p>
<hr>
<h4 id="the-collection-lacks-a-unique-index-on-id"><a href="#the-collection-lacks-a-unique-index-on-id" class="headerlink" title="the collection lacks a unique index on _id"></a>the collection lacks a unique index on _id</h4><p>这个是我遇到的一个比较奇怪的问题，下面是我查到的一些信息</p>
<ul>
<li><a href="https://jira.mongodb.org/browse/SERVER-19998" target="_blank" rel="external">参考链接1</a></li>
<li><a href="https://docs.mongodb.com/master/tutorial/build-indexes-on-replica-sets/" target="_blank" rel="external">参考链接2</a></li>
<li><a href="https://docs.mongodb.com/master/release-notes/3.0-upgrade/#change-replica-set-storage-engine-to-wiredtiger" target="_blank" rel="external">参考链接3</a></li>
<li><a href="https://docs.mongodb.com/master/tutorial/change-replica-set-wiredtiger/" target="_blank" rel="external">参考链接4</a></li>
</ul>
<p>讨论里面说的是因为服务器突然宕机导致的数据问题，查了半天没有解决方案，最后我应该是直接删掉了这个实例的dbpath，然后用副本集的机制重新同步的数据</p>
<hr>
<h4 id="rename-replset-name（重命名副本集，亲测可用）"><a href="#rename-replset-name（重命名副本集，亲测可用）" class="headerlink" title="rename replset name（重命名副本集，亲测可用）"></a>rename replset name（重命名副本集，亲测可用）</h4><p><a href="http://stackoverflow.com/questions/11265997/can-i-change-the-name-of-my-replica-set-while-mongod-processes-are-running" target="_blank" rel="external">参考链接</a></p>
<hr>
<h4 id="MongoDB-Assertion-10334-BSONObj-size-1852142352-0x1073656E-is-invalid"><a href="#MongoDB-Assertion-10334-BSONObj-size-1852142352-0x1073656E-is-invalid" class="headerlink" title="MongoDB Assertion: 10334:BSONObj size: 1852142352 (0x1073656E) is invalid"></a>MongoDB Assertion: 10334:BSONObj size: 1852142352 (0x1073656E) is invalid</h4><p>这个问题有可能也是服务器突然关闭导致的（例如断电），解决方案如下</p>
<ul>
<li>清除oplog</li>
<li>repair数据库</li>
</ul>
<p><a href="http://8858975.blog.51cto.com/8848975/1785142" target="_blank" rel="external">参考链接</a></p>
<hr>
<h4 id="关闭3-0警告方法"><a href="#关闭3-0警告方法" class="headerlink" title="关闭3.0警告方法"></a>关闭3.0警告方法</h4><p><a href="https://docs.mongodb.com/manual/tutorial/transparent-huge-pages/" target="_blank" rel="external">参考链接1</a><br><a href="http://stackoverflow.com/questions/28911634/how-to-avoid-transparent-hugepage-defrag-warning-from-mongodb" target="_blank" rel="external">参考链接2</a></p>
<hr>
<h3 id="分片相关"><a href="#分片相关" class="headerlink" title="分片相关"></a>分片相关</h3><h4 id="chunk-move-failed"><a href="#chunk-move-failed" class="headerlink" title="chunk move failed"></a>chunk move failed</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">moveChunk failed to engage TO-shard in the data transfer: can&apos;t accept new chunks because  there are still 59 deletes from previous migration</div></pre></td></tr></table></figure>
<p>意思是说，当前正要去接受新chunk 的shard正在删除上一次数据迁移出的数据，不能接受新Chunk，于是本次迁移失败。这种log里显示的是warning，但有时候会发现shard的删除持续了十几天都没完成，查看日志，可以发现同一个chunk的删除在不断重复执行，重启所有无法接受新chunk的shard可以解决这个问题。<br>参考：<br><a href="http://stackoverflow.com/questions/26640861/movechunk-failed-to-engage-to-shard-in-the-data-transfer-cant-accept-new-chunk" target="_blank" rel="external">http://stackoverflow.com/questions/26640861/movechunk-failed-to-engage-to-shard-in-the-data-transfer-cant-accept-new-chunk</a><br>如果采用了balancer自动均衡，那么可以加上_waitForDelete参数，如：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="attr">"_id"</span> : <span class="string">"balancer"</span>, <span class="attr">"activeWindow"</span> : &#123; <span class="attr">"start"</span> : <span class="string">"12:00"</span>, <span class="attr">"stop"</span> : <span class="string">"19:30"</span> &#125;, <span class="attr">"stopped"</span> : <span class="literal">false</span>, <span class="attr">"_waitForDelete"</span> : <span class="literal">true</span> &#125;</div></pre></td></tr></table></figure></p>
<p>，这样就不会因delete堆积而导致后续migrate失败，当然，需要考虑到这里的阻塞是否会影响到程序正常运转，在实践中慎重采用使用waitForDelete，因为发现加上它之后迁移性能非常差，可能出现卡住十几个小时的情况，外界拿住了被迁移chunk的游标句柄，这时候删除不能执行，阻塞了后续其它迁移操作。<br>游标被打开而导致被迁移数据无法及时删除时的日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2015-03-07T10:21:20.118+0800 [RangeDeleter] rangeDeleter waiting for open cursors in: cswuyg_test.cswuyg_test, min: &#123; _id: -6665031702664277348 &#125;, max: &#123; _id: -6651575076051867067 &#125;, elapsedSecs: 6131244, cursors: [ 220477635588 ]</div></pre></td></tr></table></figure></p>
<p>这可能会卡住几十小时，甚至一直卡住，影响后续的moveChunk操作，导致数据不均衡。<br>解决方法还是：重启。</p>
<hr>
<h4 id="数据表已经分片，但是磁盘空间没有释放"><a href="#数据表已经分片，但是磁盘空间没有释放" class="headerlink" title="数据表已经分片，但是磁盘空间没有释放"></a>数据表已经分片，但是磁盘空间没有释放</h4><p>分片完成，数据chunk移动完成，其他分片已经分得当前分片的数据了，但是当前分片磁盘占用还是和之前一样大，问题在在于这个</p>
<blockquote>
<p>The file size, once allocated, does not go down – that space will be re-used by Mongo if your shard continues to grow. So if you truly want to get disk space back, repairDatabase is the way to go. You can take your secondary out of the replica set, run the repairDatabase, and bring it back into the replica set.<br>原因是磁盘空间一旦释放，mongo不会释放磁盘空间，以后来数据的时候会复用，如果需要立刻释放磁盘空间，使用repairDatabase或者是先删掉数据目录，利用副本集的机制重新导入一遍就能释放戴㷣磁盘空间</p>
</blockquote>
<hr>
<h4 id="大表分片卡住的问题"><a href="#大表分片卡住的问题" class="headerlink" title="大表分片卡住的问题"></a>大表分片卡住的问题</h4><p>大表分片的时候卡住不动，数据库读写都被阻塞<br><a href="https://jira.mongodb.org/browse/SERVER-10853" target="_blank" rel="external">https://jira.mongodb.org/browse/SERVER-10853</a><br>这个目前没有找到好的解决办法，一定要在业务量小的时候进行分片</p>
<hr>
<h3 id="索引相关"><a href="#索引相关" class="headerlink" title="索引相关"></a>索引相关</h3><h4 id="mongodb添加索引注意事项"><a href="#mongodb添加索引注意事项" class="headerlink" title="mongodb添加索引注意事项"></a>mongodb添加索引注意事项</h4><p>mongodb 添加索引<br>By default, MongoDB builds indexes in the foreground, which prevents all read and write operations to the database while the index builds. Also, no operation that requires a read or write lock on all databases (e.g. listDatabases) can occur during a foreground index build.<br>Background index construction allows read and write operations to continue while building the index.<br>默认<code>createIndex</code>会阻塞当前数据库所有的读写操作和另外一些依赖所有数据的的读写操作的命令（例如listdatabase），如果创建索引时候加上background，就能避免读写失败的问题</p>
<hr>
<h3 id="副本集相关"><a href="#副本集相关" class="headerlink" title="副本集相关"></a>副本集相关</h3><h4 id="replica-set-protocolVersion的问题"><a href="#replica-set-protocolVersion的问题" class="headerlink" title="replica set protocolVersion的问题"></a>replica set protocolVersion的问题</h4><p>[ReplicationExecutor] Error in heartbeat request to 127.0.0.1:27017; BadValue Unexpected field protocolVersion in replica set configuration<br>mongodb3.2之前replset的默认protocolVersion是0，3.2之后默认是1，所以当副本集中各个节点mongod版本不同时，要改为一致，修改的方法如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var cfg = rs.conf(); </div><div class="line">cfg.protocolVersion=1; </div><div class="line">rs.reconfig(cfg);</div></pre></td></tr></table></figure></p>
<hr>
<h4 id="修改副本集名称（需要停止数据库）"><a href="#修改副本集名称（需要停止数据库）" class="headerlink" title="修改副本集名称（需要停止数据库）"></a>修改副本集名称（需要停止数据库）</h4><ul>
<li>关闭副本集所有节点（注意要先关闭authentication）</li>
<li>不使用–replSet参数，启动所有节点</li>
<li><p>更新本地local数据库代码，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use local  </div><div class="line"><span class="keyword">var</span> doc = db.system.replset.findOne()  </div><div class="line">doc._id = <span class="string">'NewReplicaSetName'</span></div><div class="line">db.system.replset.save(doc)  </div><div class="line">db.system.replset.remove(&#123;<span class="attr">_id</span>:<span class="string">'OldReplicaSetName'</span>&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>再次关闭所有节点</p>
</li>
<li>修改配置文件中的replset name</li>
<li>启动所有节点</li>
</ul>
<hr>
<h4 id="No-common-protocol-found-when-add-shard-in-local-network"><a href="#No-common-protocol-found-when-add-shard-in-local-network" class="headerlink" title="No common protocol found when add shard in local network"></a>No common protocol found when add shard in local network</h4><p>副本集中同时存在mongo3.2和mongo3.0的时候就会出现这个错误，解决方案就是统一版本</p>
<hr>
<h4 id="副本集中主从节点数据量大小不同的原因"><a href="#副本集中主从节点数据量大小不同的原因" class="headerlink" title="副本集中主从节点数据量大小不同的原因"></a>副本集中主从节点数据量大小不同的原因</h4><p>Brief: Because of different amount of not reclaimed memory space on secondary and different padding factor on secondary and primary.</p>
<p>Long: It could be the case if you have long running primary node where some documents were deleted and inserted, and no compact operation was run. This space would no be reclaimed, and would be counted in dataSize, avgObjSize and storageSize. Secondary could be fully resynced from primary, but only operations from current oplog would be replayed. In this case secondary could have lower values for dataSize, avgObjSize and storageSize. If after that secondary is elected as primary, you could see described difference in sizes. In addition each server has it’s own padding factor, that is why you see difference in dataSize.</p>
<p>Concrete scenario could be different, but there are two main causes: amount of not reclaimed memory space and different padding factor.</p>
<p><a href="http://stackoverflow.com/questions/23509840/mongodb-replica-set-database-size-difference" target="_blank" rel="external">参考链接1</a><br><a href="https://dba.stackexchange.com/questions/96962/size-of-data-in-secondary-exceeded-primary-after-its-initial-resync-from-primary" target="_blank" rel="external">参考链接2</a></p>
<hr>
<h4 id="Fatal-assertion-15915-OplogOperationUnsupported-Applying-renameCollection-not-supported-in-initial-sync"><a href="#Fatal-assertion-15915-OplogOperationUnsupported-Applying-renameCollection-not-supported-in-initial-sync" class="headerlink" title="Fatal assertion 15915 OplogOperationUnsupported: Applying renameCollection not supported in initial sync"></a>Fatal assertion 15915 OplogOperationUnsupported: Applying renameCollection not supported in initial sync</h4><p>这个是因为副本集在initsync的过程中遇到了更改集合名称的操作，遇到这个操作，initsync会中断，手动重启即可</p>
<h3 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h3><h4 id="读写性能影响"><a href="#读写性能影响" class="headerlink" title="读写性能影响"></a>读写性能影响</h4><blockquote>
<p>Mongdump does not lock the db. It means other read and write operations will continue normally.<br>Actually, both mongodump and mongorestore are non-blocking. So if you want to mongodump mongorestore a db then its your responsibility to make sure that it is really a desired snapshot backup/restore. To do this, you must stop all other write operations while taking/restoring backups with mongodump/mongorestore. If you are running a sharded environment then its recommended you stop the balancer also.</p>
</blockquote>
<p>mongodump和mongorestore都不会阻塞数据库，但是会影响数据库读写性能</p>
<hr>
<h4 id="通过复制数据目录转移数据"><a href="#通过复制数据目录转移数据" class="headerlink" title="通过复制数据目录转移数据"></a>通过复制数据目录转移数据</h4><blockquote>
<p>注意，复制的时候一定要保证没有数据库正在使用这个数据目录，否则复制过去的数据目录是无法正常启动数据库的</p>
</blockquote>
<hr>
<h3 id="集群相关"><a href="#集群相关" class="headerlink" title="集群相关"></a>集群相关</h3><h4 id="不同的mongos节点读写数据不一致"><a href="#不同的mongos节点读写数据不一致" class="headerlink" title="不同的mongos节点读写数据不一致"></a>不同的mongos节点读写数据不一致</h4><p>这个问题有可能是使用了<code>moveprimary</code>命令导致的，看官网上的一段话:</p>
<blockquote>
<p>WARNING<br>If you use the movePrimary command to move un-sharded collections, you must either restart all mongos instances, or use the flushRouterConfig command on all mongos instances before reading or writing any data to any unsharded collections that were moved. This action ensures that the mongos is aware of the new shard for these collections.<br>If you do not update the mongos instances’ metadata cache after using movePrimary, the mongos may miss data on reads, and may not write data to the correct shard. To recover, you must manually intervene.</p>
</blockquote>
<p>意思是，<code>moveprimary</code>命令执行完成之后，如果没有重启所有mongos或者是没有手动<code>flushRouterConfig</code>，将会导致使用不同的mongos读写的数据分布在不同的分片上，这个不是必现的，但是如果某天真的出现了，就完蛋了，所以使用这个的时候一定要千万小心。</p>
<hr>
<h4 id="mongodb-lockpinger"><a href="#mongodb-lockpinger" class="headerlink" title="mongodb lockpinger"></a>mongodb lockpinger</h4><blockquote><p>There are distributed locks used in a sharded environment. The balancer takes a lock (only one migration is active at a time), the shards will take out meta data locks when doing splits also. Those live in the config.locks collection.</p>
<p>As for the lock pinger, the config.lockpings collection keeps track of the active components in the cluster, so it is an informational collection. The lock pinger is what populates this collection and you have pasted what looks to be the result of a successful ping.</p>
<p>Note: please do not use these collections for anything in your application or elsewhere. These collections (as noted on the linked pages) are considered internal only and can (and will) be changed/removed/updated without notice.</p>
<footer><strong>stackoverflow</strong><cite><a href="https://dba.stackexchange.com/questions/58272/what-is-lock-pinger-in-mongodb" target="_blank" rel="external">dba.stackexchange.com/questions/58272/what-is-lock-pinger-in-mongodb</a></cite></footer></blockquote>
<hr>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="Incompatible-to-update-capped-collection-after-upgrade-to-mongo3-2"><a href="#Incompatible-to-update-capped-collection-after-upgrade-to-mongo3-2" class="headerlink" title="Incompatible to update capped collection after upgrade to mongo3.2"></a>Incompatible to update capped collection after upgrade to mongo3.2</h4><p>这是我升级的时候发现的一个问题，副本集<code>init-sync</code>的时候出现问题了，提示<code>can not change the size of a document in a capped collection</code>，搜了一下发现了<a href="https://jira.mongodb.org/browse/SERVER-23981" target="_blank" rel="external">这个</a></p>
<blockquote><p>MongoDB 3.2 behaivor<br>MongoDB-3.2 added on a new condition check when update a capped collection, this is suitable for all storage engines. Which means user “Cannot change the size of a document in a capped collection”.</p>
<p>MongoDB 3.0 behaivor<br>In mongodb 3.0, only mmapv1 have limitation to update a capped collection, that is “objects in a capped ns cannot grow(no need have the same size with old document”.</p>
<footer><strong>mongo jira</strong><cite><a href="https://jira.mongodb.org/browse/SERVER-23981" target="_blank" rel="external">jira.mongodb.org/browse/SERVER-23981</a></cite></footer></blockquote>
<p>另外，有api可以让一个普通表转为固定大小表，却没有命令可以让固定大小表转为普通表，所以切换钱要小心，如果必须要转回去，可以参考<a href="https://stackoverflow.com/questions/3971689/undo-converttocapped-to-a-collection" target="_blank" rel="external">这个</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.createCollection(<span class="string">"norm_coll"</span>);</div><div class="line"><span class="keyword">var</span> cur = db.cap_col.find()</div><div class="line"><span class="keyword">while</span> (cur.hasNext()) &#123;obj = cur.next(); db.norm_coll.insert(obj);&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="更多错误总结文章"><a href="#更多错误总结文章" class="headerlink" title="更多错误总结文章"></a>更多错误总结文章</h3><ul>
<li><a href="http://www.lifeba.org/arch/mongodb_errors.html" target="_blank" rel="external">MongoDB错误和使用总结2013-02-16（持续更新）</a></li>
<li><a href="https://docs.mongodb.com/manual/faq/storage/" target="_blank" rel="external">FAQ: MongoDB Storage</a></li>
<li><a href="http://www.cnblogs.com/cswuyg/p/4355948.html" target="_blank" rel="external">MongoDB使用小结：一些不常见的经验分享</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;升级相关&quot;&gt;&lt;a href=&quot;#升级相关&quot; class=&quot;headerlink&quot; title=&quot;升级相关&quot;&gt;&lt;/a&gt;升级相关&lt;/h3&gt;&lt;h4 id=&quot;cluster-upgrade-from-2-6-9-to-3-0-3-error-no-such-cmd-getUserCacheGeneration&quot;&gt;&lt;a href=&quot;#cluster-upgrade-from-2-6-9-to-3-0-3-error-no-such-cmd-getUserCacheGeneration&quot; class=&quot;headerlink&quot; title=&quot;cluster upgrade from 2.6.9 to 3.0.3 error: no such cmd: _getUserCacheGeneration&quot;&gt;&lt;/a&gt;cluster upgrade from 2.6.9 to 3.0.3 error: no such cmd: _getUserCacheGeneration&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://jira.mongodb.org/browse/SERVER-18651&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个问题是因为config-server在2.6.10中才加入这个api&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;configdb-error：-bad-serverID-set-in-setShardVersion-and-none&quot;&gt;&lt;a href=&quot;#configdb-error：-bad-serverID-set-in-setShardVersion-and-none&quot; class=&quot;headerlink&quot; title=&quot;configdb error： bad serverID set in setShardVersion and none&quot;&gt;&lt;/a&gt;configdb error： bad serverID set in setShardVersion and none&lt;/h4&gt;&lt;p&gt;升级3.0就能解决这个问题&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;2-6-primary-连接不上-3-0的seconary-errno-111-Connection-refused&quot;&gt;&lt;a href=&quot;#2-6-primary-连接不上-3-0的seconary-errno-111-Connection-refused&quot; class=&quot;headerlink&quot; title=&quot;2.6 primary 连接不上 3.0的seconary errno:111 Connection refused&quot;&gt;&lt;/a&gt;2.6 primary 连接不上 3.0的seconary errno:111 Connection refused&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/24899849/connection-refused-to-mongodb-errno-111&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;问题是mongodb没有正常关闭，删掉dbpath所有内容，重启mongodb，问题就解决了&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;mongorestore-no-reachable-servers&quot;&gt;&lt;a href=&quot;#mongorestore-no-reachable-servers&quot; class=&quot;headerlink&quot; title=&quot;mongorestore no reachable servers&quot;&gt;&lt;/a&gt;mongorestore no reachable servers&lt;/h4&gt;&lt;p&gt;这个问题是因为节点启动指定了rs name，但是却没有正确初始化replica set&lt;/p&gt;
    
    </summary>
    
      <category term="mongodb" scheme="http://cocacola183.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://cocacola183.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>authSchema升级</title>
    <link href="http://cocacola183.github.io/2017/03/06/mongo/authSchema%E5%8D%87%E7%BA%A7/"/>
    <id>http://cocacola183.github.io/2017/03/06/mongo/authSchema升级/</id>
    <published>2017-03-06T09:38:16.000Z</published>
    <updated>2017-07-02T02:28:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这篇文章的前提是，mongo2.6.9升级mongo3.0.7的过程中，发现authSchema版本过低无法启动mongos。在这种情况下，有了这么一篇调研方案</p>
<h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><ul>
<li><a href="https://docs.mongodb.com/manual/release-notes/3.0-upgrade/" target="_blank" rel="external">Upgrade MongoDB to 3.0</a></li>
<li><a href="https://docs.mongodb.com/manual/release-notes/2.6-upgrade-authorization/" target="_blank" rel="external">Upgrade User Authorization Data to 2.6 Format</a></li>
</ul>
<p>这两篇文章关于authSchema版本的关键信息整理如下：</p>
<p>To override this behavior, run the upgrade command with the additional parameter upgradeShards:false. If you choose to override, you must run the upgrade procedure on the mongos first, and then run the procedure on the primary members of each shard.</p>
<p>If your existing MongoDB deployment is already running with authentication and authorization, your user data model authSchema must be at least version 3.</p>
<p>If you upgrade to 3.0 and have run authSchemaUpgrade, you cannot downgrade to 2.6 without disabling –auth or restoring a pre-upgrade backup, as authSchemaUpgrade discards the MONGODB-CR credentials used in 2.6. See Upgrade Existing MONGODB-CR Users to Use SCRAM-SHA-1.</p>
<a id="more"></a>
<h2 id="查看当前authSchema版本"><a href="#查看当前authSchema版本" class="headerlink" title="查看当前authSchema版本"></a>查看当前authSchema版本</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use admin</div><div class="line">db.system.version.find( &#123; <span class="attr">_id</span>: <span class="string">"authSchema"</span> &#125;)</div></pre></td></tr></table></figure>
<p>authSchema版本信息整理如下：</p>
<p>If you are currently using auth and you have schema version 2 or 3, the query returns the currentVersion of the existing authSchema.</p>
<p>If you do not currently have any users or you are using authSchema version 1, the query will not return any result.</p>
<p>If your authSchema version is less than 3 or the query does not return any results, see Upgrade User Authorization Data to 2.6 Format to upgrade the authSchema version before upgrading to MongoDB 3.0.</p>
<p>After upgrading MongoDB to 3.0 from 2.6, to use the new SCRAM-SHA-1 challenge-response mechanism if you have existing user data, you will need to upgrade the authentication schema a second time. This upgrades the MONGODB-CR user model to SCRAM-SHA-1 user model. See Upgrade to SCRAM-SHA-1 for details.</p>
<h2 id="升级authSchema"><a href="#升级authSchema" class="headerlink" title="升级authSchema"></a>升级authSchema</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不作用于所有分片（但会影响所有mongos）</span></div><div class="line">use admin</div><div class="line">db.getSiblingDB(<span class="string">"admin"</span>).runCommand(&#123;<span class="attr">authSchemaUpgrade</span>: <span class="number">1</span>, <span class="attr">upgradeShards</span>: <span class="literal">false</span> &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 作用于所有分片</span></div><div class="line">use admin</div><div class="line">db.getSiblingDB(<span class="string">"admin"</span>).runCommand(&#123;<span class="attr">authSchemaUpgrade</span>: <span class="number">1</span>&#125;);</div></pre></td></tr></table></figure>
<h2 id="降级authSchema"><a href="#降级authSchema" class="headerlink" title="降级authSchema"></a>降级authSchema</h2><p>官网上我没有查到相关的降级方案，只是提示说升级authSchema要慎重，因为降级比升级麻烦多了，但是没有说具体的降级方案，网上查了<a href="https://groups.google.com/forum/?utm_medium=email&amp;utm_source=footer#!msg/mongodb-user/NZNmFwTJXmo/j-QId789qp4J" target="_blank" rel="external">这篇文章</a>，也没有太大帮助，so，hack？</p>
<p><strong>hack一下</strong></p>
<blockquote>
<p>注意，这方法仅供娱乐，和临时解决问题，没有在生产环境测试过</p>
</blockquote>
<ul>
<li>删掉system.version中authSchema</li>
<li>删掉system.users中的内容</li>
<li>删掉system.new_users中的内容</li>
<li>将system.bachup_users中的用户存入system.user中</li>
</ul>
<p>降级完成之后，进行验证<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.system.version.find( &#123; _id: "authSchema" &#125;)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这篇文章的前提是，mongo2.6.9升级mongo3.0.7的过程中，发现authSchema版本过低无法启动mongos。在这种情况下，有了这么一篇调研方案&lt;/p&gt;
&lt;h2 id=&quot;知识准备&quot;&gt;&lt;a href=&quot;#知识准备&quot; class=&quot;headerlink&quot; title=&quot;知识准备&quot;&gt;&lt;/a&gt;知识准备&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/release-notes/3.0-upgrade/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Upgrade MongoDB to 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/release-notes/2.6-upgrade-authorization/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Upgrade User Authorization Data to 2.6 Format&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两篇文章关于authSchema版本的关键信息整理如下：&lt;/p&gt;
&lt;p&gt;To override this behavior, run the upgrade command with the additional parameter upgradeShards:false. If you choose to override, you must run the upgrade procedure on the mongos first, and then run the procedure on the primary members of each shard.&lt;/p&gt;
&lt;p&gt;If your existing MongoDB deployment is already running with authentication and authorization, your user data model authSchema must be at least version 3.&lt;/p&gt;
&lt;p&gt;If you upgrade to 3.0 and have run authSchemaUpgrade, you cannot downgrade to 2.6 without disabling –auth or restoring a pre-upgrade backup, as authSchemaUpgrade discards the MONGODB-CR credentials used in 2.6. See Upgrade Existing MONGODB-CR Users to Use SCRAM-SHA-1.&lt;/p&gt;
    
    </summary>
    
      <category term="mongodb" scheme="http://cocacola183.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://cocacola183.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>mongodb2.6.9热升级至3.0.7</title>
    <link href="http://cocacola183.github.io/2017/03/01/mongo/mongodb2-6-6%E5%8D%87%E7%BA%A7%E8%87%B33-0-7/"/>
    <id>http://cocacola183.github.io/2017/03/01/mongo/mongodb2-6-6升级至3-0-7/</id>
    <published>2017-03-01T11:06:10.000Z</published>
    <updated>2017-07-02T02:33:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>版本从2.6.6升级到3.0.7</p>
<h2 id="环境描述"><a href="#环境描述" class="headerlink" title="环境描述"></a>环境描述</h2><h3 id="服务器相关信息"><a href="#服务器相关信息" class="headerlink" title="服务器相关信息"></a>服务器相关信息</h3><p>系统版本: centos6.5<br>内核版本: 2.6.32-358.6.2.el6.x86_64</p>
<h3 id="数据库版本"><a href="#数据库版本" class="headerlink" title="数据库版本"></a>数据库版本</h3><p>升级前版本: 2.6.6<br>升级后版本: 3.0.7</p>
<h3 id="数据库集群模拟环境："><a href="#数据库集群模拟环境：" class="headerlink" title="数据库集群模拟环境："></a>数据库集群模拟环境：</h3><p>二个mongos<br>三个config<br>三个分片，每个分片是一个一主，一从，一仲裁的副本集</p>
<a id="more"></a>
<h2 id="为什么要升级"><a href="#为什么要升级" class="headerlink" title="为什么要升级"></a>为什么要升级</h2><p>一方面，写这篇文章的时候mongodb已经3.4了，3.4的mongo有很多新的优秀特性，升级是一个趋势，就是时间早晚的问题。另一方面更加直接，3.0支持wiredtiger，压缩性能相对mmapv1高很多，在数据量大的情况下，能帮助攻击节省很多成本。</p>
<h2 id="必备基础知识："><a href="#必备基础知识：" class="headerlink" title="必备基础知识："></a>必备基础知识：</h2><blockquote>
<p>因为是药升级到3.0.7，所有以下官方文档全部是3.0版本的</p>
</blockquote>
<p>相关官方文档：</p>
<ol>
<li><a href="https://docs.mongodb.com/v3.0/core/replication-introduction/" target="_blank" rel="external">官方文档：mongodb副本集</a></li>
<li><a href="https://docs.mongodb.com/v3.0/core/sharding-introduction/" target="_blank" rel="external">官方文档：mongodb分片集群</a></li>
<li><a href="https://docs.mongodb.com/v3.0/release-notes/3.0-upgrade/" target="_blank" rel="external">官方文档：升级mongodb至3.0</a></li>
<li><a href="https://docs.mongodb.com/v3.0/release-notes/3.0-downgrade/" target="_blank" rel="external">官方文档：mongo3.0降级方案</a></li>
</ol>
<p>这几篇文章一定要看明白，看仔细，尤其是最后一篇，前两个是帮助理解mongodb集群，最后一篇是详细的升级步骤</p>
<p>mongodb升级相关博客:</p>
<ul>
<li><a href="http://www.cleey.com/blog/single/id/750.html" target="_blank" rel="external">mongodb升级到3.0.2（2.6.9到3.0.2）</a> 除了官网之外，我主要参考了这个文章</li>
</ul>
<h2 id="升级演练方案"><a href="#升级演练方案" class="headerlink" title="升级演练方案"></a>升级演练方案</h2><p>就算明白升级的大概流程原理，也需要构建一个可用的测试环境测试一下。当然，这里比较简单的方案就是找一台环境相同的服务器，然后在这个机器上启动相应的mongodb进程，构建集群<br>如果没有可用的服务器，使用的是mac，也可以使用mac代替服务器（不推荐）<br>但是这两种方案都有一定的问题，因为是测试所以很有可能因为操作错误，需要干掉当前集群，重新起来一个然后再测试，或者是需要部署一个新版本的集群，这样前面两个方法问题就比较大，目前我采用的方式是使用docker搭建mongo集群，通过docker-compose可以一键启动和删除，非常方便，下面重点说下我使用的这个方法（当然，缺点是相对比较麻烦）</p>
<p><a href="https://github.com/CocaCola183/docker-centos-mongo" target="_blank" rel="external">项目地址</a></p>
<h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><p><code>docker version</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Client:</div><div class="line">  Version:      1.12.0</div><div class="line">  API version:  1.24</div><div class="line">  Go version:   go1.6.3</div><div class="line">  Git commit:   8eab29e</div><div class="line">  Built:        Thu Jul 28 21:15:28 2016</div><div class="line">  OS/Arch:      darwin/amd64</div><div class="line"></div><div class="line">Server:</div><div class="line">  Version:      1.12.0</div><div class="line">  API version:  1.24</div><div class="line">  Go version:   go1.6.3</div><div class="line">  Git commit:   8eab29e</div><div class="line">  Built:        Thu Jul 28 23:54:00 2016</div><div class="line">  OS/Arch:      linux/amd64</div></pre></td></tr></table></figure></p>
<p><code>docker-compose version</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker-compose version 1.8.0, build f3628c7</div><div class="line">docker-py version: 1.9.0</div><div class="line">CPython version: 2.7.9</div><div class="line">OpenSSL version: OpenSSL 1.0.2h  3 May 2016</div></pre></td></tr></table></figure></p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">├── LICENSE</div><div class="line">├── README.md</div><div class="line">├── attach.sh</div><div class="line">├── centos</div><div class="line">│   ├── centos-mongo-config                 <span class="comment"># 所有节点的配置文件</span></div><div class="line">│   ├── centos-mongo-data                   <span class="comment"># 所有节点的数据目录和日志目录，结构如config-1示例</span></div><div class="line">│   │   ├── config-1</div><div class="line">│   │   │   ├── data</div><div class="line">│   │   │   │   └── db</div><div class="line">│   │   │   └── <span class="built_in">log</span></div><div class="line">│   │   │       └── mongo.log</div><div class="line">│   ├── centos-mongo-shell                   <span class="comment"># 需要用到的脚本</span></div><div class="line">│   │   ├── startup-mongo-cluster-2.6.9.sh   <span class="comment"># 启动一个mongodb2.6.9的集群</span></div><div class="line">│   │   ├── startup-mongo-cluster.sh         <span class="comment"># 启动一个mognodb2.4的集群</span></div><div class="line">│   │   ├── upgrade_mongos.sh                <span class="comment"># 未完成，一键升级集群</span></div><div class="line">│   │   └── waitmongo.sh                     <span class="comment"># 脚本，等待mongodb实例启动（这个比较重要）</span></div><div class="line">│   └── mongo-source-rhel</div><div class="line">│       ├── config-backup                    <span class="comment"># config节点数据备份目录</span></div><div class="line">│       │   ├── config-1</div><div class="line">│       │   ├── config-2</div><div class="line">│       │   └── config-3</div><div class="line">│       ├── mongodb-2.6.9                    <span class="comment"># mongodb二进制文件夹</span></div><div class="line">│       └── mongodb-3.0.7                    <span class="comment"># mongodb二进制文件夹</span></div><div class="line">├── centos-mongo-image                       <span class="comment"># 运行mongodb的centos系统镜像</span></div><div class="line">│   ├── Dockerfile</div><div class="line">│   ├── build.sh</div><div class="line">│   └── waitmongo</div><div class="line">├── clear.sh                                 <span class="comment"># 一键清除mongodb集群，并且清楚本地缓存</span></div><div class="line">├── docker-compose.yml                       <span class="comment"># docker-compose配置文件</span></div><div class="line">├── run.sh                                   <span class="comment"># 启动脚本</span></div><div class="line">└── server                                   <span class="comment"># 测试链接使用搭建好的mongodb集群的小程序(热升级测试)</span></div><div class="line">    ├── index.js</div><div class="line">    ├── node_modules</div><div class="line">    │   ├── 此处略去一万行</div><div class="line">    └── package.json</div></pre></td></tr></table></figure>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./run.sh</div><div class="line">./attach.sh</div><div class="line">/opt/shell/startup-mongo-cluster-2.6.9.sh</div></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
</blockquote>
<p><code>startup-mongo-cluster-2.6.9.sh</code>可能会出现个别节点没有起来的情况，如果发现节点没有完全起来，可以在执行一次。因为为了快速搭建起来集群，这个方案中还有一些细节没有处理好，见谅。</p>
<h2 id="升级前注意事项"><a href="#升级前注意事项" class="headerlink" title="升级前注意事项"></a>升级前注意事项</h2><p><strong>降级限制</strong><br>一旦升级到mongo3.0，则mongo集群就不能再降级到2.6.8以下的版本了</p>
<p><strong>authSchema要求</strong><br>3.0支持的最低的authSchema版本是3，低于3mongos将无法启动。（<a href="https://docs.mongodb.com/v3.0/release-notes/2.6-upgrade-authorization/" target="_blank" rel="external">authSchema更新</a>）</p>
<p><strong>数据备份</strong><br>任何版本的升级前，一定要线备份<code>config server</code>中的数据</p>
<p><strong>升级时间选择</strong><br>最好在业务量比较小的时候进行升级，这个好处多多，大家都明白</p>
<h2 id="具体升级步骤"><a href="#具体升级步骤" class="headerlink" title="具体升级步骤"></a>具体升级步骤</h2><p>根据升级过程时间的消耗，建议将升级分为两个阶段（我们是这么处理的）。第一阶段：升级mongos和config，第二阶段：升级所有分片</p>
<h3 id="关闭负载均衡器"><a href="#关闭负载均衡器" class="headerlink" title="关闭负载均衡器"></a>关闭负载均衡器</h3><p>注意这里的负载均衡是mongo自身用于均衡各个分片数据量的，关闭负载均衡是为了阻止数据chunk移动，放置因为升级过程因为数据迁移带来问题</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 连接mongos</span></div><div class="line">/opt/mongo-source/mongodb-2.6.9/bin/mongo 127.0.0.1:9000/admin </div><div class="line"><span class="meta">#</span><span class="bash"> 关闭负载均衡</span></div><div class="line">sh.stopBalancer();</div></pre></td></tr></table></figure>
<blockquote>
<p>分析</p>
</blockquote>
<ul>
<li>安全性：这一步是比较安全的，没有安全隐患</li>
<li>会滚方案：很简单，<code>sh.setBalancerState(true)</code>，就能重新打开负载均衡器了</li>
<li>热升级保障： 这个操作不会影响在线业务</li>
</ul>
<h3 id="升级元数据，升级mongos-server"><a href="#升级元数据，升级mongos-server" class="headerlink" title="升级元数据，升级mongos server"></a>升级元数据，升级<code>mongos server</code></h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>升级元数据</li>
<li>升级mongos</li>
</ul>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>元数据升级目前我没有找到简单的方式去回滚，所以这个操作基本是不可逆的。但是，幸运的是，我在升级整个测试环境的mongo集群的时候，元数据升级成功，但是3.0的mognos却无法启动，当时测试环境出现故障，情急之下，使用2.6的mongos启动，成功了，也没有遇到什么其他问题，所以万一元数据升级之后出现问题，还是有临时方案解决的。</p>
<p>上面说到了升级元数据之后新的mongos无法启动，是因为遇到了这样的错误：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Failed to authenticate *** with mechanism MONGODB-CR: AuthenticationFailed AuthSchemaIncompatible Authorization data schema version 1 not support</div></pre></td></tr></table></figure></p>
<p>这个问题概括来说就是authSchema版本过低导致的，3.0.7支持的authSchema最低版本是3，但是当前版本是1，事实上，2.6.6默认的authSchema版本是3。出现这种问题，是因为我们的2.6.6版本的数据库是升级过来的。经过我的测试，2.4.3版本默认的authSchema版本就是1，所以这个历史遗留问题。如果你系统刚好也有这种情况，升级前最好先参考下<a href="/2017/03/06/authSchema升级/">这里</a>解决，以下是升级authSchema命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">use admin</div><div class="line"><span class="meta">#</span><span class="bash"> 升级authSchema</span></div><div class="line">db.getSiblingDB("admin").runCommand(&#123;authSchemaUpgrade: 1 &#125;)</div></pre></td></tr></table></figure>
<p>注意上面那个命令是比较危险的，原因有以下两点:</p>
<ul>
<li>authSchema升级之后如果对程序没有影响，那么无所谓，如果有影响，这个要降级到之前的版本，会比较麻烦<a href="/2017/03/06/authSchema升级/">参考这里</a></li>
<li>如果authSchema升级之后，再将整个集群升级至3.0，此时如果再想降级到2.6，那么启动mongos，mongod实例的时候，不能使用<code>--auth</code>参数，因为<code>authSchema</code>已经不兼容了（除非有所备份）</li>
<li>以上命令，作用域mongos的同时也会作用于所有的分片上，如果你不想在分片上也生效，那么可以这么做: <code>db.getSiblingDB(&quot;admin&quot;).runCommand({authSchemaUpgrade: 1, upgradeShards: false })</code></li>
</ul>
<h4 id="回滚方案"><a href="#回滚方案" class="headerlink" title="回滚方案"></a>回滚方案</h4><p>回滚<code>authSchema</code>参考<a href="">这里</a><br>回滚mongos版本，直接使用2.6的二进制文件启动mongos实例就可以了<br>回滚元数据，这个我没有做过，目前也没有好的方案，通常情况下，2.6元数据升至3.0是没有问题的（没有操作失误）</p>
<h4 id="热升级保障"><a href="#热升级保障" class="headerlink" title="热升级保障"></a>热升级保障</h4><p>如果下游有负载均衡，或者使用多个mongos实例连接方式，那么重启单个mongos实例带来的影响是可以容忍的（如果不是金融等业务的话）。如果是连接的单点mongos，重启肯定会带来一定影响，这个术语程序设计的问题了，不在这里讨论。<br>我们采用的方式是mongos之上搭建负载均衡器，选择在业务量小的时候做升级，没有太大问题</p>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 升级元数据</span></div><div class="line"><span class="meta">#</span><span class="bash"> tail -100 /mongodb/mongos-1/<span class="built_in">log</span>/mongo.log</span></div><div class="line"><span class="meta">#</span><span class="bash"> 日志中应该有类似 upgrade of config server to v6 successful 信息</span></div><div class="line">/opt/mongo-source/mongodb-3.0.7/bin/mongos -f /data/mongos-1/mongo.conf --upgrade </div><div class="line"><span class="meta">#</span><span class="bash"> 升级mongos</span></div><div class="line">/opt/mongo-source/mongodb-2.6.9/bin/mongo 127.0.0.1:9000/admin</div><div class="line">db.shutdownServer()</div><div class="line">/opt/mongo-source/mongodb-3.0.7/bin/mongos -f /data/mongos-1/mongo.conf</div></pre></td></tr></table></figure>
<p>这里只是升级了一个<code>mongos</code>，同理其他所有<code>mongos</code></p>
<h3 id="升级config-server"><a href="#升级config-server" class="headerlink" title="升级config server"></a>升级<code>config server</code></h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ul>
<li>备份<code>config server</code>的数据</li>
<li>关闭就版本节点</li>
<li>使用原来的配置打开新版本节点（不使用wiredtiger引擎）</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>升级之前一定要备份<code>config server</code>数据，因为<code>config server</code>的数据是保证整个集群正常运转的关键</li>
<li>升级<code>config server</code>的过程中，一定要保证只要处在升级过程中，都至少有一个<code>config server</code>是shutdown状态，同时至少有一个<code>config server</code>是up状态。因为，有一个shutdown的，就能保证所有<code>config server</code>数据都无法被修改，有一个up的，就能保证集群可用。这个非常关键，一旦<code>config server</code>数据不一致，集群将无法运转</li>
<li>3.0支持wiredtiger存储引擎，如果使用的话，<code>config server</code>的<code>dbpath</code>需要修改，不能使用原来的数据目录（这里其实推荐不要改变存储引擎，因为<code>config server</code>占用的磁盘空间相对来说很小，升级过程中我们没有修改存储引擎）</li>
</ul>
<h4 id="安全性-1"><a href="#安全性-1" class="headerlink" title="安全性"></a>安全性</h4><p>只要按照正确的步骤操作，安全性没有问题，因为升级并不会影响到数据</p>
<h4 id="热升级保障-1"><a href="#热升级保障-1" class="headerlink" title="热升级保障"></a>热升级保障</h4><p>只要保障有一个以上的<code>config server</code>正常运行，服务就没有问题</p>
<h4 id="回滚方案-1"><a href="#回滚方案-1" class="headerlink" title="回滚方案"></a>回滚方案</h4><p>使用原来的mongo二进制文件重新启动mongod服务即可</p>
<h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 导出数据</span></div><div class="line">/opt/mongo-source/mongodb-2.6.9/bin/mongodump --port 8000 -o /opt/mongo-source/config-backup/config-1</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 关闭config实例</span></div><div class="line">db.shutdownServer()</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 使用3.0的二进制文件启动config实例</span></div><div class="line">/opt/mongo-source/mongodb-3.0.7/bin/mongod -f /data/config-1/mongo3.conf</div></pre></td></tr></table></figure>
<h3 id="升级分片"><a href="#升级分片" class="headerlink" title="升级分片"></a>升级分片</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>因为每一个分片都是一个副本集，所有分片的升级就相当于是副本集的升级，升级副本集按照以下步骤:</p>
<ul>
<li>升级arbit</li>
<li>升级secondary</li>
<li>primary stepDown(stepDown会造成一定量的数据读写失败)</li>
<li>升级primary</li>
</ul>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><p>因为2.6升级至3.0还有一个特性地方在于如果使用wiredtiger，必须重新同步一次数据，因为原来的dbpath是无法使用的。所以我们的做法是先给副本集添加一个新的(3.0)secondary节点，让数据以副本集的内部机制复制一份到新添加的节点上，确认没有问题之后，再升级原来的副本集，最后干掉新添加的节点。</p>
<p>这里有两点需要注意：</p>
<ul>
<li>集群中允许存在不同版本的mongod实例</li>
<li>主从复制的过程会给主节点带来一定的压力，所以最好不要选择在业务繁忙的时候进行升级（最好在正常人都睡觉的时候，哈哈）</li>
<li>主从复制的时间相对较长，这也是上面为什么建议升级分为两个阶段的原因</li>
</ul>
<h4 id="安全性-2"><a href="#安全性-2" class="headerlink" title="安全性"></a>安全性</h4><p>数据分片的升级相对于<code>mongos, config</code>的升级安全性更高了，一个方面因为一个分片不会影响到整个集群，另外一个方面，完善的副本集机制为升级提供了保障。这步非常轻松（但是工作量非常大）</p>
<h4 id="回滚方案-2"><a href="#回滚方案-2" class="headerlink" title="回滚方案"></a>回滚方案</h4><p>副本集的升级和降级的步骤基本一样，可以参考升级的步骤降级</p>
<h4 id="热升级保障-2"><a href="#热升级保障-2" class="headerlink" title="热升级保障"></a>热升级保障</h4><p>这个又副本集的高可用机制保证，但是同步数据的时候是有可能导致系统负载过高的，这里最好多观察。</p>
<h4 id="升级代码示例"><a href="#升级代码示例" class="headerlink" title="升级代码示例"></a>升级代码示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 升级arbit</span></div><div class="line">/opt/mongo-source/mongodb-2.6.9/bin/mongo 127.0.0.1:6000/admin</div><div class="line">db.shutdownServer()</div><div class="line">/opt/mongo-source/mongodb-3.0.7/bin/mongod -f /data/mongod-1-3/mongo3.conf --storageEngine wiredTiger</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 升级secondary</span></div><div class="line">/opt/mongo-source/mongodb-2.6.9/bin/mongo 127.0.0.1:7001/admin</div><div class="line">db.shutdownServer()</div><div class="line">/opt/mongo-source/mongodb-3.0.7/bin/mongod -f /data/mongod-1-2/mongo3.conf --storageEngine wiredTiger</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 升级primary</span></div><div class="line">/opt/mongo-source/mongodb-2.6.9/bin/mongo 127.0.0.1:7000/admin</div><div class="line">rs.stepDown()</div><div class="line">db.shutdownServer()</div><div class="line">/opt/mongo-source/mongodb-3.0.7/bin/mongod -f /data/mongod-1-1/mongo3.conf --storageEngine wiredTiger</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 升级完成之后记得检查副本集和整个集群的状态 </span></div><div class="line">rs.status()</div><div class="line">sh.status()</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 更新authSchema，如果上面升级mongos的时候没有作用于整个集群</span></div><div class="line">db.getSiblingDB("admin").runCommand(&#123;authSchemaUpgrade: 1, upgradeShards: false &#125;)</div></pre></td></tr></table></figure>
<h3 id="打开负载均衡器"><a href="#打开负载均衡器" class="headerlink" title="打开负载均衡器"></a>打开负载均衡器</h3><p>最后，一定不要忘记打开负载均衡</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh.setBalancerState(true)</div></pre></td></tr></table></figure>
<h2 id="线上升级按照上述步骤遇到的问题"><a href="#线上升级按照上述步骤遇到的问题" class="headerlink" title="线上升级按照上述步骤遇到的问题"></a>线上升级按照上述步骤遇到的问题</h2><p>首先明确的是，上面的升级过程本身是没有问题的，然后，<strong>请一定要看看<a href="http://mt.sohu.com/20161017/n470478001.shtml" target="_blank" rel="external">这篇文章</a></strong></p>
<p>我遇到了一模一样的问题，mongodb进程的内存占用会持续走高，一直到跑满内存，然后被系统干掉。</p>
<p>我采用的任何限制内存的方案的结果都是一样的，因为只要是通过外部限制内存使用，要么根本没法限制，要么就会在到达限制的时候干掉mongodb进程。  </p>
<p>最开始的时候我们使用为机器添加内存的方式，最终的结果是将内存变为原来的8倍，依然会有这种问题</p>
<p>最终的解决方案是，重新替换为mmapv1寸处引擎，wiredtiger这名起起的却是生动，有令人期待的吞吐量和更高的数据压缩比，但是却难以控制（目前）</p>
<p>一下是我们解决问题过程中查阅的文档：</p>
<p>内存限制相关:</p>
<p><strong>cgroups方式</strong><br><a href="http://www.techpaste.com/2016/04/limit-mongodb-memory-usage/" target="_blank" rel="external">Easy Steps to Limit Mongodb Memory Usage</a>，照着这个实践过</p>
<p><strong>相关的讨论</strong><br><a href="http://dba.stackexchange.com/questions/86109/limit-the-ram-memory-usage-in-mongodb" target="_blank" rel="external">Limit the RAM memory usage in MongoDB</a><br><a href="http://stackoverflow.com/questions/6861184/is-there-any-option-to-limit-mongodb-memory-usage" target="_blank" rel="external">Is there any option to limit mongodb memory usage?</a><br><a href="https://groups.google.com/forum/#!topic/mongodb-user/JkalLE9B2DI" target="_blank" rel="external">Mongod start with memory limit</a><br><a href="http://stackoverflow.com/questions/4365224/mongodb-limit-memory" target="_blank" rel="external">MongoDB limit memory</a><br><a href="http://stackoverflow.com/questions/31502062/mongodb-wiredtiger-memory-usage-growing" target="_blank" rel="external">mongodb - wiredtiger memory usage growing</a><br><a href="http://stackoverflow.com/questions/14134109/mongodb-memory-usage-is-going-high-even-if-only-insertions-are-made" target="_blank" rel="external">mongodb memory usage is going high even if only insertions are made</a><br><a href="https://qnalist.com/questions/5264672/90-memory-usage-of-mongod" target="_blank" rel="external">Mongodb - &gt; 90% Memory Usage Of Mongod</a><br><a href="https://jira.mongodb.org/browse/SERVER-17456" target="_blank" rel="external">Mongodb 3.0 wiredTiger storage engine memory usage too high.</a><br><a href="http://dba.stackexchange.com/questions/58928/mongodb-memory-leak-or-big-collection" target="_blank" rel="external">mongodb memory leak or big collection?</a><br><a href="http://stackoverflow.com/questions/31502062/mongodb-wiredtiger-memory-usage-growing" target="_blank" rel="external">mongodb - wiredtiger memory usage growing</a><br><a href="https://docs.mongodb.com/manual/faq/storage/" target="_blank" rel="external">FAQ: MongoDB Storage</a><br><a href="http://stackoverflow.com/questions/4468873/how-to-release-the-caching-which-is-used-by-mongodb" target="_blank" rel="external">how to release the caching which is used by Mongodb?</a></p>
<p><strong>mongodb状态查询详解</strong><br><a href="http://m.blog.itpub.net/15498/viewspace-2076968/" target="_blank" rel="external">MongoDB状态查询db.serverStatus()详解</a><br><a href="http://blog.csdn.net/cug_jiang126com/article/details/42706827" target="_blank" rel="external">MongoDB状态查询详解：db.serverStatus()</a></p>
<p><strong>确定内存增长不是因为索引导致的</strong></p>
<ul>
<li><a href="http://stackoverflow.com/questions/2811299/mongodb-index-ram-relationship" target="_blank" rel="external">索引+数据量和内存占用的对应关系</a></li>
</ul>
<p><strong>查看wiredtiger cache size</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">status=db.serverStatus()</div><div class="line">memory = 0</div><div class="line">Object.keys(status.wiredTiger.cache).forEach(function(key)&#123;   </div><div class="line">  memory += status.wiredTiger.cache[key]</div><div class="line">&#125;)</div><div class="line">memory = memory / 2014 / 1024 / 1024</div></pre></td></tr></table></figure></p>
<h2 id="升级常见错误整理"><a href="#升级常见错误整理" class="headerlink" title="升级常见错误整理"></a>升级常见错误整理</h2><ul>
<li><a href="/2017/03/07/mongodb常见Q-A整理/">mongodb常见Q&amp;A整理</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;版本从2.6.6升级到3.0.7&lt;/p&gt;
&lt;h2 id=&quot;环境描述&quot;&gt;&lt;a href=&quot;#环境描述&quot; class=&quot;headerlink&quot; title=&quot;环境描述&quot;&gt;&lt;/a&gt;环境描述&lt;/h2&gt;&lt;h3 id=&quot;服务器相关信息&quot;&gt;&lt;a href=&quot;#服务器相关信息&quot; class=&quot;headerlink&quot; title=&quot;服务器相关信息&quot;&gt;&lt;/a&gt;服务器相关信息&lt;/h3&gt;&lt;p&gt;系统版本: centos6.5&lt;br&gt;内核版本: 2.6.32-358.6.2.el6.x86_64&lt;/p&gt;
&lt;h3 id=&quot;数据库版本&quot;&gt;&lt;a href=&quot;#数据库版本&quot; class=&quot;headerlink&quot; title=&quot;数据库版本&quot;&gt;&lt;/a&gt;数据库版本&lt;/h3&gt;&lt;p&gt;升级前版本: 2.6.6&lt;br&gt;升级后版本: 3.0.7&lt;/p&gt;
&lt;h3 id=&quot;数据库集群模拟环境：&quot;&gt;&lt;a href=&quot;#数据库集群模拟环境：&quot; class=&quot;headerlink&quot; title=&quot;数据库集群模拟环境：&quot;&gt;&lt;/a&gt;数据库集群模拟环境：&lt;/h3&gt;&lt;p&gt;二个mongos&lt;br&gt;三个config&lt;br&gt;三个分片，每个分片是一个一主，一从，一仲裁的副本集&lt;/p&gt;
    
    </summary>
    
      <category term="mongodb" scheme="http://cocacola183.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://cocacola183.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>ansible入门</title>
    <link href="http://cocacola183.github.io/2017/02/24/ansible/ansible%E5%85%A5%E9%97%A8/"/>
    <id>http://cocacola183.github.io/2017/02/24/ansible/ansible入门/</id>
    <published>2017-02-24T10:46:30.000Z</published>
    <updated>2017-07-02T02:28:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5分钟造火箭"><a href="#5分钟造火箭" class="headerlink" title="5分钟造火箭"></a>5分钟造火箭</h2><h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><ul>
<li>centos 6</li>
<li>python 2.6.6</li>
<li>一个控制节点，若干被管理节点</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y ansible</div></pre></td></tr></table></figure>
<p>这里安装的版本是2.2.1.0，当前官网上的最新release也是2.2.1.0所以我们选择这个版本<br>默认的配置文件: <code>/etc/ansible/ansible.cfg</code><br>默认的host文件: <code>/etc/ansible/hosts</code></p>
<h3 id="配置ssh免密登录"><a href="#配置ssh免密登录" class="headerlink" title="配置ssh免密登录"></a>配置ssh免密登录</h3><p>在真正使用前面，配置ssh免密登录是第一步<br><a href="https://ninjacn.com/2016-01-18-ansible-E5-85-A5-E9-97-A8" target="_blank" rel="external">这里</a>有篇博客分享了相关内容<br>执行的命令是下面这些<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ssh-keygen</div><div class="line">ssh-agent bash</div><div class="line">ssh-add ~/.ssh/id_rsa</div><div class="line">ssh-copy-id user@xxx.xxx.xxx.xxx</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意</p>
</blockquote>
<p>如果被管理节点的ssh启动端口不是22，分发key的命令这样：<code>ssh-copy-id &quot; -p 10022 xujw@xxx.xxx.xxx.xxx&quot;</code><br>详情参考<a href="http://www.cnblogs.com/xia/archive/2013/03/22/2975998.html" target="_blank" rel="external">这篇文章</a></p>
<p>而且，ansible默认ssh端口也需要被修改，<a href="http://www.cnblogs.com/xia/archive/2013/03/22/2975998.html" target="_blank" rel="external">看这里</a></p>
<h3 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ansible -m ping all</div></pre></td></tr></table></figure>
<p>有sudo权限的话，可以获取管理员权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ansible all -m ping -u user -b --become-user root</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="复杂一点的例子"><a href="#复杂一点的例子" class="headerlink" title="复杂一点的例子"></a>复杂一点的例子</h3><p>新建以下项目结构的文件夹<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">test</span></div><div class="line">├── hosts</div><div class="line">├── roles</div><div class="line">│   └── common</div><div class="line">│       └── tasks</div><div class="line">│           └── main.yml</div><div class="line">└── site.yml</div></pre></td></tr></table></figure></p>
<p>hosts<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[test]</div><div class="line">xxx.xxx.xxx.xxx</div></pre></td></tr></table></figure></p>
<p>site.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: test</div><div class="line">  roles:</div><div class="line">    - role: common</div></pre></td></tr></table></figure></p>
<p>roles/common/tasks/main.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- name: test connection</div><div class="line">  ping:</div></pre></td></tr></table></figure></p>
<p>执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ansible-playbook -i hosts site.yml</div></pre></td></tr></table></figure></p>
<p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">PLAY [test] ********************************************************************</div><div class="line"></div><div class="line">TASK [setup] *******************************************************************</div><div class="line">ok: [xxx.xxx.xxx.xxx]</div><div class="line"></div><div class="line">TASK [common : test connection] ************************************************</div><div class="line">ok: [xxx.xxx.xxx.xxx]</div><div class="line"></div><div class="line">PLAY RECAP *********************************************************************</div><div class="line">xxx.xxx.xxx.xxx             : ok=2    changed=0    unreachable=0    failed=0</div></pre></td></tr></table></figure></p>
<h3 id="更多优质例子分享"><a href="#更多优质例子分享" class="headerlink" title="更多优质例子分享"></a>更多优质例子分享</h3><p>建议在看这些例子之前，写歇会，看看下面的基础知识补充说明</p>
<ul>
<li><a href="https://github.com/ansible/ansible-examples" target="_blank" rel="external">examples</a>（官方的例子）</li>
<li><a href="https://github.com/leucos/ansible-tuto/tree/master/" target="_blank" rel="external">ansible-tuto</a>（开源朋友的例子，值得一看）</li>
</ul>
<h2 id="基础知识补充说明"><a href="#基础知识补充说明" class="headerlink" title="基础知识补充说明"></a>基础知识补充说明</h2><h3 id="ansible可执行命令"><a href="#ansible可执行命令" class="headerlink" title="ansible可执行命令"></a>ansible可执行命令</h3><p>安装完ansible后，发现ansible一共为我们提供了七个指令：ansible、ansible-doc、ansible-galaxy、ansible-lint、ansible-playbook、ansible-pull、ansible-vault 。命令详情请参考<a href="http://www.361way.com/ansible-framework/4393.html" target="_blank" rel="external">这篇博客</a></p>
<p>实际使用中用的比较多的是<code>ansible</code>和<code>ansible-playbook</code>这两个命令</p>
<p>1、ansible<br>ansible是指令核心部分，其主要用于执行ad-hoc命令，即单条命令。默认后面需要跟主机和选项部分，默认不指定模块时，使用的是command模块。如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ansible 192.168.0.102 -a <span class="string">'date'</span></div><div class="line">192.168.0.102 | success | rc=0 &gt;&gt;</div><div class="line">Tue May 12 22:57:24 CST 2015</div></pre></td></tr></table></figure></p>
<p>2、ansible-playbook<br>该指令是使用最多的指令，其通过读取playbook 文件后，执行相应的动作。</p>
<h3 id="ansible基本项目结构"><a href="#ansible基本项目结构" class="headerlink" title="ansible基本项目结构"></a>ansible基本项目结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">hosts                     # host配置文件</div><div class="line"></div><div class="line">group_vars/</div><div class="line">   group1                 # 组group1变量</div><div class="line">   group2                 # 组group2变量</div><div class="line">host_vars/</div><div class="line">   hostname1              # hostname1变量</div><div class="line">   hostname2              # hostname2变量</div><div class="line"></div><div class="line">library/                  # 目前我没有在项目中使用</div><div class="line">filter_plugins/           # 目前我没有在项目中使用</div><div class="line"></div><div class="line">site.yml                  # 主playbook，作用就是执行这个playbook将会完成当前项目所有的需要执行的任务</div><div class="line">webservers.yml            # 某个role的playbook</div><div class="line">dbservers.yml             # 某个role的playbook</div><div class="line"></div><div class="line">roles/</div><div class="line">    common/               # 这是一个名字是common的role</div><div class="line">        tasks/            #</div><div class="line">            main.yml      #  &lt;-- tasks file can include smaller files if warranted</div><div class="line">        handlers/         #</div><div class="line">            main.yml      #  &lt;-- handlers file</div><div class="line">        templates/        #  &lt;-- files for use with the template resource</div><div class="line">            ntp.conf.j2   #  &lt;------- templates end in .j2</div><div class="line">        files/            #</div><div class="line">            bar.txt       #  &lt;-- files for use with the copy resource</div><div class="line">            foo.sh        #  &lt;-- script files for use with the script resource</div><div class="line">        vars/             #</div><div class="line">            main.yml      #  &lt;-- variables associated with this role</div><div class="line">        defaults/         #</div><div class="line">            main.yml      #  &lt;-- default lower priority variables for this role</div><div class="line">        meta/             #</div><div class="line">            main.yml      #  &lt;-- role dependencies</div><div class="line">        library/          # roles can also include custom modules</div><div class="line">        lookup_plugins/   # or other types of plugins, like lookup in this case</div></pre></td></tr></table></figure>
<h3 id="inventory概念"><a href="#inventory概念" class="headerlink" title="inventory概念"></a>inventory概念</h3><p>简单来说就是host配置，host文件里面至少包含所有服务器的ip（或域名）信息<br>这里面有几个概念：</p>
<ul>
<li>vars 全局变量</li>
<li>group host组</li>
<li>group_vars host变量</li>
<li>host 被管理服务器</li>
<li>host_vars 单个服务器变量</li>
</ul>
<p>一个最简单的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[group_name]</div><div class="line">xxx.xxx.xxx.xxx</div></pre></td></tr></table></figure></p>
<h3 id="role概念"><a href="#role概念" class="headerlink" title="role概念"></a>role概念</h3><p>理解参考剧本里的角色，playbook是剧本，role是执行剧本的角色，role是一系列任务的集合，role通过配置执行一系列任务，实现特定的功能。<br>github上有很多开源的role，帮你实现一些特定功能，例如一键启动mongodb集群，一键启动consul集群等等</p>
<p>ansible给出了一个role的best practice，使用这个命令可以新建一个role: <code>ansible-galaxy init common --offline</code><br>重要文件夹介绍：</p>
<ul>
<li>tasks 里面放的是role的playbook，会默认执行main.yml，最佳实践是功能拆开，在main.yml中引入</li>
<li>templates 这个放的是文件模板，例如nginx的配置模板，可以根据相关信息生成配置文件</li>
<li>defaluts 这里main.yml是role相关的默认配置</li>
<li>files 这里面放的是静态文件，例如要复制到远程服务器的工具安装包</li>
</ul>
<p>总结来说，ansible项目就是通过一定的目录结构（经过实践检验的最佳实践），通过playbook定义任务，通过host相关文件进行ip配置，最后由ansible统一执行，实现自动化运维的功能</p>
<h2 id="ansible高质量入门资料分享"><a href="#ansible高质量入门资料分享" class="headerlink" title="ansible高质量入门资料分享"></a>ansible高质量入门资料分享</h2><h3 id="入门简介"><a href="#入门简介" class="headerlink" title="入门简介"></a>入门简介</h3><ul>
<li><a href="http://www.jianshu.com/p/f0cf027225df" target="_blank" rel="external">ansible超详细使用指南</a> 确实详细，看了这篇，不需要看我的了</li>
<li><a href="http://blog.waterstrong.me/ansible-basic/" target="_blank" rel="external">入门博客1</a></li>
<li><a href="http://sapser.github.io/ansible/2014/07/21/ansible-conditionals" target="_blank" rel="external">入门博客2</a></li>
</ul>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul>
<li><a href="http://ansible-tran.readthedocs.io/en/latest/" target="_blank" rel="external">官方文档</a>（中文）</li>
<li><a href="http://docs.ansible.com/ansible/index.html" target="_blank" rel="external">官方文档</a>（尽量不要看中文版的，不全面，官方文档很重要，基本有一切新手问题的答案）</li>
</ul>
<h3 id="原理语法"><a href="#原理语法" class="headerlink" title="原理语法"></a>原理语法</h3><ul>
<li><a href="http://www.361way.com/ansible-framework/4393.html" target="_blank" rel="external">ansible小结（二）ansible架构</a></li>
<li><a href="http://www.10tiao.com/html/385/201612/2651696635/1.html" target="_blank" rel="external">ansible原理2</a></li>
<li><a href="http://chuansong.me/n/775508751235" target="_blank" rel="external">jinja2语法</a> 之前没接触过py的我刚开始对这个语法不算太能接受（templates语法）</li>
</ul>
<h2 id="使用经验分享"><a href="#使用经验分享" class="headerlink" title="使用经验分享"></a>使用经验分享</h2><p>目前处于技术准备阶段，也就是在方案确定之后，需要验证是否确实可行，如果可行，需要构建一个可用的原型。</p>
<h3 id="目前使用ansbile主要做两个方面的事情："><a href="#目前使用ansbile主要做两个方面的事情：" class="headerlink" title="目前使用ansbile主要做两个方面的事情："></a>目前使用ansbile主要做两个方面的事情：</h3><ul>
<li>基础工具安装</li>
<li>服务部署</li>
</ul>
<h3 id="目前使用ansbile过程中遇到的一些坑"><a href="#目前使用ansbile过程中遇到的一些坑" class="headerlink" title="目前使用ansbile过程中遇到的一些坑"></a>目前使用ansbile过程中遇到的一些坑</h3><ul>
<li>hosts文件中，group列表，当在列表中的服务器上执行命令的时候，所有服务器是并行的，你没有简单的方法去控制执行的先后顺序（例如，按照列表先后顺序执行命令），所以在方案设计的时候，尽量不要让自己处在这种情况下</li>
<li>hosts文件配置命名不要用中划线，要用下划线</li>
<li>hosts文件中各个group的hostname最好不要重复，否则有可能导致意想不到的问题</li>
<li>hosts文件中各个group的hostname最好写成ip，如果配置可访问域名也可以，最好不要写成最终无法解析成ip的字符串，因为这个信息比较重要</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;5分钟造火箭&quot;&gt;&lt;a href=&quot;#5分钟造火箭&quot; class=&quot;headerlink&quot; title=&quot;5分钟造火箭&quot;&gt;&lt;/a&gt;5分钟造火箭&lt;/h2&gt;&lt;h3 id=&quot;环境说明&quot;&gt;&lt;a href=&quot;#环境说明&quot; class=&quot;headerlink&quot; title=&quot;环境说明&quot;&gt;&lt;/a&gt;环境说明&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;centos 6&lt;/li&gt;
&lt;li&gt;python 2.6.6&lt;/li&gt;
&lt;li&gt;一个控制节点，若干被管理节点&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;yum install -y ansible&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里安装的版本是2.2.1.0，当前官网上的最新release也是2.2.1.0所以我们选择这个版本&lt;br&gt;默认的配置文件: &lt;code&gt;/etc/ansible/ansible.cfg&lt;/code&gt;&lt;br&gt;默认的host文件: &lt;code&gt;/etc/ansible/hosts&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置ssh免密登录&quot;&gt;&lt;a href=&quot;#配置ssh免密登录&quot; class=&quot;headerlink&quot; title=&quot;配置ssh免密登录&quot;&gt;&lt;/a&gt;配置ssh免密登录&lt;/h3&gt;&lt;p&gt;在真正使用前面，配置ssh免密登录是第一步&lt;br&gt;&lt;a href=&quot;https://ninjacn.com/2016-01-18-ansible-E5-85-A5-E9-97-A8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;有篇博客分享了相关内容&lt;br&gt;执行的命令是下面这些&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ssh-keygen&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ssh-agent bash&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ssh-add ~/.ssh/id_rsa&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ssh-copy-id user@xxx.xxx.xxx.xxx&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果被管理节点的ssh启动端口不是22，分发key的命令这样：&lt;code&gt;ssh-copy-id &amp;quot; -p 10022 xujw@xxx.xxx.xxx.xxx&amp;quot;&lt;/code&gt;&lt;br&gt;详情参考&lt;a href=&quot;http://www.cnblogs.com/xia/archive/2013/03/22/2975998.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而且，ansible默认ssh端口也需要被修改，&lt;a href=&quot;http://www.cnblogs.com/xia/archive/2013/03/22/2975998.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;看这里&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;开始测试&quot;&gt;&lt;a href=&quot;#开始测试&quot; class=&quot;headerlink&quot; title=&quot;开始测试&quot;&gt;&lt;/a&gt;开始测试&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ansible -m ping all&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有sudo权限的话，可以获取管理员权限&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ansible all -m ping -u user -b --become-user root&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Automation" scheme="http://cocacola183.github.io/categories/Automation/"/>
    
    
      <category term="ansible" scheme="http://cocacola183.github.io/tags/ansible/"/>
    
      <category term="devops" scheme="http://cocacola183.github.io/tags/devops/"/>
    
      <category term="automation" scheme="http://cocacola183.github.io/tags/automation/"/>
    
  </entry>
  
  <entry>
    <title>ansible调研</title>
    <link href="http://cocacola183.github.io/2017/02/21/ansible/ansible%E8%B0%83%E7%A0%94/"/>
    <id>http://cocacola183.github.io/2017/02/21/ansible/ansible调研/</id>
    <published>2017-02-20T23:57:33.000Z</published>
    <updated>2017-07-02T02:28:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自动化运维工具"><a href="#自动化运维工具" class="headerlink" title="自动化运维工具"></a>自动化运维工具</h2><p>把运维人员常做的大量的重复的操作，通过一个工具很方便的去做，而运维人员只需要为这种工具提供必不可少的配置。这种工具就是自动化运维工具。（完全是个人理解）</p>
<h2 id="什么是ansible"><a href="#什么是ansible" class="headerlink" title="什么是ansible"></a>什么是ansible</h2><p>ansbile是一个自动化运维工具，它可以帮助部署应用，管理系统，简化操作，构建devops基础设施。</p>
<p>上面是官方的解释，不够具体，通过两周的使用，我自己的感觉最能发挥ansible价值的场景（任务），满足这样的特点：重复而且大量</p>
<p>首先是重复，借助ansible完成的任务一定是在某个层面（直观点的层面）是重复的，不然使用这个工具没有任何意义；其次是大量，这个比较能体现ansible轻便的优势</p>
<a id="more"></a>
<h2 id="为什么使用ansible"><a href="#为什么使用ansible" class="headerlink" title="为什么使用ansible"></a>为什么使用ansible</h2><h3 id="主流自动化运维工具对比调研"><a href="#主流自动化运维工具对比调研" class="headerlink" title="主流自动化运维工具对比调研"></a>主流自动化运维工具对比调研</h3><table>
<thead>
<tr>
<th>工具</th>
<th>语言</th>
<th>架构</th>
<th>协议</th>
<th>学习曲线</th>
</tr>
</thead>
<tbody>
<tr>
<td>puppet</td>
<td>ruby</td>
<td>c/s</td>
<td>http</td>
<td>上手难</td>
</tr>
<tr>
<td>chef</td>
<td>ruby</td>
<td>c/s</td>
<td>http</td>
<td>上手难</td>
</tr>
<tr>
<td>saltstack</td>
<td>python</td>
<td>c/s</td>
<td>ssh/zmp</td>
<td>难度低于上面两个，新技术</td>
</tr>
<tr>
<td>ansible</td>
<td>python</td>
<td>no client</td>
<td>ssh</td>
<td>上手容易</td>
</tr>
</tbody>
</table>
<p>Puppet和Chef会吸引广大开发人员和注重开发的公司，而Salt和Ansible极其适合系统管理员的要求。Ansible的简洁界面和可用性非常迎合系统管理员的想法;而在拥有许多Linux和Unix系统的公司，Ansible运行起来一开始就快速又轻松。</p>
<p>Salt是四款工具中最漂亮最稳健的;与Ansible一样，它也会博得系统管理员的芳心。Salt拥有高扩展性和强大功能，唯一的软肋就是Web用户界面，配置文件相对ansible复杂一些</p>
<p>Puppet是这四款工具中最成熟的，从可用性的角度来看恐怕也最容易上手，不过竭力建议你对Ruby要有深入了解。Puppet不如Ansible或Salt来得精简，配置起来有时会变得错综复杂。对异构环境来说，Puppet是最稳妥的选择，但是你可能会发觉Ansible或Salt比较适合更庞大或更一致的基础设施。</p>
<p>Chef拥有稳定的、精心设计的布局，虽然它在原始功能方面远未达到Puppet的水平，但这是款功能非常强大的解决方案。要是管理员缺乏丰富的编程经验，Chef学起来可能最困难，但它也许最适合注重开发的管理员和开发部门。 </p>
<p>总结来说，ansbile相对于其他自动化运维工具而言，有以下优势：</p>
<ul>
<li>简单，上手快</li>
<li>安全性好</li>
<li>无需client，配置文件容易理解（相对于salt）</li>
</ul>
<h3 id="ansible使用相关信息调研"><a href="#ansible使用相关信息调研" class="headerlink" title="ansible使用相关信息调研"></a>ansible使用相关信息调研</h3><p><strong>环境依赖</strong><br>windows server不支持，linux server只需要安装了py2.6+ 和 openssl</p>
<p><strong>升级机制</strong><br>推荐使用一个较新的稳定版，目前是2.2，升级多少都会因为api变动需要调整脚本<br>新的技术可能都会面临一个版本快速迭代的问题，不过目前ansible已经到了2.0（被红帽收购），应该算相对来说比较稳定了，不会频繁出现bug；另一方面，至于有没有非常完善的升级机制，官网上面只有一个2.2的安装方法。<br>这里确实存在一些问题，但是考虑到工具本身比较简单，升级带来的最大的问题就是之前使用的某些api会失效，这个可以通过不使用deprecated的api来尽量避免。<br>其实类似这种工具，应该尽量降低升级更新的频率，如果当前版本的功能，性能能够满足需求，可以考虑不升级。这也是为什么我们使用的Linux系统版本和node版本都比较低的原因。</p>
<p><strong>学习成本</strong><br>四大自动化运维工具中，ansible是最低的，不需要学习新的编程语言（以后某些复杂场景可能需要py），只需要了解playbook语法（比较简单）。<br>这个观点是调研的时候得出的结论，事实上经过两周的使用，现在看来还是有py编程经验会更好一些，尤其是使用过jinja2，因为配置文件模板使用的这个语法，上来不明白得到话，非常难受。</p>
<p><strong>社区活跃情况</strong><br>官方文档，初级问题在官方文档上基本都能找到答案<br>github开源项目（学习写法，因为各自公司往往有自己特定的需求，而开源项目大部分都会写成通用的，所以能直接用的不多。举个例子，开源项目中安装工具大都会使用yum，或者通过官方下载链接下载等网络途径去安装，然而我们有特定需求就是需要在不能访问公网的情况下安装）<br>google常见问题已经基本上都能找到答案（两周使用体验）</p>
<p><strong>对当前工作流的影响</strong><br>开发： 无<br>测试： 无<br>发布： 可以改变手动发布的现状，针对需求实现自动化新功能发布<br>这里可以说ansible对开发测试的工作流程没有什么影响，因为针对工作流，ansible能发挥作用的地方可能就是发布。这里也可以看出ansible是一个负面影响范围很小的工具，你可以在其他开发者意识不到的情况下使用它，这一点在技术选型上是比较重要的。当然，这跟ansible本身就特别简单可能也有关系（相比salt，可能我就需要运维同学配合在初始化新机器的时候，帮忙准备一下salt被管理节点所需要的环境）</p>
<h3 id="ansible原理"><a href="#ansible原理" class="headerlink" title="ansible原理"></a>ansible原理</h3><img title="ansible架构图" alt="ansible架构图" src="http://7xj5yf.com1.z0.glb.clouddn.com//images/20170223-02.png?imageView2/2/w/1000">
<img title="ansible工作流程" alt="ansible工作流程" src="http://7xj5yf.com1.z0.glb.clouddn.com//images/20170223-01.png?imageView2/2/w/1000">
<p>简单来说，ansible工作原来就是通过ssh将要执行的命令（python）发送到远程服务器，目标服务器执行这些命令，实现自动化运维的操作<br>这一点对于我们目前的情况来说，是能基本满足需求的</p>
<h3 id="ansible的不足"><a href="#ansible的不足" class="headerlink" title="ansible的不足"></a>ansible的不足</h3><p>命令传输通过ssh，是没有salt快的（zmq），如果对命令执行的速度有比较严格的要求，不能使用ansible，体验过速度确实偏慢（目前）</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综合以上调研情况，ansible是一个成本最低，而且又能满足基本自动化运维需求的选择。所以最终我们选择了ansible</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自动化运维工具&quot;&gt;&lt;a href=&quot;#自动化运维工具&quot; class=&quot;headerlink&quot; title=&quot;自动化运维工具&quot;&gt;&lt;/a&gt;自动化运维工具&lt;/h2&gt;&lt;p&gt;把运维人员常做的大量的重复的操作，通过一个工具很方便的去做，而运维人员只需要为这种工具提供必不可少的配置。这种工具就是自动化运维工具。（完全是个人理解）&lt;/p&gt;
&lt;h2 id=&quot;什么是ansible&quot;&gt;&lt;a href=&quot;#什么是ansible&quot; class=&quot;headerlink&quot; title=&quot;什么是ansible&quot;&gt;&lt;/a&gt;什么是ansible&lt;/h2&gt;&lt;p&gt;ansbile是一个自动化运维工具，它可以帮助部署应用，管理系统，简化操作，构建devops基础设施。&lt;/p&gt;
&lt;p&gt;上面是官方的解释，不够具体，通过两周的使用，我自己的感觉最能发挥ansible价值的场景（任务），满足这样的特点：重复而且大量&lt;/p&gt;
&lt;p&gt;首先是重复，借助ansible完成的任务一定是在某个层面（直观点的层面）是重复的，不然使用这个工具没有任何意义；其次是大量，这个比较能体现ansible轻便的优势&lt;/p&gt;
    
    </summary>
    
      <category term="Automation" scheme="http://cocacola183.github.io/categories/Automation/"/>
    
    
      <category term="ansible" scheme="http://cocacola183.github.io/tags/ansible/"/>
    
      <category term="devops" scheme="http://cocacola183.github.io/tags/devops/"/>
    
      <category term="automation" scheme="http://cocacola183.github.io/tags/automation/"/>
    
      <category term="sre" scheme="http://cocacola183.github.io/tags/sre/"/>
    
  </entry>
  
  <entry>
    <title>冰雪大世界-黑龙江·哈尔滨</title>
    <link href="http://cocacola183.github.io/2017/01/10/travel/%E5%86%B0%E9%9B%AA%E5%A4%A7%E4%B8%96%E7%95%8C-%E9%BB%91%E9%BE%99%E6%B1%9F%C2%B7%E5%93%88%E5%B0%94%E6%BB%A8/"/>
    <id>http://cocacola183.github.io/2017/01/10/travel/冰雪大世界-黑龙江·哈尔滨/</id>
    <published>2017-01-10T14:59:50.000Z</published>
    <updated>2017-07-02T02:23:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考行程"><a href="#参考行程" class="headerlink" title="参考行程"></a>参考行程</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>如果和我有一样有以下相同出游前提</p>
<ul>
<li>利用周末出游，出发地点是北京</li>
</ul>
<p>那么这个行程可能有一定的参考价值</p>
<h3 id="出游行程"><a href="#出游行程" class="headerlink" title="出游行程"></a>出游行程</h3><p><code>2017-01-06</code><br>中午从北京出发坐动车，晚上到达哈尔滨市<br>在距离松花江较近的7天酒店住下，普通周末大床房250左右（听出租车司机说使用铂涛旅行能再便宜50多元）</p>
<p><code>2017-01-07</code><br>上午游玩松花江，坐索道<br>中午吃完饭，打车去冰雪大世界<br>晚7点出门，坐公交车直达中央大街<br>晚9点回去旅店</p>
<p><code>2017-01-08</code><br>上午参观圣索非亚教堂，然后继续游玩中央大街<br>中午马迭尔西餐厅吃午饭<br>下午稍作休息赶往机场<br>晚上八点登机，10点返回北京</p>
<h3 id="出行消费（双人）"><a href="#出行消费（双人）" class="headerlink" title="出行消费（双人）"></a>出行消费（双人）</h3><p>双人来回路费 2000<br>住宿 500<br>冰雪大世界门票 660<br>其他 1000（主要是吃东西的消费）</p>
<h3 id="保暖措施"><a href="#保暖措施" class="headerlink" title="保暖措施"></a>保暖措施</h3><ul>
<li>帽子必须</li>
<li>手套必须</li>
<li>厚衣服（外套裤子不提）</li>
<li>厚鞋子（根据情况，我当时就穿的一双厚点的板鞋玩了一天，怕冷的还是要穿厚点的鞋子）</li>
</ul>
<h3 id="游玩建议-重要"><a href="#游玩建议-重要" class="headerlink" title="游玩建议(重要)"></a>游玩建议(重要)</h3><ul>
<li>一定要带一个抗冻的手机！或者给手机来点保暖措施（很多手机低温下电量会迅速减少，vivo和小米亲测10分钟用完满格电）</li>
<li>进了冰雪大世界一定要第一时间赶去最里面的300米滑梯玩滑梯，人一多根本没可能玩了</li>
<li>中央大街，有个华梅西餐厅，中国四大西餐厅之一，一定要排队领号才能吃到，中央大街只有这家值得去吃 </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考行程&quot;&gt;&lt;a href=&quot;#参考行程&quot; class=&quot;headerlink&quot; title=&quot;参考行程&quot;&gt;&lt;/a&gt;参考行程&lt;/h2&gt;&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="travel" scheme="http://cocacola183.github.io/categories/travel/"/>
    
    
      <category term="travel" scheme="http://cocacola183.github.io/tags/travel/"/>
    
  </entry>
  
  <entry>
    <title>javascript原型</title>
    <link href="http://cocacola183.github.io/2016/11/09/javascript/javascript%E5%8E%9F%E5%9E%8B/"/>
    <id>http://cocacola183.github.io/2016/11/09/javascript/javascript原型/</id>
    <published>2016-11-09T14:18:45.000Z</published>
    <updated>2017-07-02T02:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于js原型的思考"><a href="#关于js原型的思考" class="headerlink" title="关于js原型的思考"></a>关于js原型的思考</h2><p>一直想讨论js原型的问题，但却不知道怎么入手，后来突然想到，能不能从作者的角度思考呢？</p>
<h3 id="我要什么"><a href="#我要什么" class="headerlink" title="我要什么"></a>我要什么</h3><ul>
<li>我需要面向对象编程</li>
<li>我需要一门简单的的语言，所以不需要传统面向对象编程中类的概念，还要能够实现传统面向对象编程语言中类的功能</li>
</ul>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>面向对象编程，最重要的是类和对象，我不想要类，所以最重要的就是对象，所以第一步就是一切皆对象。</p>
<p>虽然没有类，但是我需要实现类的功能啊！没有类怎么生成对象呢？其实由类生成对象的过程，在传统面向对象的语言中，是偏语言底层的过程。我不想搞这么复杂，算了，直接用代码生成对象吧。用代码生成对象，就是执行一段js代码，生成了一个对象。</p>
<p>生成对象的问题解决了，要让生成对象这个代码段规范统一起来，就要和普通的代码段不一样，我得给这个东西规范一个名字，而且代码段最能让人想到的东西就是函数了，就叫这个构造函数吧！那么现在新的问题来了，在这个一切皆对象的世界里，构造函数算什么呢？肯定不能是别的，为了更加直接简单，我让构造函数也是对象，不对是所有的函数都是对象。怎样让函数也是对象？这里先不展开，先贯彻函数也是对象的概念就好。</p>
<p>解决了类和对象的问题，接下来就是面向对象编程的几个重要概念的实现了。</p>
<a id="more"></a>
<h3 id="封装和继承"><a href="#封装和继承" class="headerlink" title="封装和继承"></a>封装和继承</h3><p>先说抽象和封装吧。抽象不说了，直接封装。为了简单，我让对象就是一个键值对的集合，键不能重复，值任意。现在我需要有个地方封装“属性”和“方法”（在js里，全都是对象，只不过表现形式分为属性和对象），而且我需要静态的属性方法，大家共享，不能修改，节省空间。动态的属性方法，大家各用各的。我没有类，我要怎么办才能封装呢？我需要一个容器，这里就是以键值对的方式装着属性方法。又因为类图通常是树形结构的，（看java，哈哈）所以我也要搞一个属性结构的属性方法容器，每一个节点都是一个容器，我用这个容器去关联对象，被同一个容器关联的所有对象，我称他们是同一个类的实例化对象，这样我就实现了静态属性方法的封装功能。（因为属性方法是共享的，所以只能是静态的），动态的属性方法怎么解决呢？必须在创建对象的时候重新开辟内存空间复制这些属性方法给新创建的对象，上文提到了，创建对象使用构造函数，动态属性方法的分配可以在这个构造函数执行的过程中进行。综上所有，动态的属性方法，封装在构造函数中，静态的属性方法封装在容器中，这个容器就是原型，原型到根节点的最短路线，叫做原型链。</p>
<p>再说说继承的问题，继承需要和封装关联起来。静态属性的继承，只需要让原型链上的任一节点上都能访问到从当前节点到原型链顶点所有属性方法，就是功能上实现了继承。静态属性的继承需要原型链路，动态属性的继承，解决问题的方式就是通过一个构造函数链路实现，子构造函数执行的时候调用父构造函数即可。</p>
<p>这样就理清楚了js中，类，对象，原型，构造函数的一些基本的概念，接下来讨论用这种方式解决面向对象编程的一些细节和问题</p>
<h3 id="对象和函数-Object和Function"><a href="#对象和函数-Object和Function" class="headerlink" title="对象和函数(Object和Function)"></a>对象和函数(Object和Function)</h3><p>首先要讨论的还是先有鸡还是先有蛋的问题，既然一开始就明确了，js一切皆对象，那么这个设定已经基本确定了就是先有蛋了。<br>又因为js封装继承的原理都是借助于原型链来实现的，所以还是先从原型链开始，顶端（第一个容器，或者说连容器都算不上），没有任何功能，除了代表原型的起点。真正的js万物的起点，应该是这么一个对象：首先，它是有生成对象的能力的，这就决定了，这个对象一定是一个函数。</p>
<p>现在做这么几个规定：</p>
<ul>
<li>每个函数关联一个容器，容器封装静态属性方法，为继承做准备。这个容器叫做<code>prototype</code>，<code>prototype</code>实现的效果是，当使用这个函数做为构造函数的时候，生成的对象拥有<code>prototype</code>里面的所有属性方法</li>
<li>每一个对象都有一个<code>__proto__</code>的属性，通过这个属性，可以访问到生成这个对象的构造函数关联的容器，即<code>prototype</code>。（注意即使不通过<code>__proto__</code>也是可以访问到原型上的属性的）</li>
</ul>
<p>这样的话，就基本解决了封装和继承的问题，那么产生了另外一个问题，函数也是对象，那么函数的<code>__proto__</code>是啥？更要命的是Object的<code>__proto__</code>是啥？<code>Object</code>已经是最接近原型链顶端的对象（函数）了，我们之前又约定<code>__proto__</code>代表了自己的构造函数的<code>prototype</code>属性，那么到底是谁构造了<code>Object</code>了呢？</p>
<p>说到这，又要引入另外一个神奇的东西了，<code>Function</code>—函数的起点。首先，作为具有类能力的对象，<code>Function</code>也是个函数，又因为函数也是对象，所以<code>Function</code>只能由<code>Object</code>拓展而来，即<code>Function</code>是继承了<code>Object</code>的属性方法的，<code>Function.prototype.__proto__</code> === <code>Object.prototype</code>。但是作为所有函数的起点，<code>bject</code>和<code>Function</code>本身又都是函数，所以<code>Object</code>和<code>Function</code>都是由<code>Function</code>实例化而得，即<code>Object.__proto__</code> === <code>Function.__proto__</code> === <code>Function.prototype</code></p>
<p>上面那段话很绕，但是却基本解决了面向对象编程过程中的细节问题。自此，Object实例化出对象，Function实例化处函数，构建了js世界万象。原型和构造函数给了js面向对象编程的能力。</p>
<h2 id="原型相关概念的理解"><a href="#原型相关概念的理解" class="headerlink" title="原型相关概念的理解"></a>原型相关概念的理解</h2><h3 id="Object-和-Function-关系"><a href="#Object-和-Function-关系" class="headerlink" title="Object 和 Function 关系"></a>Object 和 Function 关系</h3><ul>
<li>从原型角度理解</li>
</ul>
<p>先看下面四个等式:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__); <span class="comment">// null</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>另外一种获取对象<code>__proto__</code>属性的方法是<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf" target="_blank" rel="external">Object.getPrototypeOf</a></p>
<p><code>Object</code>的<code>prototype</code>的原型，就是原型链路的起点，而<code>Function</code>的<code>prototype</code>的原型，是<code>Object</code>的<code>prototype</code>，这说明了<code>Function</code>还是拓展于<code>Object</code>的。<br>再说说<code>Object.__proto__</code>和<code>Function.__proto__</code>都指向<code>Function.prototype</code>表明了<code>Function</code>是所有函数的基类</p>
<p>用一个图来表示<br><img title="Object和Function" alt="Object和Function" src="http://7xj5yf.com1.z0.glb.clouddn.com//images/20161109-01.png?imageView2/2/w/1000"></p>
<p>我参考了<a href="http://anykoro.sinaapp.com/2012/01/31/javascript%E4%B8%ADfunctionobjectprototypes__proto__%E7%AD%89%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">这篇博客</a>，写的很详细，值得参考</p>
<ul>
<li>从拓展方面理解</li>
</ul>
<p>先看个图<br><img title="Object和Function" alt="Object和Function" src="http://7xj5yf.com1.z0.glb.clouddn.com//images/20161109-02.png?imageView2/2/w/1000"></p>
<p><code>Object</code>和<code>Function</code>分别走了两个方向，<code>Object</code>偏向于做为所有对象的基类，<code>Function</code>偏向于做为函数的基类型</p>
<p>拓展Object原型：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.foo = <span class="string">'bar'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.foo); <span class="comment">// bar</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.foo); <span class="comment">// bar</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.foo); <span class="comment">// bar</span></div></pre></td></tr></table></figure></p>
<p>拓展<code>Object.prototype</code>，就相当于拓展了<code>Function.prototype</code>，又因为<code>Object</code>和<code>Function</code>都由<code>Function</code>拓展而来的，所以当你拓展<code>Function.prototype</code>，那么<code>Function</code>和<code>Object</code>就都被拓展了，所以才有了<code>Function.foo</code>和<code>Object.foo</code>都等于<code>bar</code></p>
<p>接着上面的例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(foo.foo); <span class="comment">// bar</span></div><div class="line"><span class="built_in">console</span>.log(Foo.foo); <span class="comment">// bar</span></div></pre></td></tr></table></figure></p>
<p>这说明实例对象和函数都被拓展了</p>
<p>总结：<code>Object</code>拓展了所有的object，<code>Object</code>拓展了<code>Function</code>，<code>Object</code>拓展了自己的属性（通过拓展<code>Function</code>拓展自己）</p>
<p>拓展<code>Function</code>原型：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.foo = <span class="string">'bar'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.foo); <span class="comment">// bar</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.foo); <span class="comment">// bar</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.foo); <span class="comment">// bar</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(foo.foo); <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(Foo.foo); <span class="comment">// bar</span></div></pre></td></tr></table></figure></p>
<p>以上说明了<code>Function</code>原型拓展只能拓展未被实例化的函数，实例化对象无法拓展</p>
<h3 id="proto-和-prototype-的理解"><a href="#proto-和-prototype-的理解" class="headerlink" title="__proto 和 prototype 的理解"></a>__proto 和 prototype 的理解</h3><p>所有的对象都有<code>__proto__</code>属性，指向他们构造函数的<code>prototype</code><br>当然，所有的函数也都有<code>__proto__</code>属性，指向<code>Function.prototype</code><br>只有函数有<code>prototype</code>属性，函数的<code>prototype</code>属性，就是为封装操作提供的，让对象共享属性方法</p>
<p>对于区别：<br>从实际效果上来说，可以认为<code>__proto__</code>是用来扩展<code>Function</code>的，扩展出来的函数，可以直接调用，不需要<code>new</code>出对象才能用，同时对象是不会扩展通过<code>__proto__</code>扩展的方法或属性的。</p>
<ul>
<li>扩展<code>__proto__</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Foo.__proto__.test=<span class="string">"__proto__ test property found"</span>;<span class="comment">//通过__proto__扩展</span></div><div class="line">Foo.__proto__.addextend=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">"Foo add extend by __proto__"</span>);&#125;</div><div class="line">Foo.addextend();<span class="comment">//可以执行</span></div><div class="line"><span class="keyword">var</span> foo=<span class="keyword">new</span> Foo;</div><div class="line">alert(<span class="string">"Foo:"</span>+Foo.test);<span class="comment">//可以访问</span></div><div class="line">alert(foo.addextend);<span class="comment">//未定义</span></div></pre></td></tr></table></figure>
<p>对于<code>prototype</code>来说，它是针对对象的，也就是<code>Function</code>是无法使用的，只有<code>new</code>出来的才能有效</p>
<ul>
<li>扩展<code>prototype</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Foo.prototype.test=<span class="string">"prototype test property found"</span>;</div><div class="line">Foo.prototype.addextend=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">"Foo add extend by prototype"</span>);&#125;</div><div class="line">alert(Foo.addextend());<span class="comment">//未定义</span></div><div class="line"><span class="keyword">var</span> foo=<span class="keyword">new</span> Foo;</div><div class="line">alert(<span class="string">"Foo:"</span>+Foo.test);<span class="comment">//无法访问</span></div><div class="line">foo.addextend();<span class="comment">//可以执行</span></div><div class="line">alert(<span class="string">"Foo instance:"</span>+foo.test);<span class="comment">//找到了</span></div></pre></td></tr></table></figure>
<ul>
<li>通过<code>__proto__</code>扩展<code>Object</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.__proto__.test4extend=<span class="string">"123"</span>;<span class="comment">//扩展Object的原型</span></div><div class="line">alert(<span class="string">"Function:"</span>+<span class="built_in">Function</span>.test4extend);<span class="comment">//在Function中出现了test4extend属性</span></div><div class="line">alert(<span class="string">"Object:"</span>+<span class="built_in">Object</span>.test4extend);<span class="comment">//在Object中出现了test4extend属性，此时Object还是个Function</span></div><div class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>;</div><div class="line">alert(<span class="string">"Object instance:"</span>+obj.test4extend);<span class="comment">//未定义</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo;</div><div class="line">alert(<span class="string">"foo object:"</span>+foo.test4extend);<span class="comment">//未定义</span></div></pre></td></tr></table></figure>
<p><code>Function</code>扩展自<code>Object</code>，但是<code>Function</code>对<code>Object</code>又有影响，这是通过<code>Object.__proto__</code>就是（===）<code>Function.prototype</code>建立的联系。记住这个联系后，我们还要记住<code>__proto__</code>和<code>prototype</code>的区别，前者扩展的只可以被<code>Function</code>直接调用，后者扩展的只可以通过其实例调用。另外，还要注意<code>__proto__</code>和<code>prototype</code>的链的概念，这是因为，他们可以互相关联，访问到<code>Function</code>或<code>Ojbect</code>的内容。</p>
<h3 id="原型操作常用操作符总结"><a href="#原型操作常用操作符总结" class="headerlink" title="原型操作常用操作符总结"></a>原型操作常用操作符总结</h3><ul>
<li><code>constructor</code> // 对象有个.constructor 属性，指向自己的构造函数</li>
<li><code>instanceof</code> // instanceof运算符，判断左边的实例是否又右边的构造函数生成</li>
<li><code>isPrototypeOf</code> // 这个方法用来判断，某个proptotype对象和某个实例之间的关系 Cat.prototype.isPrototypeOf(cat1)</li>
<li><code>hasOwnProperty</code> // 每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。</li>
<li><code>in</code> // in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。in运算符还可以用来遍历某个对象的所有属性</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于js原型的思考&quot;&gt;&lt;a href=&quot;#关于js原型的思考&quot; class=&quot;headerlink&quot; title=&quot;关于js原型的思考&quot;&gt;&lt;/a&gt;关于js原型的思考&lt;/h2&gt;&lt;p&gt;一直想讨论js原型的问题，但却不知道怎么入手，后来突然想到，能不能从作者的角度思考呢？&lt;/p&gt;
&lt;h3 id=&quot;我要什么&quot;&gt;&lt;a href=&quot;#我要什么&quot; class=&quot;headerlink&quot; title=&quot;我要什么&quot;&gt;&lt;/a&gt;我要什么&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;我需要面向对象编程&lt;/li&gt;
&lt;li&gt;我需要一门简单的的语言，所以不需要传统面向对象编程中类的概念，还要能够实现传统面向对象编程语言中类的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h3&gt;&lt;p&gt;面向对象编程，最重要的是类和对象，我不想要类，所以最重要的就是对象，所以第一步就是一切皆对象。&lt;/p&gt;
&lt;p&gt;虽然没有类，但是我需要实现类的功能啊！没有类怎么生成对象呢？其实由类生成对象的过程，在传统面向对象的语言中，是偏语言底层的过程。我不想搞这么复杂，算了，直接用代码生成对象吧。用代码生成对象，就是执行一段js代码，生成了一个对象。&lt;/p&gt;
&lt;p&gt;生成对象的问题解决了，要让生成对象这个代码段规范统一起来，就要和普通的代码段不一样，我得给这个东西规范一个名字，而且代码段最能让人想到的东西就是函数了，就叫这个构造函数吧！那么现在新的问题来了，在这个一切皆对象的世界里，构造函数算什么呢？肯定不能是别的，为了更加直接简单，我让构造函数也是对象，不对是所有的函数都是对象。怎样让函数也是对象？这里先不展开，先贯彻函数也是对象的概念就好。&lt;/p&gt;
&lt;p&gt;解决了类和对象的问题，接下来就是面向对象编程的几个重要概念的实现了。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://cocacola183.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://cocacola183.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB聚合操作小节</title>
    <link href="http://cocacola183.github.io/2016/10/26/mongo/mongodb%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C/"/>
    <id>http://cocacola183.github.io/2016/10/26/mongo/mongodb聚合操作/</id>
    <published>2016-10-26T12:38:13.000Z</published>
    <updated>2017-07-02T02:33:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么使用聚合"><a href="#为什么使用聚合" class="headerlink" title="为什么使用聚合"></a>为什么使用聚合</h2><ul>
<li><p>聚合操作的作用</p>
<blockquote>
<p>Aggregations operations process data records and return computed results. Aggregation operations group values from multiple documents together, and can perform a variety of operations on the grouped data to return a single result.</p>
</blockquote>
<p>我的理解是，聚合类的操作提供了一个便捷的计算查询结果的方法。例如你如果使用简单的查询语句可能返回的是一组结果，需要代码去把结果进行计算处理，但是如果使用聚合操作，可以通过一个聚合语句直接返回计算结果。</p>
</li>
<li><p>这里举一个官网上提供的最简单的例子</p>
<img title="聚合操作示例" alt="聚合操作示例" src="http://7xj5yf.com1.z0.glb.clouddn.com//images/20161026-01.png?imageView2/2/w/1000">
<p>如果需要从左边的数据得到右边的结果，一个简单的查询是没有办法做到的，但是聚合操作就可以做到。</p>
</li>
</ul>
<a id="more"></a>
<h2 id="MongoDB提供了哪些聚合操作"><a href="#MongoDB提供了哪些聚合操作" class="headerlink" title="MongoDB提供了哪些聚合操作"></a>MongoDB提供了哪些聚合操作</h2><h3 id="Aggregation-Pipeline"><a href="#Aggregation-Pipeline" class="headerlink" title="Aggregation Pipeline"></a>Aggregation Pipeline</h3><p>MongoDB提供的聚合操作（aggregation）是基于数据处理管道模型的。管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。</p>
<p>最基本的聚合管道类似过滤器或者是文档格式转换器。稍微复杂点的，会提供分组，排序，计算等操作。</p>
<p>相比其他的聚合方法，聚合管道这种聚合方式是比较高效的，因为聚合管道是mongodb远程操作去执行的（区别于map reduce），这是mongodb官方推荐的聚合方式</p>
<p>聚合管道可以在分片集合上执行</p>
<p>可以通过添加索引来提高聚合管道的性能，聚合管道自身也有一套性能优化方案</p>
<h3 id="Map-reduce"><a href="#Map-reduce" class="headerlink" title="Map-reduce"></a>Map-reduce</h3><p>MongoDB还提供了一种简单聚合操作，map reduce。map reduce的聚合原理分为两个步骤，即map阶段和reduce阶段。这两个操作非常类似es5中，数组原型上的两个方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="external">map</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="external">reduce</a>。不理解的建议先理解一下这两个方法</p>
<ul>
<li>map过程： 将输入的一组文档映射成为另外一组文档（便于统计计算的格式的文档）</li>
<li>reduce过程：对map的结果进行聚合，计算等操作</li>
</ul>
<p>这么些可能不太好理解，还是举一个官网的例子<br><img title="map-reduce示例" alt="map-reduce示例" src="http://7xj5yf.com1.z0.glb.clouddn.com//images/20161026-02.png?imageView2/2/w/1000"></p>
<p>map-reduce可以指定一个最终的数据处理阶段，用于对数据的最后一次整理。而且map reduce也可以指定一个查询语句去过滤数据，或者进行sort和limit操作。<br>map-reduce使用js方法去执行聚合操作，这样的好处是提供了极大的灵活性，缺点是在性能上会比aggregation pipeline差。<br>map-reduce在分片的集合上操作，也可以把数据输出到分片集合上。</p>
<h3 id="Single-Purpose-Aggregation-Operations（单一目的聚合操作）"><a href="#Single-Purpose-Aggregation-Operations（单一目的聚合操作）" class="headerlink" title="Single Purpose Aggregation Operations（单一目的聚合操作）"></a>Single Purpose Aggregation Operations（单一目的聚合操作）</h3><p>MongoDB提供了一些常用的简单聚合操作的快捷入口，例如<code>db.collection.count()</code>, <code>db.collection.group()</code>, <code>db.collection.distinct()</code><br>这些操作使用起来非常简单，但是没有aggregation pipeline 和 map-reduce 灵活。性能上，这些操作是比aggregation pipeline要慢的，这种聚合操作就是方便了调用。</p>
<img title="group操作示例" alt="group操作示例" src="http://7xj5yf.com1.z0.glb.clouddn.com//images/20161026-03.png?imageView2/2/w/1000">
<h2 id="MongoDB三种聚合操作的比较"><a href="#MongoDB三种聚合操作的比较" class="headerlink" title="MongoDB三种聚合操作的比较"></a>MongoDB三种聚合操作的比较</h2><h3 id="聚合操作比较表"><a href="#聚合操作比较表" class="headerlink" title="聚合操作比较表"></a><strong><a href="https://docs.mongodb.com/manual/reference/aggregation-commands-comparison/" target="_blank" rel="external">聚合操作比较表</a></strong></h3><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">aggregate pipeline</th>
<th style="text-align:left">map-reduce</th>
<th style="text-align:left">group</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>描述</strong></td>
<td style="text-align:left">为了聚合操作的性能和可用性而生，使用多级管道处理数据</td>
<td style="text-align:left">适合处理较大数据量的聚合操作，有map,reduce,final(不是必须)三个数据处理阶段</td>
<td style="text-align:left">提供函数式的简单聚合操作，但是速度比aggregate慢，灵活性没有aggregate和map-reduce高</td>
</tr>
<tr>
<td style="text-align:center"><strong>主要特点</strong></td>
<td style="text-align:left"><p>管道操作可重复多次，没有次数限制</p> <p>管道不用实现每一个输入文档都对应一个输出文档; 管道也提供生成新的文档，过滤输入文档的功能</p></td>
<td style="text-align:left">除了分组操作，可以执行复杂的聚合任务以及对不断增长的数据集执行增量聚合（<code>增量聚合稍后讨论</code>）<p></p></td>
<td style="text-align:left"><p>非常方便的对文档现有字段进行分组</p><p>也可以通过定制keyf js函数，对计算过的字段进行分组（<code>keyf函数稍后讨论</code>）</p></td>
</tr>
<tr>
<td style="text-align:center"><strong>灵活性</strong></td>
<td style="text-align:left">尽管受mongodb提供的aggregation操作符和表达式的限制，还是能够通过$project实现常用的聚合基本操作（<code>稍后讨论aggregation操作符</code>）</td>
<td style="text-align:left">自定义的map，reduce，final等js函数给聚合操作提供了非常大的灵活性</td>
<td style="text-align:left">自定义的reduce，final等js函数为group操作提供了灵活性</td>
</tr>
<tr>
<td style="text-align:center"><strong>输出结果</strong></td>
<td style="text-align:left"><p>返回一个内联文档（包含一个结集和一个结果集的指针），或者是存储结果到集合中</p> <p>如果以内联文档的形式返回，那么返回数据受到BSON文档大小的限制（<code>稍后讨论BSON文档大小限制</code>）</p> <p>NOTE：2.6版本之后可以只返回一个指针或者是存储数据到集合中</p></td>
<td style="text-align:left">多种数据输出方式，可以内联文档形式返回，可以存入collection，可以merge，replace，reduce</td>
<td style="text-align:left"><p>返回一个内联数组（分过组的数据组成的数组），返回数据受到BSON文档大小的限制</p> <p>返回的数组最多包含20,000 条数据</p></td>
</tr>
<tr>
<td style="text-align:center"><strong>对分片的支持</strong></td>
<td style="text-align:left">支持分片集合</td>
<td style="text-align:left">支持分片集合</td>
<td style="text-align:left">不支持分片集合</td>
</tr>
</tbody>
</table>
<h3 id="聚合操作比较补充说明"><a href="#聚合操作比较补充说明" class="headerlink" title="聚合操作比较补充说明"></a><strong>聚合操作比较补充说明</strong></h3><p><br></p>
<h4 id="Map-reduce的增量聚合"><a href="#Map-reduce的增量聚合" class="headerlink" title="Map-reduce的增量聚合"></a><a href="https://docs.mongodb.com/manual/tutorial/perform-incremental-map-reduce/" target="_blank" rel="external">Map-reduce的增量聚合</a></h4><p>如果当前map-reduce数据集合处于持续增长的状态，我们会希望能够实现增量的map-reduce（每次都只对新增数据进行map-reduce），而不是每次聚合都需要对所有数据进行map-reduce。</p>
<p>怎样进行增量map-reduce?</p>
<ul>
<li>在一个<code>collection</code>中启动<code>map-reduce</code>任务，输出结果到另外一个独立的<code>collection</code>中</li>
<li>当有新的数据需要处理的时候，在下面的前提下执行之后的<code>map-reduce</code>任务<ol>
<li><code>query</code>参数要能匹配出新增的数据</li>
<li><code>out</code>参数要能使<code>reduce</code>产出的新的结果正确的合并到已存在的结果集中</li>
</ol>
</li>
</ul>
<p>下面通过一个例子说明:</p>
<ul>
<li>场景：每天结束的时候增量聚合一下用户的<code>session</code>集合</li>
<li><p>数据: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="attr">userid</span>: <span class="string">"a"</span>, <span class="attr">ts</span>: ISODate(<span class="string">'2011-11-03 14:17:00'</span>), <span class="attr">length</span>: <span class="number">95</span> &#125;</div><div class="line">&#123; <span class="attr">userid</span>: <span class="string">"b"</span>, <span class="attr">ts</span>: ISODate(<span class="string">'2011-11-03 14:23:00'</span>), <span class="attr">length</span>: <span class="number">110</span> &#125;</div><div class="line">&#123; <span class="attr">userid</span>: <span class="string">"c"</span>, <span class="attr">ts</span>: ISODate(<span class="string">'2011-11-03 15:02:00'</span>), <span class="attr">length</span>: <span class="number">120</span> &#125;</div><div class="line">&#123; <span class="attr">userid</span>: <span class="string">"d"</span>, <span class="attr">ts</span>: ISODate(<span class="string">'2011-11-03 16:45:00'</span>), <span class="attr">length</span>: <span class="number">45</span> &#125;</div><div class="line"><span class="comment">/****************************************************************/</span></div><div class="line">&#123; <span class="attr">userid</span>: <span class="string">"a"</span>, <span class="attr">ts</span>: ISODate(<span class="string">'2011-11-04 11:05:00'</span>), <span class="attr">length</span>: <span class="number">105</span> &#125;</div><div class="line">&#123; <span class="attr">userid</span>: <span class="string">"b"</span>, <span class="attr">ts</span>: ISODate(<span class="string">'2011-11-04 13:14:00'</span>), <span class="attr">length</span>: <span class="number">120</span> &#125;</div><div class="line">&#123; <span class="attr">userid</span>: <span class="string">"c"</span>, <span class="attr">ts</span>: ISODate(<span class="string">'2011-11-04 17:00:00'</span>), <span class="attr">length</span>: <span class="number">130</span> &#125;</div><div class="line">&#123; <span class="attr">userid</span>: <span class="string">"d"</span>, <span class="attr">ts</span>: ISODate(<span class="string">'2011-11-04 15:37:00'</span>), <span class="attr">length</span>: <span class="number">65</span> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>初始化<code>session</code>集合的<code>map-reduce</code>:<br>1.定义<code>map</code>方法，实现<code>userid</code>到用户信息的映射</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mapFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                    <span class="keyword">var</span> key = <span class="keyword">this</span>.userid;</div><div class="line">                    <span class="keyword">var</span> value = &#123;</div><div class="line">                                  <span class="attr">userid</span>: <span class="keyword">this</span>.userid,</div><div class="line">                                  <span class="attr">total_time</span>: <span class="keyword">this</span>.length,</div><div class="line">                                  <span class="attr">count</span>: <span class="number">1</span>,</div><div class="line">                                  <span class="attr">avg_time</span>: <span class="number">0</span></div><div class="line">                                 &#125;;</div><div class="line"></div><div class="line">                    emit( key, value );</div><div class="line">                &#125;;</div></pre></td></tr></table></figure>
<p>2.定义与<code>map</code>对应的<code>reduce</code>方法，实现通过<code>key</code>和<code>value</code>去计算<code>total_time</code>和<code>count</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reduceFunction = <span class="function"><span class="keyword">function</span>(<span class="params">key, values</span>) </span>&#123;</div><div class="line">                      <span class="keyword">var</span> reducedObject = &#123;</div><div class="line">                                            <span class="attr">userid</span>: key,</div><div class="line">                                            <span class="attr">total_time</span>: <span class="number">0</span>,</div><div class="line">                                            <span class="attr">count</span>:<span class="number">0</span>,</div><div class="line">                                            <span class="attr">avg_time</span>:<span class="number">0</span></div><div class="line">                                          &#125;;</div><div class="line"></div><div class="line">                      values.forEach( <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">                                            reducedObject.total_time += value.total_time;</div><div class="line">                                            reducedObject.count += value.count;</div><div class="line">                                      &#125;</div><div class="line">                                    );</div><div class="line">                      <span class="keyword">return</span> reducedObject;</div><div class="line">                   &#125;;</div></pre></td></tr></table></figure>
<p>3.定义<code>finalize</code>方法，接收<code>key</code>和<code>reducedObject</code>两个参数，修改<code>reducedObject</code>为最终想要的格式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> finalizeFunction = <span class="function"><span class="keyword">function</span> (<span class="params">key, reducedValue</span>) </span>&#123;</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (reducedValue.count &gt; <span class="number">0</span>)</div><div class="line">                            reducedValue.avg_time = reducedValue.total_time / reducedValue.count;</div><div class="line"></div><div class="line">                        <span class="keyword">return</span> reducedValue;</div><div class="line">                     &#125;;</div></pre></td></tr></table></figure>
<p>4.在<code>session</code>集合执行<code>map-reduce</code>操作通过上面定义的三个方法，输出数据到<code>session-stat</code>集合中，如果<code>session-stat</code>集合已存在，则此操作将会替换一下内容:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.sessions.mapReduce( mapFunction,</div><div class="line">                     reduceFunction,</div><div class="line">                     &#123;</div><div class="line">                       <span class="attr">out</span>: <span class="string">"session_stat"</span>,</div><div class="line">                       <span class="attr">finalize</span>: finalizeFunction</div><div class="line">                     &#125;</div><div class="line">                   )</div></pre></td></tr></table></figure>
</li>
<li><p>实现增量<code>map-reduce</code><br>加入今天又出现了一下几条数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.sessions.save( &#123; <span class="attr">userid</span>: <span class="string">"a"</span>, <span class="attr">ts</span>: ISODate(<span class="string">'2011-11-05 14:17:00'</span>), <span class="attr">length</span>: <span class="number">100</span> &#125; );</div><div class="line">db.sessions.save( &#123; <span class="attr">userid</span>: <span class="string">"b"</span>, <span class="attr">ts</span>: ISODate(<span class="string">'2011-11-05 14:23:00'</span>), <span class="attr">length</span>: <span class="number">115</span> &#125; );</div><div class="line">db.sessions.save( &#123; <span class="attr">userid</span>: <span class="string">"c"</span>, <span class="attr">ts</span>: ISODate(<span class="string">'2011-11-05 15:02:00'</span>), <span class="attr">length</span>: <span class="number">125</span> &#125; );</div><div class="line">db.sessions.save( &#123; <span class="attr">userid</span>: <span class="string">"d"</span>, <span class="attr">ts</span>: ISODate(<span class="string">'2011-11-05 16:45:00'</span>), <span class="attr">length</span>: <span class="number">55</span> &#125; );</div></pre></td></tr></table></figure>
<p>那么接下来的<code>map-reduce</code>操作应该这么做:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">db.sessions.mapReduce( mapFunction,</div><div class="line">                       reduceFunction,</div><div class="line">                       &#123;</div><div class="line">                         <span class="attr">query</span>: &#123; <span class="attr">ts</span>: &#123; <span class="attr">$gt</span>: ISODate(<span class="string">'2011-11-05 00:00:00'</span>) &#125; &#125;,</div><div class="line">                         <span class="attr">out</span>: &#123; <span class="attr">reduce</span>: <span class="string">"session_stat"</span> &#125;,</div><div class="line">                         <span class="attr">finalize</span>: finalizeFunction</div><div class="line">                       &#125;</div><div class="line">                     );</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="group的keyf函数"><a href="#group的keyf函数" class="headerlink" title="group的keyf函数"></a><a href="https://docs.mongodb.com/manual/reference/command/group/#dbcmd.group" target="_blank" rel="external">group的keyf函数</a></h3><p><code>group</code>的<code>$keyf</code>参数，是可选的，是<code>key</code>参数的一种取代方案，它指定一个函数，返回一个<code>key Object</code>作为分组的<code>key</code>。用<code>$keyf</code>代替<code>key</code>的意义在于，可以实现用计算得出的字段去分组，而不是用已经存在的字段去分组</p>
<p>举个例子：</p>
<ul>
<li><p>以下是测试数据的数据类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">_id</span>: ObjectId(<span class="string">"5085a95c8fada716c89d0021"</span>),</div><div class="line">  <span class="attr">ord_dt</span>: ISODate(<span class="string">"2012-07-01T04:00:00Z"</span>),</div><div class="line">  <span class="attr">ship_dt</span>: ISODate(<span class="string">"2012-07-02T04:00:00Z"</span>),</div><div class="line">  <span class="attr">item</span>:</div><div class="line">    &#123;</div><div class="line">      <span class="attr">sku</span>: <span class="string">"abc123"</span>,</div><div class="line">      <span class="attr">price</span>: <span class="number">1.99</span>,</div><div class="line">      <span class="attr">uom</span>: <span class="string">"pcs"</span>,</div><div class="line">      <span class="attr">qty</span>: <span class="number">25</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>目标是计算总和，总数，平均值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">db.runCommand(</div><div class="line">  &#123;</div><div class="line">    <span class="attr">group</span>:</div><div class="line">     &#123;</div><div class="line">       <span class="attr">ns</span>: <span class="string">'orders'</span>, <span class="comment">// collection name</span></div><div class="line">       $keyf: <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</div><div class="line">                  <span class="keyword">return</span> &#123; <span class="attr">day_of_week</span>: doc.ord_dt.getDay() &#125;;</div><div class="line">              &#125;,</div><div class="line">       <span class="attr">cond</span>: &#123; <span class="attr">ord_dt</span>: &#123; <span class="attr">$gt</span>: <span class="keyword">new</span> <span class="built_in">Date</span>( <span class="string">'01/01/2012'</span> ) &#125; &#125;, <span class="comment">// 相当于过滤条件，缺省的话就是group全部</span></div><div class="line">       $reduce: <span class="function"><span class="keyword">function</span>(<span class="params"> curr, result </span>) </span>&#123;</div><div class="line">                    result.total += curr.item.qty;</div><div class="line">                    result.count++;</div><div class="line">                &#125;,</div><div class="line">       <span class="attr">initial</span>: &#123; <span class="attr">total</span> : <span class="number">0</span>, <span class="attr">count</span>: <span class="number">0</span> &#125;,</div><div class="line">       <span class="attr">finalize</span>: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</div><div class="line">                    <span class="keyword">var</span> weekdays = [</div><div class="line">                         <span class="string">"Sunday"</span>, <span class="string">"Monday"</span>, <span class="string">"Tuesday"</span>,</div><div class="line">                         <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>,</div><div class="line">                         <span class="string">"Friday"</span>, <span class="string">"Saturday"</span></div><div class="line">                        ];</div><div class="line">                    result.day_of_week = weekdays[result.day_of_week];</div><div class="line">                    result.avg = <span class="built_in">Math</span>.round(result.total / result.count);</div><div class="line">                 &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
</li>
<li><p>得到以下数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"retval"</span> :</div><div class="line">      [</div><div class="line">        &#123; <span class="string">"day_of_week"</span> : <span class="string">"Sunday"</span>, <span class="string">"total"</span> : <span class="number">70</span>, <span class="string">"count"</span> : <span class="number">4</span>, <span class="string">"avg"</span> : <span class="number">18</span> &#125;,</div><div class="line">        &#123; <span class="string">"day_of_week"</span> : <span class="string">"Friday"</span>, <span class="string">"total"</span> : <span class="number">110</span>, <span class="string">"count"</span> : <span class="number">6</span>, <span class="string">"avg"</span> : <span class="number">18</span> &#125;,</div><div class="line">        &#123; <span class="string">"day_of_week"</span> : <span class="string">"Tuesday"</span>, <span class="string">"total"</span> : <span class="number">70</span>, <span class="string">"count"</span> : <span class="number">3</span>, <span class="string">"avg"</span> : <span class="number">23</span> &#125;</div><div class="line">      ],</div><div class="line">  <span class="string">"count"</span> : <span class="number">13</span>,</div><div class="line">  <span class="string">"keys"</span> : <span class="number">3</span>,</div><div class="line">  <span class="string">"ok"</span> : <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Aggregation-Pipeline-操作符"><a href="#Aggregation-Pipeline-操作符" class="headerlink" title="Aggregation Pipeline 操作符"></a><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/" target="_blank" rel="external">Aggregation Pipeline 操作符</a></h3><p><br></p>
<h4 id="聚合阶段操作符"><a href="#聚合阶段操作符" class="headerlink" title="聚合阶段操作符"></a>聚合阶段操作符</h4><table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$project</td>
<td style="text-align:left">改变数据流中的文档结构</td>
</tr>
<tr>
<td style="text-align:left">$match</td>
<td style="text-align:left">数据过滤器，只聚合match到的数据，match语句格式是mongdb标准查询语句格式</td>
</tr>
<tr>
<td style="text-align:left">$redact</td>
<td style="text-align:left">基于文档自身内容去调整文档机构，包含了$match和$project的功能，可以用于文档的字段编辑。对于每一个输入，可以有0个或者是1哥输出</td>
</tr>
<tr>
<td style="text-align:left">$limit</td>
<td style="text-align:left">限制通过的文档的数量</td>
</tr>
<tr>
<td style="text-align:left">$skip</td>
<td style="text-align:left">跳过指定数量的文档</td>
</tr>
<tr>
<td style="text-align:left">$unwind</td>
<td style="text-align:left">解构输入文档的数组字段，为数组中的每一元素指定一个新的输出文档</td>
</tr>
<tr>
<td style="text-align:left">$group</td>
<td style="text-align:left">分组操作的功能实现，需要指定一个id表达式和一些计算表达式（非必需）。都指定之后，分组操作会输入每一组所有的文档，然后输出一个经过计算之后的输出文档。注意输出文档只包含了id表达式指定的字段，以及计算表达式指定的字段（如果有计算表达式的话）</td>
</tr>
<tr>
<td style="text-align:left">$sample</td>
<td style="text-align:left">随机选择指定数量的输入文档</td>
</tr>
<tr>
<td style="text-align:left">$sort</td>
<td style="text-align:left">根据指定字段给输入结果排序，输出排序后的结果，一个输入对应一个输出</td>
</tr>
<tr>
<td style="text-align:left">$geoNear</td>
<td style="text-align:left">输出接近某一地理位置的有序文档</td>
</tr>
<tr>
<td style="text-align:left">$lookup</td>
<td style="text-align:left">类似一个left outer join 的操作</td>
</tr>
<tr>
<td style="text-align:left">$out</td>
<td style="text-align:left">输出聚合结果到一个collection中</td>
</tr>
<tr>
<td style="text-align:left">$indexStats</td>
<td style="text-align:left">返回集合中索引的使用统计结果</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="表达式操作符"><a href="#表达式操作符" class="headerlink" title="表达式操作符"></a>表达式操作符</h4><table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$and</td>
<td style="text-align:left">逻辑与</td>
</tr>
<tr>
<td style="text-align:left">$or</td>
<td style="text-align:left">逻辑或</td>
</tr>
<tr>
<td style="text-align:left">$not</td>
<td style="text-align:left">逻辑非</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="集合操作符"><a href="#集合操作符" class="headerlink" title="集合操作符"></a>集合操作符</h4><table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/setEquals/#exp._S_setEquals" target="_blank" rel="external">$setEquals</a></td>
<td style="text-align:left">比较两个数组是否包含相同的不重复元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/setIntersection/#exp._S_setIntersection" target="_blank" rel="external">$setIntersection</a></td>
<td style="text-align:left">返回所有输入数组共同拥有的不重复元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/setUnion/#exp._S_setUnion" target="_blank" rel="external">$setUnion</a></td>
<td style="text-align:left">返回所有输入数组的所有不重复元素组成的集合</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/setDifference/#exp._S_setDifference" target="_blank" rel="external">$setDifference</a></td>
<td style="text-align:left">返回第一个数组中有的，第二个数组中没有的不重复元素组成的集合</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/setIsSubset/#exp._S_setIsSubset" target="_blank" rel="external">$setIsSubset</a></td>
<td style="text-align:left">如果第一个数组所有元素在第二个数组中都出现，则返回true，否则返回false</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/anyElementTrue/#exp._S_anyElementTrue" target="_blank" rel="external">$anyElementTrue</a></td>
<td style="text-align:left">数组只要有一个元素经过if语句判断都能通过的时候，返回true，否则返回false</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/allElementsTrue/#exp._S_allElementsTrue" target="_blank" rel="external">$allElementsTrue</a></td>
<td style="text-align:left">数组所有元素经过if语句判断都能通过的时候，返回true，否则返回false</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h4><table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$cmp</td>
<td style="text-align:left">相等，返回0，第一个值大于第二个，返回1，第一个值小于第二个，返回-1</td>
</tr>
<tr>
<td style="text-align:left">$eq</td>
<td style="text-align:left">两值相等，返回true</td>
</tr>
<tr>
<td style="text-align:left">$gt</td>
<td style="text-align:left">第一个值大于第二个值的时候，返回true</td>
</tr>
<tr>
<td style="text-align:left">$gte</td>
<td style="text-align:left">第一个值大于或者等于第二个值的时候，返回true</td>
</tr>
<tr>
<td style="text-align:left">$lt</td>
<td style="text-align:left">第一个值小于第二个值的时候，返回true</td>
</tr>
<tr>
<td style="text-align:left">$lte</td>
<td style="text-align:left">第一个值大于或等于第二个值的时候，返回true</td>
</tr>
<tr>
<td style="text-align:left">$ne</td>
<td style="text-align:left">两值不想等的时候返回true</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="数学操作符"><a href="#数学操作符" class="headerlink" title="数学操作符"></a>数学操作符</h4><table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$abs</td>
<td style="text-align:left">取绝对值</td>
</tr>
<tr>
<td style="text-align:left">$add</td>
<td style="text-align:left">计算两数之和或者是日期加上一个数字得到的一个新的日期，数字被当作毫秒看待。可以有任意参数，但是最多只有一个参数会被当作日期处理</td>
</tr>
<tr>
<td style="text-align:left">$ceil</td>
<td style="text-align:left">返回一个比给出值大或相等的最小整数</td>
</tr>
<tr>
<td style="text-align:left">$divide</td>
<td style="text-align:left">做除法，只接收两个参数</td>
</tr>
<tr>
<td style="text-align:left">$exp</td>
<td style="text-align:left">指定e的指数为n，计算e的n次方</td>
</tr>
<tr>
<td style="text-align:left">$floor</td>
<td style="text-align:left">返回一个比给出值小或相等的最大整数</td>
</tr>
<tr>
<td style="text-align:left">$ln</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$log</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$log10</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$mod</td>
<td style="text-align:left">取余</td>
</tr>
<tr>
<td style="text-align:left">$multiply</td>
<td style="text-align:left">做乘法</td>
</tr>
<tr>
<td style="text-align:left">$pow</td>
<td style="text-align:left">指数运算</td>
</tr>
<tr>
<td style="text-align:left">$sqrt</td>
<td style="text-align:left">开方运算</td>
</tr>
<tr>
<td style="text-align:left">$subtract</td>
<td style="text-align:left">减法运算</td>
</tr>
<tr>
<td style="text-align:left">$trunc</td>
<td style="text-align:left">截去一个数值的小数部分，返回小数部分</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="字符串操作符"><a href="#字符串操作符" class="headerlink" title="字符串操作符"></a>字符串操作符</h4><table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$concat</td>
<td style="text-align:left">拼接人意数量的字符串</td>
</tr>
<tr>
<td style="text-align:left">$substr</td>
<td style="text-align:left">字符串截取功能</td>
</tr>
<tr>
<td style="text-align:left">$toLower</td>
<td style="text-align:left">字符串转小写</td>
</tr>
<tr>
<td style="text-align:left">$toUpper</td>
<td style="text-align:left">字符串转大写</td>
</tr>
<tr>
<td style="text-align:left">$strcasecmp</td>
<td style="text-align:left">字符串比较（区分大小写）</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="文字操作符"><a href="#文字操作符" class="headerlink" title="文字操作符"></a>文字操作符</h4><table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/meta/#exp._S_meta" target="_blank" rel="external">$meta</a></td>
<td style="text-align:left">结合$text一起使用，例子看<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/meta/#exp._S_meta" target="_blank" rel="external">这里</a></td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="数组操作符"><a href="#数组操作符" class="headerlink" title="数组操作符"></a>数组操作符</h4><table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$arrayElemAt</td>
<td style="text-align:left">返回数组指定位置的元素</td>
</tr>
<tr>
<td style="text-align:left">$concatArrays</td>
<td style="text-align:left">合并数组</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/filter/#exp._S_filter" target="_blank" rel="external">$filter</a></td>
<td style="text-align:left">根据输入数组和过滤条件返回一个子数组</td>
</tr>
<tr>
<td style="text-align:left">$isArray</td>
<td style="text-align:left">判断指定字段是不是数组</td>
</tr>
<tr>
<td style="text-align:left">$size</td>
<td style="text-align:left">返回数组长度</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/slice/#exp._S_slice" target="_blank" rel="external">$slice</a></td>
<td style="text-align:left">根据条件生成子数组</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="变量操作符"><a href="#变量操作符" class="headerlink" title="变量操作符"></a>变量操作符</h4><table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$map</td>
<td style="text-align:left">类似数组的map操作</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/" target="_blank" rel="external">$let</a></td>
<td style="text-align:left">现在<code>var</code>表达式里面定义一组变量，然后再<code>in</code>表达式去操作</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="文字操作符-1"><a href="#文字操作符-1" class="headerlink" title="文字操作符"></a>文字操作符</h4><table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$literal</td>
<td style="text-align:left">一个用途是将操作符’$’作为普通字符使用，另外一个是创建一个新的字段</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="日期操作符"><a href="#日期操作符" class="headerlink" title="日期操作符"></a>日期操作符</h4><table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$dayOfYear</td>
<td style="text-align:left">返回一年中的第几天） 1～366</td>
</tr>
<tr>
<td style="text-align:left">$dayOfMonth</td>
<td style="text-align:left">返回一个月中的第几天 1～31</td>
</tr>
<tr>
<td style="text-align:left">$dayOfWeek</td>
<td style="text-align:left">返回一周的第几天 1～7</td>
</tr>
<tr>
<td style="text-align:left">$year</td>
<td style="text-align:left">返回年份 e.g 2014</td>
</tr>
<tr>
<td style="text-align:left">$month</td>
<td style="text-align:left">返回月份 1~12</td>
</tr>
<tr>
<td style="text-align:left">$week</td>
<td style="text-align:left">一年中的第几周 0~53</td>
</tr>
<tr>
<td style="text-align:left">$hour</td>
<td style="text-align:left">返回日期中的小时 0~23</td>
</tr>
<tr>
<td style="text-align:left">$minute</td>
<td style="text-align:left">返回日期中的分钟数 0~59</td>
</tr>
<tr>
<td style="text-align:left">$second</td>
<td style="text-align:left">返回日期中的秒数 0~60</td>
</tr>
<tr>
<td style="text-align:left">$millisecond</td>
<td style="text-align:left">返回日期的毫秒数 0~999</td>
</tr>
<tr>
<td style="text-align:left">$dateToString</td>
<td style="text-align:left">根据指定的格式返回时间字符串</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h4><table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$cond</td>
<td style="text-align:left">条件操作符，支持if/else，三目运算</td>
</tr>
<tr>
<td style="text-align:left">$ifNull</td>
<td style="text-align:left">如果第一个值是null，那么用第二个值替换它</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="计算操作符"><a href="#计算操作符" class="headerlink" title="计算操作符"></a>计算操作符</h4><table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$sum</td>
<td style="text-align:left">求和</td>
</tr>
<tr>
<td style="text-align:left">$avg</td>
<td style="text-align:left">计算平均值</td>
</tr>
<tr>
<td style="text-align:left">$first</td>
<td style="text-align:left">返回每一组中的第一个文档</td>
</tr>
<tr>
<td style="text-align:left">$last</td>
<td style="text-align:left">返回每一组中的最后一个文档</td>
</tr>
<tr>
<td style="text-align:left">$max</td>
<td style="text-align:left">返回每一组中的最大的文档</td>
</tr>
<tr>
<td style="text-align:left">$min</td>
<td style="text-align:left">返回每一组中的最小的文档</td>
</tr>
<tr>
<td style="text-align:left">$push</td>
<td style="text-align:left">只能在<code>$group</code>中使用，将对应表达式生成的数据压入一个数组返回</td>
</tr>
<tr>
<td style="text-align:left">$addToSet</td>
<td style="text-align:left">类似push，不过集合中的元素不能重复</td>
</tr>
<tr>
<td style="text-align:left">$stdDevPop</td>
<td style="text-align:left">返回输入值的总体标准偏差（没太理解）</td>
</tr>
<tr>
<td style="text-align:left">$stdDevSamp</td>
<td style="text-align:left">返回输入值的样本标准差（没太理解）</td>
</tr>
</tbody>
</table>
<h3 id="BSON文档大小限制"><a href="#BSON文档大小限制" class="headerlink" title="BSON文档大小限制"></a>BSON文档大小限制</h3><p>BSON文档大小限制是16MB，嵌套层数限制是100层。<br>如果需要存储大于16MB的文档，可以使用MongoDB提供的GridFS API。</p>
<h2 id="Aggregation-Pipeline优化"><a href="#Aggregation-Pipeline优化" class="headerlink" title="Aggregation Pipeline优化"></a>Aggregation Pipeline优化</h2><p>MongoDB中，在一个集合上执行的聚合操作，理论上是会传递整个集合的数据到聚合管道中的。为了优化这个操作，尽可能地使用以下几个策略去避免出现操作整个集合数据的情况。</p>
<ul>
<li><p>利用索引<br>在管道入口（第一节管道）利用$match和$sort操作符匹配索引字段。这样后来管道的输入数据就都是过滤过的而且有序的数据。</p>
<blockquote>
<p>2.4之后的版本，$geoNear操作符可以利用地理位置索引操作数据，注意，使用$geoNear操作符的时候，必须在管道第一节中使用。<br>Changed in version 3.2: Starting in MongoDB 3.2, indexes can cover an aggregation pipeline. In MongoDB 2.6 and 3.0, indexes could not cover an aggregation pipeline since even when the pipeline uses an index, aggregation still requires access to the actual documents.（这段我还没有理解）</p>
</blockquote>
</li>
<li><p>尽量早的过滤数据<br>尽量在管道入口执行数据过滤操作，例如$match，$limit，$skip等。</p>
</li>
<li><p>附加功能<br>聚合管道内置优化程序，这部分会在下面进行详细讨论</p>
</li>
</ul>
<h3 id="管道顺序优化"><a href="#管道顺序优化" class="headerlink" title="管道顺序优化"></a>管道顺序优化</h3><ul>
<li>优化程序会自动将$match操作放在在$sort前（当$match紧跟在$sort之后时）</li>
<li>优化程序会将$limit操作放在$skip操作前（skip操作比较耗时，先limit减少输入数据的数量）</li>
<li>优化程序会将$match操作放在$redact操作前</li>
<li>优化程序会将$skip和$limit操作放在$project前</li>
</ul>
<h3 id="管道合并"><a href="#管道合并" class="headerlink" title="管道合并"></a>管道合并</h3><ul>
<li>当$limit操作紧跟在$sort之后的时候，优化程序会将$limit操作合并到$sort中</li>
<li>当一个$limit紧跟在一个$limit之后时候，优化程序会合并两个$limit操作</li>
<li>$skip合并（同上）</li>
<li>$match合并（同上）</li>
<li>当$unwind操作紧跟在$lookup操作，并且$unwind操作的正好是$lookup对应的as字段的时候，优化程序会将这两个操作合并，避免创建过大的內联文档</li>
</ul>
<p>上述优化策略都是聚合管道内置的优化策略来提高 聚合查询性能的</p>
<h2 id="Aggregation-Pipeline限制"><a href="#Aggregation-Pipeline限制" class="headerlink" title="Aggregation Pipeline限制"></a>Aggregation Pipeline限制</h2><p>聚合管道有以下两个查询限制</p>
<ul>
<li>返回结果大小限制<br>从2.6版本开始，聚合管道操作可以返回结果指针或者存储结果到集合中，此时每个文档大小受到BSON文档大小限制，即单个文档不得超过16MB，如果哪个文档超过大小，会返回错误。这个限制只针对返回结果，数据在管道流动过程中，可能会超出这个大小限制。2.6之后聚合管道操作默认返回结果指针</li>
<li>内存占用限制<br>聚合管道操作限制内存为100MB，超出会报错。如果要改变这个大小限制，使用<code>allowDiskUse</code>选项让聚合管道操作可以写入数据到临时文件中</li>
</ul>
<h2 id="Aggregation-Pipeline和Sharded-Collections"><a href="#Aggregation-Pipeline和Sharded-Collections" class="headerlink" title="Aggregation Pipeline和Sharded Collections"></a>Aggregation Pipeline和Sharded Collections</h2><p>聚合管道支持操作分片集合<br>如果管道是以$match开始，而且匹配了片键，那么聚合管道操作将只会操作匹配到的分片的数据。在3.2之前，管道聚合操作会分开，然后在主分片上合并结果。<br>对于必须在多个分片上执行的聚合管道操作，如果操作没有要求必须在主分片上执行，那么管道操作会将结果路由到一个随机的分片上去执行合并操作，避免数据库主分片过载。$out和$lookup操作需要数据库主分片上执行。</p>
<h2 id="Aggregation-Pipeline例子"><a href="#Aggregation-Pipeline例子" class="headerlink" title="Aggregation Pipeline例子"></a>Aggregation Pipeline例子</h2><h2 id="Map-Reduce和Sharded-Collections"><a href="#Map-Reduce和Sharded-Collections" class="headerlink" title="Map-Reduce和Sharded Collections"></a>Map-Reduce和Sharded Collections</h2><h3 id="分片集合作为输入"><a href="#分片集合作为输入" class="headerlink" title="分片集合作为输入"></a>分片集合作为输入</h3><p>当用分片集合作为map-reduce的输入时，mongos会自动并行的分发map-reduce任务到各个分片上。mongos会等待所有分片上的任务完成。</p>
<h3 id="分片集合作为输出"><a href="#分片集合作为输出" class="headerlink" title="分片集合作为输出"></a>分片集合作为输出</h3><p>如果map-reduce的out字段包含了分片的值，MongoDB以<code>_id</code>作为片键对输出集合进行分片，为了将结果输到分片集合中，执行以下操作：</p>
<ul>
<li>如果输出集合不存在，MongoDB会创建集合并以<code>_id</code>为片键进行分片</li>
<li>对于一个新的，或者是空的分片集合，MongoDB使用map-reduce操作第一阶段的操作结果去初始化分给分片的<a href="https://docs.mongodb.com/manual/reference/glossary/#term-chunk" target="_blank" rel="external">chunks</a></li>
<li>mongos并行分发map-reduce后续处理任务到每一个拥有chunk的分片上，在处理期间，每个分片都会从其他分片上拉取处理结果，执行最后的reduce/finalize方法，然后从本地写数据到输出集合</li>
</ul>
<blockquote>
<p>在map-reduce任务处理期间，分片会根据需要切分chunks<br>MongoDB为了避免map-reduce过程中高并发带来的问题，会自动禁用输出集合chunk的平衡操作（可能数据不平均）</p>
</blockquote>
<p> 在MongoDB 2.0中：</p>
<ul>
<li>mongos从各个集合分片中查询数据，然后合并，排序，然后使用reduce/finalize方法处理结果，然后用分片模式写入结果到输出集合中</li>
<li>map-reduce方法是需要使用少量内存，即使在处理大量数据的时候</li>
<li>插入的时候不会自动切割chunks，需要手动操作。</li>
</ul>
<blockquote>
<p>2.2版本之后，为了达到最佳效果，最好只使用map-reduce的分片输出选项</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么使用聚合&quot;&gt;&lt;a href=&quot;#为什么使用聚合&quot; class=&quot;headerlink&quot; title=&quot;为什么使用聚合&quot;&gt;&lt;/a&gt;为什么使用聚合&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;聚合操作的作用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Aggregations operations process data records and return computed results. Aggregation operations group values from multiple documents together, and can perform a variety of operations on the grouped data to return a single result.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的理解是，聚合类的操作提供了一个便捷的计算查询结果的方法。例如你如果使用简单的查询语句可能返回的是一组结果，需要代码去把结果进行计算处理，但是如果使用聚合操作，可以通过一个聚合语句直接返回计算结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这里举一个官网上提供的最简单的例子&lt;/p&gt;
&lt;img title=&quot;聚合操作示例&quot; alt=&quot;聚合操作示例&quot; src=&quot;http://7xj5yf.com1.z0.glb.clouddn.com//images/20161026-01.png?imageView2/2/w/1000&quot;&gt;
&lt;p&gt;如果需要从左边的数据得到右边的结果，一个简单的查询是没有办法做到的，但是聚合操作就可以做到。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="mongodb" scheme="http://cocacola183.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://cocacola183.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>web端用户行为分析初探</title>
    <link href="http://cocacola183.github.io/2016/10/13/web/web%E7%AB%AF%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/"/>
    <id>http://cocacola183.github.io/2016/10/13/web/web端用户行为分析初探/</id>
    <published>2016-10-13T03:55:25.000Z</published>
    <updated>2017-07-02T02:33:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>任意三方网页中插入一段js脚本，采集用户操作相关信息，发送到服务端处理，产出网站用户轨迹图，鼠标热力图，或者是行为还原动画等等。</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>知乎上看到了老鱼分享的文章<br><img title="用户行为分析解决方案" alt="用户行为分析解决方案" src="http://7xj5yf.com1.z0.glb.clouddn.com//images/20161013-01.jpg?imageView2/2/w/1000"></p>
<h3 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h3><ul>
<li>信息采集（终端平台信息，用户操作信息）</li>
<li>跨域请求</li>
<li>用户身份标识+会话控制</li>
</ul>
<a id="more"></a>
<h3 id="相关环境"><a href="#相关环境" class="headerlink" title="相关环境"></a>相关环境</h3><ul>
<li>osx 10.12</li>
<li>chrome.53</li>
<li>node v4.5.0</li>
<li><a href="https://github.com/CocaCola183/web-uba" target="_blank" rel="external">源码</a></li>
</ul>
<h3 id="信息采集"><a href="#信息采集" class="headerlink" title="信息采集"></a>信息采集</h3><ul>
<li>终端信息的获取，暂时用的是这个库<a href="https://github.com/bestiejs/platform.js/" target="_blank" rel="external">platform.js</a>，简单易用，兼容性测试情况：Tested in Chrome 46-47, Firefox 42-43, IE 8-11, Edge 13, Safari 8-9, Node.js 0.10-6, &amp; PhantomJS 1.9.8.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// on IE10 x86 platform preview running in IE7 compatibility mode on Windows 7 64 bit edition</span></div><div class="line">platform.name; <span class="comment">// 'IE'</span></div><div class="line">platform.version; <span class="comment">// '10.0'</span></div><div class="line">platform.layout; <span class="comment">// 'Trident'</span></div><div class="line">platform.os; <span class="comment">// 'Windows Server 2008 R2 / 7 x64'</span></div><div class="line">platform.description; <span class="comment">// 'IE 10.0 x86 (platform preview; running in IE 7 mode) on Windows Server 2008 R2 / 7 x64'</span></div><div class="line"></div><div class="line"><span class="comment">// or on an iPad</span></div><div class="line">platform.name; <span class="comment">// 'Safari'</span></div><div class="line">platform.version; <span class="comment">// '5.1'</span></div><div class="line">platform.product; <span class="comment">// 'iPad'</span></div><div class="line">platform.manufacturer; <span class="comment">// 'Apple'</span></div><div class="line">platform.layout; <span class="comment">// 'WebKit'</span></div><div class="line">platform.os; <span class="comment">// 'iOS 5.0'</span></div><div class="line">platform.description; <span class="comment">// 'Safari 5.1 on Apple iPad (iOS 5.0)'</span></div><div class="line"></div><div class="line"><span class="comment">// or parsing a given UA string</span></div><div class="line"><span class="keyword">var</span> info = platform.parse(<span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7.2; en; rv:2.0) Gecko/20100101 Firefox/4.0 Opera 11.52'</span>);</div><div class="line">info.name; <span class="comment">// 'Opera'</span></div><div class="line">info.version; <span class="comment">// '11.52'</span></div><div class="line">info.layout; <span class="comment">// 'Presto'</span></div><div class="line">info.os; <span class="comment">// 'Mac OS X 10.7.2'</span></div><div class="line">info.description; <span class="comment">// 'Opera 11.52 (identifying as Firefox 4.0) on Mac OS X 10.7.2'</span></div></pre></td></tr></table></figure>
<ul>
<li>用户ip获取，采用的是jsonp的方式，用的是<code>ipify</code>的<code>open api</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ubaip;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 客户端ip获取回调</div><div class="line"> * @param  回调数据</div><div class="line"> * @return null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ubaGetIPCallback</span>(<span class="params">json</span>) </span>&#123;</div><div class="line">  ubaip = json.ip;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * JSONP获取当前ip</div><div class="line"> * @return null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ubaGetIP</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ipScript= <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">  ipScript.type = <span class="string">"text/javascript"</span>;</div><div class="line">  ipScript.src=<span class="string">"https://api.ipify.org?format=jsonp&amp;callback=ubaGetIPCallback"</span>;</div><div class="line">  <span class="built_in">document</span>.body.appendChild(ipScript);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>页面url及停留时长获取，这个比较简单，不在这里做解释了</li>
</ul>
<p>注意，这里没有做鼠标轨迹绘制，用户点击事件的捕捉，先跑通了整个逻辑，后期做完善，优化</p>
<h3 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h3><p>这里解决跨域问题的方案比较简单，像上图所说的，利用<code>src</code>属性可跨域的特点，动态加载一张图片来完成。这中跨域的方法的缺点是只能发起get请求<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*!</span></div><div class="line"> * 跨域请求发送</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 发送get请求</div><div class="line"> * @param  url 请求url</div><div class="line"> * @return null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ubaGet</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">  img.src = url;</div><div class="line">  img.hidden = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 在全局变量中引用img，防止img被垃圾回收机制过早回收造成请求发送失败</span></div><div class="line">  <span class="comment">// var random_id = "_img_" + Math.random();</span></div><div class="line">  <span class="comment">// window[random_id] = img;</span></div><div class="line"></div><div class="line">  <span class="built_in">document</span>.body.appendChild(img);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="用户身份标识-回话控制"><a href="#用户身份标识-回话控制" class="headerlink" title="用户身份标识+回话控制"></a>用户身份标识+回话控制</h3><p>传送到服务端的数据，一次会话(session，我这里设定的是5分钟)是一条记录，记录包括终端，客户的一些信息，还有个<code>setp</code>数组，这个<code>step</code>数组，就记录的用户轨迹。这个是以后需要拓展的重点。</p>
<p>用户这部分，上图描述的是通过<code>apache</code>给用户打标签，<code>nginx</code>也可以实现相同的效果，但是不能运用于上述需求场景。因为我们能做的只能在页面中插入一段脚本而已。</p>
<p>所以用户标记这功能需要手动实现，这就涉及到下面两个问题：</p>
<ol>
<li>uuid的生成</li>
<li>cookie的读写</li>
</ol>
<p>uuid的生成，我查找了一些资料，这里给出一种解决方案（不是最好的）。使用这个库<a href="https://github.com/broofa/node-uuid" target="_blank" rel="external">node-uuid</a></p>
<p>cookie的读写，这里不再解释<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取指定名字的cookie</div><div class="line"> * @param  cookie name</div><div class="line"> * @return cookie</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ubaGetCookie</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> arr, reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^| )"</span>+name+<span class="string">"=([^;]*)(;|$)"</span>);</div><div class="line">  <span class="keyword">if</span>(arr = <span class="built_in">document</span>.cookie.match(reg))</div><div class="line">    <span class="keyword">return</span> <span class="built_in">unescape</span>(arr[<span class="number">2</span>]);</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 标记用户</div><div class="line"> * @param  &#123;[type]&#125;</div><div class="line"> * @return &#123;[type]&#125;</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ubaMarkUser</span>(<span class="params">cookieName</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">  date.setYear(<span class="number">2116</span>);</div><div class="line">  <span class="built_in">document</span>.cookie = cookieName + <span class="string">'='</span> + uuid() + <span class="string">';expires='</span> + date.toGMTString() + <span class="string">';'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="服务端接入"><a href="#服务端接入" class="headerlink" title="服务端接入"></a>服务端接入</h3><p>解决上述问题之后，接入一个简单的<code>node server</code>获取，整理信息然后持久化就可以了。后期还可以添加更高级的数据分析操作。</p>
<h3 id="已经存在的问题"><a href="#已经存在的问题" class="headerlink" title="已经存在的问题"></a>已经存在的问题</h3><ul>
<li>浏览器兼容性全面测试</li>
<li>uuid绝对不会重复的保证（不确定）</li>
<li>cookie禁用后的解决方案</li>
</ul>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul>
<li>用户行为更细粒度的监控（鼠标轨迹，点击事件，鼠标热力图的生成）</li>
<li>用户行为动画还原</li>
<li>根据数据对用户进行分析（打标签）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;p&gt;任意三方网页中插入一段js脚本，采集用户操作相关信息，发送到服务端处理，产出网站用户轨迹图，鼠标热力图，或者是行为还原动画等等。&lt;/p&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;&lt;a href=&quot;#实现思路&quot; class=&quot;headerlink&quot; title=&quot;实现思路&quot;&gt;&lt;/a&gt;实现思路&lt;/h3&gt;&lt;p&gt;知乎上看到了老鱼分享的文章&lt;br&gt;&lt;img title=&quot;用户行为分析解决方案&quot; alt=&quot;用户行为分析解决方案&quot; src=&quot;http://7xj5yf.com1.z0.glb.clouddn.com//images/20161013-01.jpg?imageView2/2/w/1000&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;需要解决的问题&quot;&gt;&lt;a href=&quot;#需要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;需要解决的问题&quot;&gt;&lt;/a&gt;需要解决的问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;信息采集（终端平台信息，用户操作信息）&lt;/li&gt;
&lt;li&gt;跨域请求&lt;/li&gt;
&lt;li&gt;用户身份标识+会话控制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Node.js" scheme="http://cocacola183.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://cocacola183.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>javascript面向对象编程实践</title>
    <link href="http://cocacola183.github.io/2016/10/08/javascript/javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://cocacola183.github.io/2016/10/08/javascript/javascript面向对象编程/</id>
    <published>2016-10-08T07:01:54.000Z</published>
    <updated>2017-07-02T02:31:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是面向对象编程"><a href="#什么是面向对象编程" class="headerlink" title="什么是面向对象编程"></a>什么是面向对象编程</h2><blockquote>
<p>面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程范型，同时也是一种程序开发的方法。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。</p>
</blockquote>
<a id="more"></a>
<h2 id="面向对象编程的基本概念以及js实践"><a href="#面向对象编程的基本概念以及js实践" class="headerlink" title="面向对象编程的基本概念以及js实践"></a>面向对象编程的基本概念以及js实践</h2><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a><strong>类和对象</strong></h3><p><br></p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>类：定义了一件事物的抽象特点，类的定义包含了数据的形式（属性）以及对数据的操作（方法）</li>
<li>对象：类的实例（简单来说），在面向对象程序设计中，对象是程序的基本单元</li>
<li>属性：对象的特征，比如颜色、尺寸等</li>
<li>方法：对象的行为，比如行走、说话等</li>
<li>构造函数：对象初始化的瞬间被调用的方法</li>
</ul>
<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p><strong> 1. 类在面向对象编程中的作用(个人理解) </strong></p>
<ul>
<li>面向对象编程概念中<code>抽象</code>，<code>封装</code>, <code>继承</code>的实现</li>
<li>生成对象</li>
</ul>
<p><strong> 2. 类的使用（或者说是如何在js中实现类的功能）</strong></p>
<blockquote>
<p>javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有<code>class</code>（类）（es6之前）。</p>
</blockquote>
<ul>
<li><p>面向对象编程概念中<code>抽象</code>，<code>封装</code>, <code>继承</code>的实现<br>因为上述原因的存在，在js中可能没有办法像传统OOP语言（C++, java）那样使用关键字<code>class</code>，或者用传统的思路进行OOP，那么需要做的就是寻求替代<code>class</code>应有功能的解决方案。<br>这部分内容，在下文中抽象，封装，继承的章节中会有体现</p>
</li>
<li><p>对象的生成<br>1.对象字面量语法</p>
<div style="background-color: #eee; border: 1px solid #ddd; border-radius: 3px; padding: .5rem;">如果你从来没有接触过对象字面量的写法，可能会感觉怪怪的。但越到后来你就越喜欢它。本质上讲，对象字面量语法包括：<br>  1. 将对象主体包含在一对花括号内（{ 和 }）。<br>  2. 对象内的属性或方法之间使用逗号分隔。最后一个名值对后也可以有逗号，但在IE下会报错，所以尽量不要在最后一个属性或方法后加逗号。<br>  3. 属性名和值之间使用冒号分隔。<br>  4. 如果将对象赋值给一个变量，不要忘了在右括号}之后补上分号。<br></div><br>2.构造函数创建对象/自定义构造函数/构造函数的返回值<br><div></div><br>3.new Object()方法（不推荐使用这种方法）<br><div style="background-color: #eee; border: 1px solid #ddd; border-radius: 3px; padding: .5rem;">创建实例对象时能用对象字面量就不要使用new Object()构造函数，但有时你可能是在别人写的代码基础上工作，这时就需要了解构造函数的一个“特性”（也是不使用它的另一个原因），就是Object()构造函数可以接收参数，通过这个参数可以把对象实例的创建过程委托给另一个内置构造函数，并返回另外一个对象实例，而这往往不是你想要的。<br></div>

</li>
</ul>
<p>以上是创建对象的三种基本的思想（方法），可以进行多种变形。如果对字面量或者是对象创建过程比较感兴趣，可以参考这篇文章<a href="https://github.com/TooBug/javascript.patterns/blob/master/chapter3.markdown" target="_blank" rel="external">第三章 字面量和构造函数</a></p>
<h3 id="抽象"><a href="#抽象" class="headerlink" title=" 抽象 "></a><strong> 抽象 </strong></h3><p><br></p>
<h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>抽象是人们认识事物的常用方法，比如地图的绘制。抽象的过程就是如何简化、概括所观察到的现实世界，并为人们所用的过程。</p>
<p>抽象是软件开发的基础。软件开发离不开现实环境，但需要对信息细节进行提炼、抽象，找到事物的本质和重要属性。</p>
<p>抽象包括两个方面：过程抽象和数据抽象。过程抽象把一个系统按功能划分成若干个子系统，进行”自顶向下逐步求精”的程序设计。数据抽象以数据为中心，把数据类型和施加在该类型对象上的操作作为一个整体（对象）来进行描述，形成抽象数据类型ADT。</p>
<p>所有编程语言的最终目的都是提供一种”抽象”方法。一种较有争议的说法是：解决问题的复杂程度直接取决于抽象的种类及质量。其中，”种类”是指准备对什么进行”抽象”。汇编语言是对基础机器的少量抽象。后来的许多”命令式”语言（如FORTRAN、BASIC和C）是对汇编语言的一种抽象。与汇编语言相比，这些语言已有了较大的进步，但它们的抽象原理依然要求程序设计者着重考虑计算机的结构，而非考虑问题本身的结构。在机器模型（位于”方案空间”）与实际解决的问题模型（位于”问题空间”）之间，程序员必须建立起一种联系。这个过程要求人们付出较大的精力，而且由于它脱离了编程语言本身的范围，造成程序代码很难编写，而且要花较大的代价进行维护。由此造成的副作用便是一门完善的”编程方法”学科。</p>
<p>为机器建模的另一个方法是为要解决的问题制作模型。对一些早期语言来说，如LISP和APL，它们的做法是”从不同的角度观察世界”、”所有问题都归纳为列表”或”所有问题都归纳为算法”。PROLOG则将所有问题都归纳为决策链。对于这些语言，可以认为它们一部分是面向基于”强制”的编程，另一部分则是专为处理图形符号设计的。每种方法都有自己特殊的用途，适合解决某一类的问题。但只要超出了它们力所能及的范围，就会显得非常笨拙。</p>
<p>面向对象的程序设计在此基础上则跨出了一大步，程序员可利用一些工具来表达问题空间内的元素。由于这种表达非常普遍，所以不必受限于特定类型的问题。人们将问题空间中的元素以及它们在方案空间的表示物称作”对象”。当然，还有一些在问题空间没有对应体的其他对象。通过添加新的对象类型，程序可进行灵活的调整，以便与特定的问题配合。所以在阅读方案的描述代码时，会读到对问题进行表达的话语。与以前的方法相比，这无疑是一种更加灵活、更加强大的语言抽象方法。</p>
<p>总之，OOP允许人们根据问题，而不是根据方案来描述问题。然而，仍有一个联系途径回到计算机。每个对象都类似一台小计算机；它们有自己的状态，而且可要求它们进行特定的操作。与现实世界的”对象”或者”物体”相比，编程”对象”与它们也存在共通的地方：它们都有自己的特征和行为。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我的理解，抽象就是现实世界到计算机程序的映射，就是想办法用计算机的方式去描述现实世界的过程。<br>输入现实世界，输出计算机程序可以理解的概念，像“类和对象”里面的例子，输入的是现实世界的猫，输出的是一个有“名字”，“颜色”，“类型”等属性的，有“吃”这个方法的一个计算机程序概念，然后在把这个概念封装成为类，实例化成对象，运行在面向对象程序中。这个输入输出的过程，叫做抽象。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title=" 封装 "></a><strong> 封装 </strong></h3><p><br></p>
<h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>封装是面向对象编程的特征之一，也是类和对象的主要特征。封装将数据以及加在这些数据上的操作组织在一起，成为有独立意义的构件。外部无法直接访问这些封装了的数据，从而保证了这些数据的正确性。如果这些数据发生了差错，也很容易定位错误是由哪个操作引起的。</p>
<p>如果外部需要访问类里面的数据，就必须通过接口（Interface）进行访问。接口规定了可对一个特定的对象发出哪些请求。当然，必须在某个地方存在着一些代码，以便满足这些请求。这些代码与那些隐藏起来的数据叫作”隐藏的实现”。站在过程化程序编写（Procedural Programming）的角度，整个问题并不显得复杂。一种类型含有与每种可能的请求关联起来的函数。一旦向对象发出一个特定的请求，就会调用那个函数。通常将这个过程总结为向对象”发送一条消息”（提出一个请求）。对象的职责就是决定如何对这条消息作出反应（执行相应的代码）。</p>
<p>若任何人都能使用一个类的所有成员，那么可对这个类做任何事情，则没有办法强制他们遵守任何约束–所有东西都会暴露无遗。</p>
<p>有两方面的原因促使了类的编制者控制对成员的访问。第一个原因是防止程序员接触他们不该接触的东西–通常是内部数据类型的设计思想。若只是为了解决特定的问题，用户只需操作接口即可，无需明白这些信息。类向用户提供的实际是一种服务，因为他们很容易就可看出哪些对自己非常重要，以及哪些可忽略不计。进行访问控制的第二个原因是允许库设计人员修改内部结构，不用担心它会对客户程序员造成什么影响。例如，编制者最开始可能设计了一个形式简单的类，以便简化开发。以后又决定进行改写，使其更快地运行。若接口与实现方法早已隔离开，并分别受到保护，就可放心做到这一点，只要求用户重新链接一下即可。</p>
<p>封装考虑的是内部实现，抽象考虑的是外部行为。符合模块化的原则，使得软件的可维护性、扩充性大为改观。</p>
</blockquote>
<h4 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h4><blockquote>
<p>构造函数模式</p>
</blockquote>
<p>为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。<br>所谓”构造函数”，其实就是一个普通函数，但是内部使用了<code>this</code>变量。对构造函数使用<code>new</code>运算符，就能生成实例，并且<code>this</code>变量会绑定在实例对象上（简单来说就是<code>this</code>对象所有的属性，方法，生成的对象都会有）。例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.color = color;</div><div class="line">  <span class="keyword">this</span>.type = <span class="string">'猫科动物'</span>;</div><div class="line">  <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"吃老鼠"</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这就是一个构造函数，生成实例对象:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>,<span class="string">"黄色"</span>);</div><div class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"二毛"</span>,<span class="string">"黑色"</span>);</div><div class="line">alert(cat1.name); <span class="comment">// 大毛</span></div><div class="line">alert(cat1.color); <span class="comment">// 黄色</span></div></pre></td></tr></table></figure></p>
<p>缺点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(cat1.eat == cat2.eat); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出，<code>eat</code>方法被生成了2次，但却是一模一样的内容，所以，构造函数方法实现封装的问题是造成内存浪费</p>
<div style="background-color: #eee; border: 1px solid #ddd; border-radius: 3px; padding: .5rem;">这里补充说明一点：<code>new</code>语句执行的过程<br>  1. 一个新对象被创建。它继承自Cat.prototype.<br>  2. 构造函数 Cat 被执行。执行的时候，相应的传参会被传入，同时上下文(this)会被指定为这个新实例。<br>  3. 如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象，ps：一般情况下构造函数不返回任何值，不过用户如果想覆盖这个返回值，可以自己选择返回一个普通对象来覆盖。当然，返回数组也会覆盖，因为数组也是对象。<br></div>

<blockquote>
<p>prototype模式</p>
</blockquote>
<p>javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。<br>这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.color = color;</div><div class="line">&#125;</div><div class="line">Cat.prototype.type = <span class="string">"猫科动物"</span>;</div><div class="line">Cat.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"吃老鼠"</span>) &#125;;</div></pre></td></tr></table></figure></p>
<p>js常用方法（面向对象相关）</p>
<ol>
<li><code>constructor</code> 获取对象的构造函数</li>
<li><code>instanceof</code> 左边是对象，右边是构造函数，验证原型对象与实例对象之间的关系</li>
<li><code>isPrototypeOf</code> 这个方法用来判断，某个<code>proptotype</code>对象和某个实例之间的关系</li>
<li><code>hasOwnProperty</code> 来判断某一个属性到底是本地属性，还是继承自<code>prototype</code>对象的属性</li>
<li><code>in</code> 判断某个实例是否含有某个属性，不管是不是本地属性</li>
</ol>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>动态<code>属性</code>或<code>方法</code>通过构造函数封装，静态的<code>属性</code>或者<code>方法</code>通过原型封装</p>
<h3 id="继承"><a href="#继承" class="headerlink" title=" 继承 "></a><strong> 继承 </strong></h3><p><br></p>
<h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类的继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且派生类可以修改或增加新的方法使之更适合特殊的需求。这也体现了大自然中一般与特殊的关系。继承性很好地解决了软件的可重用性问题。比如说，所有的Windows应用程序都有一个窗口，它们可以看作都是从一个窗口类派生出来的。但是有的应用程序用于文字处理，有的应用程序用于绘图，这是由于派生出了不同的子类，各个子类添加了不同的特性。</p>
</blockquote>
<h4 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h4><p>继承实践会随着封装的方式在策略上有所不同</p>
<ul>
<li>构造函数封装，继承方式一定要是以下<code>构造函数继承</code>中的一种</li>
<li>原型封装，继承的时候一定要复制父类原型属性方法</li>
<li>构造函数混合原型封装，要保证原型和构造函数的属性方法都要能继承</li>
</ul>
<blockquote>
<p>构造函数继承</p>
</blockquote>
<p>1.构造函数绑定<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.species = <span class="string">"动物"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>) </span>&#123;</div><div class="line">	Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 构造函数绑定重点</span></div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.color = color;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>,<span class="string">"黄色"</span>);</div><div class="line"><span class="built_in">console</span>.log(cat1.species);</div></pre></td></tr></table></figure></p>
<p>小结：本质就是在子类的构造函数中调用父类的构造函数，这种继承方式的缺点是，父类原型上自定义的属性方法，通过构造函数是没有办法继承得到的。</p>
<p>2.prototype<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Cat.prototype = <span class="keyword">new</span> Animal();</div><div class="line">Cat.prototype.constructor = Cat;</div><div class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>,<span class="string">"黄色"</span>);</div><div class="line">alert(cat1.species); <span class="comment">// 动物</span></div></pre></td></tr></table></figure></p>
<p>小结：用父类的实例，替换子类的<code>prototype</code>，并手动纠正构造函数。实例对象拥有构造函数原型的所有属性方法的特点，实现继承。注意，手动纠正<code>constructor</code>的那行代码很重要，如果不写，会造成继承紊乱</p>
<p>3.<del>直接继承<code>prototype</code></del><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123; &#125;</div><div class="line">Animal.prototype.species = <span class="string">'动物'</span>;</div><div class="line"></div><div class="line">Cat.prototype = Animal.prototype;</div><div class="line">Cat.prototype.constructor = Cat;</div><div class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">'大毛'</span>, <span class="string">'黄色'</span>);</div><div class="line">alert(cat1.species); <span class="comment">// 动物</span></div></pre></td></tr></table></figure></p>
<p>小结：这种方法有优点，不用多实例化父类一次了，节省了资源。缺点是，一方面，父类的非静态属性（父类构造函数中添加的属性）没有办法得到继承，另一方面，父类和子类的<code>prototype</code>指向了同一个对象，任何对子类原型的修改都会反映到父类原型上。而且<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Cat.prototype.constructor = Cat;</div><div class="line">alert(Animal.prototype.constructor); <span class="comment">// Cat</span></div></pre></td></tr></table></figure></p>
<p>实际上上面的代码已经将父类的构造函数改掉了，所以个人不推荐这种方法</p>
<p>4.利用空对象作为中介<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">F.prototype = Animal.prototype;</div><div class="line">Cat.prototype = <span class="keyword">new</span> F();</div><div class="line">Cat.prototype.constructor = Cat;</div><div class="line">alert(Animal.prototype.constructor); <span class="comment">// Animal</span></div></pre></td></tr></table></figure></p>
<p>F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。<br>我们将上面的方法，封装成一个函数，便于使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">  F.prototype = Parent.prototype;</div><div class="line">  Child.prototype = <span class="keyword">new</span> F();</div><div class="line">  Child.prototype.constructor = Child;</div><div class="line">  Child.uber = Parent.prototype;</div><div class="line">&#125;</div><div class="line"></div><div class="line">extend(Cat,Animal);</div><div class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>,<span class="string">"黄色"</span>);</div><div class="line">alert(cat1.species); <span class="comment">// 动物</span></div></pre></td></tr></table></figure></p>
<p>另外，说明一点，函数体最后一行意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</p>
<p>小结：修复了3中的问题，也一定程度上解决了内存占用的问题</p>
<p>5.拷贝继承<br>上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。</p>
<p>首先，还是把Animal的所有不变属性，都放到它的prototype对象上。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Animal.prototype.species = <span class="string">"动物"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend2</span>(<span class="params">Child, Parent</span>) </span>&#123; <span class="comment">// 浅拷贝</span></div><div class="line">  <span class="keyword">var</span> p = Parent.prototype;</div><div class="line">  <span class="keyword">var</span> c = Child.prototype;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</div><div class="line">    c[i] = p[i];</div><div class="line">  &#125;</div><div class="line">  c.uber = p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>小结：自己复制父类原型所有属性方法到子类原型实现继承</p>
<blockquote>
<p>非构造函数继承</p>
</blockquote>
<p>1.解决问题的场景：两个对象，希望一个对象能够继承另外一个对象的属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Chinese = &#123;</div><div class="line">  <span class="attr">nation</span>: <span class="string">'中国'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> Doctor = &#123;</div><div class="line">  <span class="attr">career</span>: <span class="string">'医生'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>让医生继承中国<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Doctor = object(Chinese);</div><div class="line">Doctor.career = <span class="string">'医生'</span>;</div><div class="line">alert(Doctor.nation); <span class="comment">//中国</span></div></pre></td></tr></table></figure></p>
<p>小结：原理就是把子对象的<code>prototype</code>属性，指向父对象，从而使得父对象和子对象关联起来。</p>
<p>2.浅拷贝<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendCopy</span>(<span class="params">p</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> c = &#123;&#125;;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123; </div><div class="line">    c[i] = p[i];</div><div class="line">  &#125;</div><div class="line">  c.uber = p;</div><div class="line">  <span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Doctor = extendCopy(Chinese);</div><div class="line">Doctor.career = <span class="string">'医生'</span>;</div><div class="line">alert(Doctor.nation); <span class="comment">// 中国</span></div></pre></td></tr></table></figure></p>
<p>小结：浅拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。</p>
<p>3.深拷贝<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">p, c</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> c = c || &#123;&#125;;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> p[i] === <span class="string">'object'</span>) &#123;</div><div class="line">      c[i] = (p[i].constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</div><div class="line">      deepCopy(p[i], c[i]);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      c[i] = p[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>小结：深拷贝解决了浅拷贝的问题</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>继承构造函数中封装的属性方法:<ol>
<li>构造函数绑定</li>
<li>修改子类原型为父类实例对象</li>
</ol>
</li>
<li>继承原型上封装的属性方法:<ol>
<li>利用空对象复制父类原型</li>
<li>遍历拷贝父类原型</li>
</ol>
</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h3><p><br></p>
<h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>多态性是指允许不同类的对象对同一消息作出响应。比如同样的加法，把两个时间加在一起和把两个整数加在一起肯定完全不同。又比如，同样的选择”编辑”、”粘贴”操作，在字处理程序和绘图程序中有不同的效果。多态性包括参数化多态性和运行时多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好地解决了应用程序函数同名问题。</p>
</blockquote>
<h4 id="实践-3"><a href="#实践-3" class="headerlink" title="实践"></a>实践</h4><p><strong> 1. 参数化多态性 </strong><br>参数化多态性的实现，需要结束<code>function</code>的<code>arguments</code>属性来实现<br><strong> 2. 运行时多态性 </strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> makeSound = <span class="function"><span class="keyword">function</span>(<span class="params">animal</span>) </span>&#123;</div><div class="line">  animal.sound();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Duck = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Duck.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'嘎嘎嘎'</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Chiken = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">Chiken.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'咯咯咯'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">makeSound(<span class="keyword">new</span> Chicken());</div><div class="line">makeSound(<span class="keyword">new</span> Duck());</div></pre></td></tr></table></figure></p>
<p>注意，这里的多态性的实现，并不遵循多态定义中<code>子类重写父类方法，并且子类示可任意例替代父类实例的调用</code>的概念，因为js是动态语言的缘故。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="external">Javascript 面向对象编程（一）：封装</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">Javascript面向对象编程（二）：构造函数的继承</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">Javascript面向对象编程（三）：非构造函数的继承</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1#.E5.8B.95.E6.85.8B.E9.85.8D.E7.BD.AE.E8.88.87.E8.A8.8A.E6.81.AF.E5.82.B3.E9.81.9E.E6.A9.9F.E5.88.B6" target="_blank" rel="external">维基百科-面向对象程序设计</a></li>
<li><a href="http://wwsun.github.io/posts/javascript-oo-summary.html" target="_blank" rel="external">深入解读JavaScript面向对象编程实践</a></li>
<li><a href="http://blog.csdn.net/cancan8538/article/details/8057095" target="_blank" rel="external">面向对象的三个基本特征 和 五种设计原则</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference" target="_blank" rel="external">JavaScript reference MDN</a></li>
<li><a href="https://github.com/TooBug/javascript.patterns/blob/master/chapter3.markdown" target="_blank" rel="external">字面量和构造函数</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是面向对象编程&quot;&gt;&lt;a href=&quot;#什么是面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;什么是面向对象编程&quot;&gt;&lt;/a&gt;什么是面向对象编程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程范型，同时也是一种程序开发的方法。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://cocacola183.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://cocacola183.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
